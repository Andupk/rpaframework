{
    "RPA.Archive": {
        "name": "RPA.Archive",
        "doc": "`Archive` is a library for operating with ZIP and TAR packages.\n\n**Examples**\n\n.. code-block:: robotframework\n\n   *** Settings ***\n   Library  RPA.Archive\n\n   *** Tasks ***\n   Creating a ZIP archive\n      Archive Folder With ZIP   ${CURDIR}${/}tasks  tasks.zip   recursive=True  include=*.robot  exclude=/.*\n      @{files}                  List Archive             tasks.zip\n      FOR  ${file}  IN  ${files}\n         Log  ${file}\n      END\n      Add To Archive            .${/}..${/}missing.robot  tasks.zip\n      &{info}                   Get Archive Info\n\n\n.. code-block:: python\n\n    from RPA.Archive import Archive\n\n    lib = Archive()\n    lib.archive_folder_with_tar('./tasks', 'tasks.tar', recursive=True)\n    files = lib.list_archive('tasks.tar')\n    for file in files:\n       print(file)",
        "version": "",
        "named_args": true,
        "scope": "GLOBAL",
        "generated": "2020-12-01 14:53:06",
        "inits": [],
        "keywords": [
            {
                "name": "Add To Archive",
                "args": [
                    "files: typing.Any",
                    "archive_name: str",
                    "folder: str = None"
                ],
                "doc": "Add file(s) to the archive\n\n:param files: name of the file, or list of files, to add\n:param archive_name: filename of the archive\n:param folder: name of the folder for added file,\n    relative path in the archive\n\nThis keyword adds file or list of files into existing archive. Files\ncan be added to archive structure with relative path using argument `folder`.\n\nExample:\n\n.. code-block:: robotframework\n\n    Add To Archive  extrafile.txt  myfiles.zip\n    Add To Archive  stat.png       archive.tar.gz  images\n    @{files}        Create List    filename1.txt   filename2.txt\n    Add To Archive  ${files}       files.tar",
                "shortdoc": "Add file(s) to the archive",
                "tags": [],
                "matched": true
            },
            {
                "name": "Archive Folder With Tar",
                "args": [
                    "folder: str",
                    "archive_name: str",
                    "recursive: bool = False",
                    "include: str = None",
                    "exclude: str = None"
                ],
                "doc": "Create a tar/tar.gz archive of a folder\n\n:param folder: name of the folder to archive\n:param archive_name: filename of the archive\n:param recursive: should sub directories be included, defaults is False\n:param include: define file pattern to include in the package,\n    by default all files are included\n:param exclude: define file pattern to exclude from the package\n\nThis keyword creates an TAR or TAR.GZ archive of a local folder. Type of archive\nis determined by the file extension. By default subdirectories are not\nincluded, but they can included using `recursive` argument.\n\nTo include only certain files, like TXT files, the argument `include` can be used.\nSimilarly to exclude certain file, like dotfiles, the argument `exclude` can be used.\n\nExample:\n\n.. code-block:: robotframework\n\n    Archive Folder With TAR  ${CURDIR}${/}documents  documents.tar\n    Archive Folder With TAR  ${CURDIR}${/}tasks      tasks.tar.gz   include=*.robot\n    Archive Folder With TAR  ${CURDIR}${/}tasks      tasks.tar      exclude=/.*\n    Archive Folder With TAR  ${CURDIR}${/}documents  documents.tar  recursive=True",
                "shortdoc": "Create a tar/tar.gz archive of a folder",
                "tags": [],
                "matched": true
            },
            {
                "name": "Archive Folder With Zip",
                "args": [
                    "folder: str",
                    "archive_name: str",
                    "recursive: bool = False",
                    "include: str = None",
                    "exclude: str = None",
                    "compression: str = stored"
                ],
                "doc": "Create a zip archive of a folder\n\n:param folder: name of the folder to archive\n:param archive_name: filename of the archive\n:param recursive: should sub directories be included, defaults is False\n:param include: define file pattern to include in the package, defaults to None (means all files)\n:param exclude: define file pattern to exclude from the package, defaults is None\n:param compression: type of package compression method, defaults to \"stored\"\n\nThis keyword creates an ZIP archive of a local folder. By default subdirectories are not\nincluded, but they can included using `recursive` argument.\n\nTo include only certain files, like TXT files, the argument `include` can be used.\nSimilarly to exclude certain file, like dotfiles, the argument `exclude` can be used.\n\nCompression methods:\n\n- stored, default\n- deflated\n- bzip2\n- lzma\n\nExample:\n\n.. code-block:: robotframework\n\n    Archive Folder With Zip  ${CURDIR}${/}documents  mydocs.zip\n    Archive Folder With Zip  ${CURDIR}${/}tasks      robottasks.zip   include=*.robot\n    Archive Folder With Zip  ${CURDIR}${/}tasks      no_dotfiles.zip  exclude=/.*\n    Archive Folder With Zip  ${CURDIR}${/}documents  documents.zip    recursive=True\n    Archive Folder With Zip  ${CURDIR}               packagelzma.zip  compression=lzma\n    Archive Folder With Zip  ${CURDIR}               bzipped.zip      compression=bzip2",
                "shortdoc": "Create a zip archive of a folder",
                "tags": [],
                "matched": true
            },
            {
                "name": "Extract Archive",
                "args": [
                    "archive_name: str",
                    "path: str = None",
                    "members: typing.Any = None"
                ],
                "doc": "Extract files from archive into local directory\n\n:param archive_name: filename of the archive\n:param path: filepath to extract file into, default is current working directory\n:param members: list of files to extract from, by default\n    all files in archive are extracted\n\nThis keyword supports extracting files from zip, tar and tar.gz archives.\n\nBy default file is extracted into current working directory, but `path` argument\ncan be set to define extraction path.\n\nExample:\n\n.. code-block:: robotframework\n\n    Extract Archive    myfiles.zip   ${CURDIR}${/}extracted\n    @{files}           Create List   filename1.txt    filename2.txt\n    Extract Archive    archive.tar   C:${/}myfiles${/}  ${files}",
                "shortdoc": "Extract files from archive into local directory",
                "tags": [],
                "matched": true
            },
            {
                "name": "Extract File From Archive",
                "args": [
                    "filename: str",
                    "archive_name: str",
                    "path: str = None"
                ],
                "doc": "Extract a file from archive into local directory\n\n:param filename: name of the file to extract\n:param archive_name: filename of the archive\n:param path: filepath to extract file into,\n    default is current working directory\n\nThis keyword supports extracting a file from zip, tar and tar.gz archives.\n\nBy default file is extracted into current working directory,\nbut `path` argument can be set to define extraction path.\n\nExample:\n\n.. code-block:: robotframework\n\n    Extract File From Archive    extrafile.txt   myfiles.zip\n    Extract File From Archive    background.png  images.tar.gz  ${CURDIR}${/}extracted",
                "shortdoc": "Extract a file from archive into local directory",
                "tags": [],
                "matched": true
            },
            {
                "name": "Get Archive Info",
                "args": [
                    "archive_name: str"
                ],
                "doc": "Get information about the archive\n\n:param archive_name: filename of the archive\n\nReturns following file attributes in a dictionary:\n\n- filename\n- filemode\n- size\n- mtime\n- last modification time in format `%d.%m.%Y %H:%M:%S`\n\nExample:\n\n.. code-block:: robotframework\n\n    &{archiveinfo}   Get Archive Info    myfiles.zip",
                "shortdoc": "Get information about the archive",
                "tags": [],
                "matched": true
            },
            {
                "name": "List Archive",
                "args": [
                    "archive_name: str"
                ],
                "doc": "List files in an archive\n\n:param archive_name: filename of the archive\n\nReturns list of file, where each file in a list is a dictionary\nwith following attributes:\n\n- name\n- size\n- mtime\n- last modification time in format `%d.%m.%Y %H:%M:%S`\n\nExample:\n\n.. code-block:: robotframework\n\n    @{files}   List Archive    myfiles.zip\n    FOR  ${file}  IN   ${files}\n        Log  ${file}[filename]\n        Log  ${file}[size]\n        Log  ${file}[mtime]\n    END",
                "shortdoc": "List files in an archive",
                "tags": [],
                "matched": true
            }
        ],
        "all_tags": [],
        "contains_tags": false
    },
    "RPA.Browser": {
        "name": "RPA.Browser",
        "doc": "Browser is a web testing library for Robot Framework,\nbased on the popular SeleniumLibrary.\n\nIt uses the Selenium WebDriver modules internally to\ncontrol a web browser. See http://seleniumhq.org for more information\nabout Selenium in general.\n\n= Locating elements =\n\nAll keywords in the browser library that need to interact with an element\non a web page take an argument typically named ``locator`` that specifies\nhow to find the element. Most often the locator is given as a string\nusing the locator syntax described below, but `using WebElements` is\npossible too.\n\n== Locator syntax ==\n\nFinding elements can be done using different strategies\nsuch as the element id, XPath expressions, or CSS selectors. The strategy\ncan either be explicitly specified with a prefix or the strategy can be\nimplicit.\n\n=== Default locator strategy ===\n\nBy default, locators are considered to use the keyword specific default\nlocator strategy. All keywords support finding elements based on ``id``\nand ``name`` attributes, but some keywords support additional attributes\nor other values that make sense in their context. For example, `Click\nLink` supports the ``href`` attribute and the link text and addition\nto the normal ``id`` and ``name``.\n\nExamples:\n\n| `Click Element` | example | # Match based on ``id`` or ``name``.            |\n| `Click Link`    | example | # Match also based on link text and ``href``.   |\n| `Click Button`  | example | # Match based on ``id``, ``name`` or ``value``. |\n\nIf a locator accidentally starts with a prefix recognized as `explicit\nlocator strategy` or `implicit XPath strategy`, it is possible to use\nthe explicit ``default`` prefix to enable the default strategy.\n\nExamples:\n\n| `Click Element` | name:foo         | # Find element with name ``foo``.               |\n| `Click Element` | default:name:foo | # Use default strategy with value ``name:foo``. |\n| `Click Element` | //foo            | # Find element using XPath ``//foo``.           |\n| `Click Element` | default: //foo   | # Use default strategy with value ``//foo``.    |\n\n=== Explicit locator strategy ===\n\nThe explicit locator strategy is specified with a prefix using either\nsyntax ``strategy:value`` or ``strategy=value``. The former syntax\nis preferred because the latter is identical to Robot Framework's\n[http://robotframework.org/robotframework/latest/RobotFrameworkUserGuide.html#named-argument-syntax|\nnamed argument syntax] and that can cause problems. Spaces around\nthe separator are ignored, so ``id:foo``, ``id: foo`` and ``id : foo``\nare all equivalent.\n\nLocator strategies that are supported by default are listed in the table\nbelow. In addition to them, it is possible to register `custom locators`.\n\n| = Strategy = |          = Match based on =         |         = Example =            |\n| id           | Element ``id``.                     | ``id:example``                 |\n| name         | ``name`` attribute.                 | ``name:example``               |\n| identifier   | Either ``id`` or ``name``.          | ``identifier:example``         |\n| class        | Element ``class``.                  | ``class:example``              |\n| tag          | Tag name.                           | ``tag:div``                    |\n| xpath        | XPath expression.                   | ``xpath://div[@id=\"example\"]`` |\n| css          | CSS selector.                       | ``css:div#example``            |\n| dom          | DOM expression.                     | ``dom:document.images[5]``     |\n| link         | Exact text a link has.              | ``link:The example``           |\n| partial link | Partial link text.                  | ``partial link:he ex``         |\n| sizzle       | Sizzle selector deprecated.         | ``sizzle:div.example``         |\n| jquery       | jQuery expression.                  | ``jquery:div.example``         |\n| default      | Keyword specific default behavior.  | ``default:example``            |\n\nSee the `Default locator strategy` section below for more information\nabout how the default strategy works. Using the explicit ``default``\nprefix is only necessary if the locator value itself accidentally\nmatches some of the explicit strategies.\n\nDifferent locator strategies have different pros and cons. Using ids,\neither explicitly like ``id:foo`` or by using the `default locator\nstrategy` simply like ``foo``, is recommended when possible, because\nthe syntax is simple and locating elements by id is fast for browsers.\nIf an element does not have an id or the id is not stable, other\nsolutions need to be used. If an element has a unique tag name or class,\nusing ``tag``, ``class`` or ``css`` strategy like ``tag:h1``,\n``class:example`` or ``css:h1.example`` is often an easy solution. In\nmore complex cases using XPath expressions is typically the best\napproach. They are very powerful but a downside is that they can also\nget complex.\n\nExamples:\n\n| `Click Element` | id:foo                      | # Element with id 'foo'. |\n| `Click Element` | css:div#foo h1              | # h1 element under div with id 'foo'. |\n| `Click Element` | xpath: //div[@id=\"foo\"]//h1 | # Same as the above using XPath, not CSS. |\n| `Click Element` | xpath: //*[contains(text(), \"example\")] | # Element containing text 'example'. |\n\n*NOTE:*\n\n- Using the ``sizzle`` strategy or its alias ``jquery`` requires that\n  the system under test contains the jQuery library.\n\n=== Implicit XPath strategy ===\n\nIf the locator starts with ``//`` or ``(//``, the locator is considered\nto be an XPath expression. In other words, using ``//div`` is equivalent\nto using explicit ``xpath://div``.\n\nExamples:\n\n| `Click Element` | //div[@id=\"foo\"]//h1 |\n| `Click Element` | (//div)[2]           |\n\n== Using WebElements ==\n\nIn addition to specifying a locator as a string, it is possible to use\nSelenium's WebElement objects. This requires first getting a WebElement,\nfor example, by using the `Get WebElement` keyword.\n\n| ${elem} =       | `Get WebElement` | id:example |\n| `Click Element` | ${elem}          |            |\n\n== Custom locators ==\n\nIf more complex lookups are required than what is provided through the\ndefault locators, custom lookup strategies can be created. Using custom\nlocators is a two part process. First, create a keyword that returns\na WebElement that should be acted on:\n\n| Custom Locator Strategy | [Arguments] | ${browser} | ${locator} | ${tag} | ${constraints} |\n|   | ${element}= | Execute Javascript | return window.document.getElementById('${locator}'); |\n|   | [Return] | ${element} |\n\nThis keyword is a reimplementation of the basic functionality of the\n``id`` locator where ``${browser}`` is a reference to a WebDriver\ninstance and ``${locator}`` is the name of the locator strategy. To use\nthis locator, it must first be registered by using the\n`Add Location Strategy` keyword:\n\n| `Add Location Strategy` | custom | Custom Locator Strategy |\n\nThe first argument of `Add Location Strategy` specifies the name of\nthe strategy and it must be unique. After registering the strategy,\nthe usage is the same as with other locators:\n\n| `Click Element` | custom:example |\n\nSee the `Add Location Strategy` keyword for more details.\n\n= Browser and Window =\n\nThere is different conceptual meaning when this library talks\nabout windows or browsers. This chapter explains those differences.\n\n== Browser ==\n\nWhen `Open Browser` or `Create WebDriver` keyword is called, it\nwill create a new Selenium WebDriver instance by using the\n[https://www.seleniumhq.org/docs/03_webdriver.jsp|Selenium WebDriver]\nAPI. In this library's terms, a new browser is created. It is\npossible to start multiple independent browsers (Selenium Webdriver\ninstances) at the same time, by calling `Open Browser` or\n`Create WebDriver` multiple times. These browsers are usually\nindependent of each other and do not share data like cookies,\nsessions or profiles. Typically when the browser starts, it\ncreates a single window which is shown to the user.\n\n== Window ==\n\nWindows are the part of a browser that loads the web site and presents\nit to the user. All content of the site is the content of the window.\nWindows are children of a browser. In this context a browser is a\nsynonym for WebDriver instance. One browser may have multiple\nwindows. Windows can appear as tabs, as separate windows or pop-ups with\ndifferent position and size. Windows belonging to the same browser\ntypically share the sessions detail, like cookies. If there is a\nneed to separate sessions detail, example login with two different\nusers, two browsers (Selenium WebDriver instances) must be created.\nNew windows can be opened example by the application under test or\nby example `Execute Javascript` keyword:\n\n| `Execute Javascript`    window.open()    # Opens a new window with location about:blank\n\nThe example below opens multiple browsers and windows,\nto demonstrate how the different keywords can be used to interact\nwith browsers, and windows attached to these browsers.\n\nStructure:\n| BrowserA\n|            Window 1  (location=https://robotframework.org/)\n|            Window 2  (location=https://robocon.io/)\n|            Window 3  (location=https://github.com/robotframework/)\n|\n| BrowserB\n|            Window 1  (location=https://github.com/)\n\nExample:\n| `Open Browser`       | https://robotframework.org         | ${BROWSER}       | alias=BrowserA   | # BrowserA with first window is opened.                                       |\n| `Execute Javascript` | window.open()                      |                  |                  | # In BrowserA second window is opened.                                        |\n| `Switch Window`      | locator=NEW                        |                  |                  | # Switched to second window in BrowserA                                       |\n| `Go To`              | https://robocon.io                 |                  |                  | # Second window navigates to robocon site.                                    |\n| `Execute Javascript` | window.open()                      |                  |                  | # In BrowserA third window is opened.                                         |\n| ${handle}            | `Switch Window`                    | locator=NEW      |                  | # Switched to third window in BrowserA                                        |\n| `Go To`              | https://github.com/robotframework/ |                  |                  | # Third windows goes to robot framework github site.                          |\n| `Open Browser`       | https://github.com                 | ${BROWSER}       | alias=BrowserB   | # BrowserB with first windows is opened.                                      |\n| ${location}          | `Get Location`                     |                  |                  | # ${location} is: https://www.github.com                                      |\n| `Switch Window`      | ${handle}                          | browser=BrowserA |                  | # BrowserA second windows is selected.                                        |\n| ${location}          | `Get Location`                     |                  |                  | # ${location} = https://robocon.io/                                           |\n| @{locations 1}       | `Get Locations`                    |                  |                  | # By default, lists locations under the currectly active browser (BrowserA).   |\n| @{locations 2}       | `Get Locations`                    |  browser=ALL     |                  | # By using browser=ALL argument keyword list all locations from all browsers. |\n\nThe above example, @{locations 1} contains the following items:\nhttps://robotframework.org/, https://robocon.io/ and\nhttps://github.com/robotframework/'. The @{locations 2}\ncontains the following items: https://robotframework.org/,\nhttps://robocon.io/, https://github.com/robotframework/'\nand 'https://github.com/.\n\n= Timeouts, waits, and delays =\n\nThis section discusses different ways how to wait for elements to\nappear on web pages and to slow down execution speed otherwise.\nIt also explains the `time format` that can be used when setting various\ntimeouts, waits, and delays.\n\n== Timeout ==\n\nThis library contains various keywords that have an optional\n``timeout`` argument that specifies how long these keywords should\nwait for certain events or actions. These keywords include, for example,\n``Wait ...`` keywords and keywords related to alerts. Additionally\n`Execute Async Javascript`. Although it does not have ``timeout``,\nargument, uses a timeout to define how long asynchronous JavaScript\ncan run.\n\nThe default timeout these keywords use can be set globally either by\nusing the `Set Selenium Timeout` keyword or with the ``timeout`` argument\nwhen `importing` the library. See `time format` below for supported\ntimeout syntax.\n\n== Implicit wait ==\n\nImplicit wait specifies the maximum time how long Selenium waits when\nsearching for elements. It can be set by using the `Set Selenium Implicit\nWait` keyword or with the ``implicit_wait`` argument when `importing`\nthe library. See [https://www.seleniumhq.org/docs/04_webdriver_advanced.jsp|Selenium documentation]\nfor more information about this functionality.\n\nSee `time format` below for supported syntax.\n\n== Selenium speed ==\n\nSelenium execution speed can be slowed down globally by using `Set\nSelenium speed` keyword. This functionality is designed to be used for\ndemonstrating or debugging purposes. Using it to make sure that elements\nappear on a page is not a good idea. The above-explained timeouts\nand waits should be used instead.\n\nSee `time format` below for supported syntax.\n\n== Time format ==\n\nAll timeouts and waits can be given as numbers considered seconds\n(e.g. ``0.5`` or ``42``) or in Robot Framework's time syntax\n(e.g. ``1.5 seconds`` or ``1 min 30 s``). For more information about\nthe time syntax see the\n[http://robotframework.org/robotframework/latest/RobotFrameworkUserGuide.html#time-format|Robot Framework User Guide].\n\n= Run-on-failure functionality =\n\nThis library has a handy feature that it can automatically execute\na keyword if any of its own keywords fails. By default, it uses the\n`Capture Page Screenshot` keyword, but this can be changed either by\nusing the `Register Keyword To Run On Failure` keyword or with the\n``run_on_failure`` argument when `importing` the library. It is\npossible to use any keyword from any imported library or resource file.\n\nThe run-on-failure functionality can be disabled by using a special value\n``NOTHING`` or anything considered false (see `Boolean arguments`)\nsuch as ``NONE``.\n\n= Boolean arguments =\n\nSome keywords accept arguments that are handled as Boolean values true or\nfalse. If such an argument is given as a string, it is considered false if\nit is either empty or case-insensitively equal to ``false``, ``no``, ``off``,\n ``0`` or ``none``. Other strings are considered true regardless of their value and\nother argument types are tested using the same\n[https://docs.python.org/3/library/stdtypes.html#truth-value-testing|rules as in Python].\n\nTrue examples:\n\n| `Set Screenshot Directory` | ${RESULTS} | persist=True    | # Strings are generally true.    |\n| `Set Screenshot Directory` | ${RESULTS} | persist=yes     | # Same as the above.             |\n| `Set Screenshot Directory` | ${RESULTS} | persist=${TRUE} | # Python True is true.           |\n| `Set Screenshot Directory` | ${RESULTS} | persist=${42}   | # Numbers other than 0 are true. |\n\nFalse examples:\n\n| `Set Screenshot Directory` | ${RESULTS} | persist=False    | # String false is false.        |\n| `Set Screenshot Directory` | ${RESULTS} | persist=no       | # Also string no is false.      |\n| `Set Screenshot Directory` | ${RESULTS} | persist=NONE     | # String NONE is false.         |\n| `Set Screenshot Directory` | ${RESULTS} | persist=${EMPTY} | # Empty string is false.        |\n| `Set Screenshot Directory` | ${RESULTS} | persist=${FALSE} | # Python False is false.        |\n| `Set Screenshot Directory` | ${RESULTS} | persist=${NONE}  | # Python None is false.         |",
        "version": "4.5.0",
        "named_args": true,
        "scope": "GLOBAL",
        "generated": "2020-12-01 14:53:06",
        "inits": [
            {
                "name": "Init",
                "args": [
                    "*args",
                    "**kwargs"
                ],
                "doc": "SeleniumLibrary can be imported with several optional arguments.\n\n- ``timeout``:\n  Default value for `timeouts` used with ``Wait ...`` keywords.\n- ``implicit_wait``:\n  Default value for `implicit wait` used when locating elements.\n- ``run_on_failure``:\n  Default action for the `run-on-failure functionality`.\n- ``screenshot_root_directory``:\n  Path to folder where possible screenshots are created or EMBED.\n  See `Set Screenshot Directory` keyword for further details about EMBED.\n  If not given, the directory where the log file is written is used.\n- ``plugins``:\n  Allows extending the SeleniumLibrary with external Python classes.\n- ``event_firing_webdriver``:\n  Class for wrapping Selenium with\n  [https://seleniumhq.github.io/selenium/docs/api/py/webdriver_support/selenium.webdriver.support.event_firing_webdriver.html#module-selenium.webdriver.support.event_firing_webdriver|EventFiringWebDriver]",
                "shortdoc": "SeleniumLibrary can be imported with several optional arguments.",
                "tags": [],
                "matched": true
            }
        ],
        "keywords": [
            {
                "name": "Add Cookie",
                "args": [
                    "name",
                    "value",
                    "path=None",
                    "domain=None",
                    "secure=None",
                    "expiry=None"
                ],
                "doc": "Adds a cookie to your current session.\n\n``name`` and ``value`` are required, ``path``, ``domain``, ``secure``\nand ``expiry`` are optional.  Expiry supports the same formats as\nthe [http://robotframework.org/robotframework/latest/libraries/DateTime.html|DateTime]\nlibrary or an epoch timestamp.\n\nExample:\n| `Add Cookie` | foo | bar |                            |\n| `Add Cookie` | foo | bar | domain=example.com         |\n| `Add Cookie` | foo | bar | expiry=2027-09-28 16:21:35 | # Expiry as timestamp.     |\n| `Add Cookie` | foo | bar | expiry=1822137695          | # Expiry as epoch seconds. |\n\nPrior to SeleniumLibrary 3.0 setting expiry did not work.",
                "shortdoc": "Adds a cookie to your current session.",
                "tags": [],
                "matched": true
            },
            {
                "name": "Add Location Strategy",
                "args": [
                    "strategy_name",
                    "strategy_keyword",
                    "persist=False"
                ],
                "doc": "Adds a custom location strategy.\n\nSee `Custom locators` for information on how to create and use\ncustom strategies. `Remove Location Strategy` can be used to\nremove a registered strategy.\n\nLocation strategies are automatically removed after leaving the\ncurrent scope by default. Setting ``persist`` to a true value (see\n`Boolean arguments`) will cause the location strategy to stay\nregistered throughout the life of the test.",
                "shortdoc": "Adds a custom location strategy.",
                "tags": [],
                "matched": true
            },
            {
                "name": "Alert Should Be Present",
                "args": [
                    "text=",
                    "action=ACCEPT",
                    "timeout=None"
                ],
                "doc": "Verifies that an alert is present and by default, accepts it.\n\nFails if no alert is present. If ``text`` is a non-empty string,\nthen it is used to verify alert's message. The alert is accepted\nby default, but that behavior can be controlled by using the\n``action`` argument same way as with `Handle Alert`.\n\n``timeout`` specifies how long to wait for the alert to appear.\nIf it is not given, the global default `timeout` is used instead.\n\n``action`` and ``timeout`` arguments are new in SeleniumLibrary 3.0.\nIn earlier versions, the alert was always accepted and a timeout was\nhardcoded to one second.",
                "shortdoc": "Verifies that an alert is present and by default, accepts it.",
                "tags": [],
                "matched": true
            },
            {
                "name": "Alert Should Not Be Present",
                "args": [
                    "action=ACCEPT",
                    "timeout=0"
                ],
                "doc": "Verifies that no alert is present.\n\nIf the alert actually exists, the ``action`` argument determines\nhow it should be handled. By default, the alert is accepted, but\nit can be also dismissed or left open the same way as with the\n`Handle Alert` keyword.\n\n``timeout`` specifies how long to wait for the alert to appear.\nBy default, is not waited for the alert at all, but a custom time can\nbe given if alert may be delayed. See the `time format` section\nfor information about the syntax.\n\nNew in SeleniumLibrary 3.0.",
                "shortdoc": "Verifies that no alert is present.",
                "tags": [],
                "matched": true
            },
            {
                "name": "Assign Id To Element",
                "args": [
                    "locator",
                    "id"
                ],
                "doc": "Assigns a temporary ``id`` to the element specified by ``locator``.\n\nThis is mainly useful if the locator is complicated and/or slow XPath\nexpression and it is needed multiple times. Identifier expires when\nthe page is reloaded.\n\nSee the `Locating elements` section for details about the locator\nsyntax.\n\nExample:\n| `Assign ID to Element` | //ul[@class='example' and ./li[contains(., 'Stuff')]] | my id |\n| `Page Should Contain Element` | my id |",
                "shortdoc": "Assigns a temporary ``id`` to the element specified by ``locator``.",
                "tags": [],
                "matched": true
            },
            {
                "name": "Attach Chrome Browser",
                "args": [
                    "port: int",
                    "alias: str = None"
                ],
                "doc": "Attach to an existing instance of Chrome or Chromium.\n\nRequires that the browser was started with the command line\noption ``--remote-debugging-port=<port>``, where port is any\n4-digit number not being used by other applications.\n\nThat port can then be used to connect using this keyword.\n\nExample:\n\n| Attach Chrome Browser | port=9222 |",
                "shortdoc": "Attach to an existing instance of Chrome or Chromium.",
                "tags": [],
                "matched": true
            },
            {
                "name": "Capture Element Screenshot",
                "args": [
                    "locator",
                    "filename=selenium-element-screenshot-{index}.png"
                ],
                "doc": "Captures a screenshot from the element identified by ``locator`` and embeds it into log file.\n\nSee `Capture Page Screenshot` for details about ``filename`` argument.\nSee the `Locating elements` section for details about the locator\nsyntax.\n\nAn absolute path to the created element screenshot is returned.\n\nSupport for capturing the screenshot from an element has limited support\namong browser vendors. Please check the browser vendor driver documentation\ndoes the browser support capturing a screenshot from an element.\n\nNew in SeleniumLibrary 3.3. Support for EMBED is new in SeleniumLibrary 4.2.\n\nExamples:\n| `Capture Element Screenshot` | id:image_id |                                |\n| `Capture Element Screenshot` | id:image_id | ${OUTPUTDIR}/id_image_id-1.png |\n| `Capture Element Screenshot` | id:image_id | EMBED                          |",
                "shortdoc": "Captures a screenshot from the element identified by ``locator`` and embeds it into log file.",
                "tags": [],
                "matched": true
            },
            {
                "name": "Capture Page Screenshot",
                "args": [
                    "filename=selenium-screenshot-{index}.png"
                ],
                "doc": "Takes a screenshot of the current page and embeds it into a log file.\n\n``filename`` argument specifies the name of the file to write the\nscreenshot into. The directory where screenshots are saved can be\nset when `importing` the library or by using the `Set Screenshot\nDirectory` keyword. If the directory is not configured, screenshots\nare saved to the same directory where Robot Framework's log file is\nwritten.\n\nIf ``filename`` equals to EMBED (case insensitive), then screenshot\nis embedded as Base64 image to the log.html. In this case file is not\ncreated in the filesystem.\n\nStarting from SeleniumLibrary 1.8, if ``filename`` contains marker\n``{index}``, it will be automatically replaced with an unique running\nindex, preventing files to be overwritten. Indices start from 1,\nand how they are represented can be customized using Python's\n[https://docs.python.org/3/library/string.html#format-string-syntax|\nformat string syntax].\n\nAn absolute path to the created screenshot file is returned or if\n``filename``  equals to EMBED, word `EMBED` is returned.\n\nSupport for EMBED is new in SeleniumLibrary 4.2\n\nExamples:\n| `Capture Page Screenshot` |                                        |\n| `File Should Exist`       | ${OUTPUTDIR}/selenium-screenshot-1.png |\n| ${path} =                 | `Capture Page Screenshot`              |\n| `File Should Exist`       | ${OUTPUTDIR}/selenium-screenshot-2.png |\n| `File Should Exist`       | ${path}                                |\n| `Capture Page Screenshot` | custom_name.png                        |\n| `File Should Exist`       | ${OUTPUTDIR}/custom_name.png           |\n| `Capture Page Screenshot` | custom_with_index_{index}.png          |\n| `File Should Exist`       | ${OUTPUTDIR}/custom_with_index_1.png   |\n| `Capture Page Screenshot` | formatted_index_{index:03}.png         |\n| `File Should Exist`       | ${OUTPUTDIR}/formatted_index_001.png   |\n| `Capture Page Screenshot` | EMBED                                  |\n| `File Should Not Exist`   | EMBED                                  |",
                "shortdoc": "Takes a screenshot of the current page and embeds it into a log file.",
                "tags": [],
                "matched": true
            },
            {
                "name": "Checkbox Should Be Selected",
                "args": [
                    "locator"
                ],
                "doc": "Verifies checkbox ``locator`` is selected/checked.\n\nSee the `Locating elements` section for details about the locator\nsyntax.",
                "shortdoc": "Verifies checkbox ``locator`` is selected/checked.",
                "tags": [],
                "matched": true
            },
            {
                "name": "Checkbox Should Not Be Selected",
                "args": [
                    "locator"
                ],
                "doc": "Verifies checkbox ``locator`` is not selected/checked.\n\nSee the `Locating elements` section for details about the locator\nsyntax.",
                "shortdoc": "Verifies checkbox ``locator`` is not selected/checked.",
                "tags": [],
                "matched": true
            },
            {
                "name": "Choose File",
                "args": [
                    "locator",
                    "file_path"
                ],
                "doc": "Inputs the ``file_path`` into the file input field ``locator``.\n\nThis keyword is most often used to input files into upload forms.\nThe keyword does not check ``file_path`` is the file or folder\navailable on the machine where tests are executed. If the ``file_path``\npoints at a file and when using Selenium Grid, Selenium will\n[https://seleniumhq.github.io/selenium/docs/api/py/webdriver_remote/selenium.webdriver.remote.command.html?highlight=upload#selenium.webdriver.remote.command.Command.UPLOAD_FILE|magically],\ntransfer the file from the machine where the tests are executed\nto the Selenium Grid node where the browser is running.\nThen Selenium will send the file path, from the nodes file\nsystem, to the browser.\n\nThat ``file_path`` is not checked, is new in SeleniumLibrary 4.0.\n\nExample:\n| `Choose File` | my_upload_field | ${CURDIR}/trades.csv |",
                "shortdoc": "Inputs the ``file_path`` into the file input field ``locator``.",
                "tags": [],
                "matched": true
            },
            {
                "name": "Clear All Highlights",
                "args": [],
                "doc": "Remove all highlighting made by ``Highlight Elements``.",
                "shortdoc": "Remove all highlighting made by ``Highlight Elements``.",
                "tags": [],
                "matched": true
            },
            {
                "name": "Clear Element Text",
                "args": [
                    "locator"
                ],
                "doc": "Clears the value of the text-input-element identified by ``locator``.\n\nSee the `Locating elements` section for details about the locator\nsyntax.",
                "shortdoc": "Clears the value of the text-input-element identified by ``locator``.",
                "tags": [],
                "matched": true
            },
            {
                "name": "Click Button",
                "args": [
                    "locator",
                    "modifier=False"
                ],
                "doc": "Clicks the button identified by ``locator``.\n\nSee the `Locating elements` section for details about the locator\nsyntax. When using the default locator strategy, buttons are\nsearched using ``id``, ``name``, and ``value``.\n\nSee the `Click Element` keyword for details about the\n``modifier`` argument.\n\nThe ``modifier`` argument is new in SeleniumLibrary 3.3",
                "shortdoc": "Clicks the button identified by ``locator``.",
                "tags": [],
                "matched": true
            },
            {
                "name": "Click Button When Visible",
                "args": [
                    "locator: str",
                    "modifier: str = None"
                ],
                "doc": "Click button identified by ``locator``, once it becomes visible.\n\n``locator`` element locator\n\n``modifier`` press given keys while clicking the element, e.g. CTRL\n\nExample:\n\n| Click Button When Visible  | //button[@class=\"mybutton\"] |",
                "shortdoc": "Click button identified by ``locator``, once it becomes visible.",
                "tags": [],
                "matched": true
            },
            {
                "name": "Click Element",
                "args": [
                    "locator",
                    "modifier=False",
                    "action_chain=False"
                ],
                "doc": "Click the element identified by ``locator``.\n\nSee the `Locating elements` section for details about the locator\nsyntax.\n\nThe ``modifier`` argument can be used to pass\n[https://seleniumhq.github.io/selenium/docs/api/py/webdriver/selenium.webdriver.common.keys.html#selenium.webdriver.common.keys.Keys|Selenium Keys]\nwhen clicking the element. The `+` can be used as a separator\nfor different Selenium Keys. The `CTRL` is internally translated to\nthe `CONTROL` key. The ``modifier`` is space and case insensitive, example\n\"alt\" and \" aLt \" are supported formats to\n[https://seleniumhq.github.io/selenium/docs/api/py/webdriver/selenium.webdriver.common.keys.html#selenium.webdriver.common.keys.Keys.ALT|ALT key]\n. If ``modifier`` does not match to Selenium Keys, keyword fails.\n\nIf ``action_chain`` argument is true, see `Boolean arguments` for more\ndetails on how to set boolean argument, then keyword uses ActionChain\nbased click instead of the <web_element>.click() function. If both\n``action_chain`` and ``modifier`` are defined, the click will be\nperformed using ``modifier`` and ``action_chain`` will be ignored.\n\nExample:\n| Click Element | id:button |                   | # Would click element without any modifiers.               |\n| Click Element | id:button | CTRL              | # Would click element with CTLR key pressed down.          |\n| Click Element | id:button | CTRL+ALT          | # Would click element with CTLR and ALT keys pressed down. |\n| Click Element | id:button | action_chain=True | # Clicks the button using an Selenium  ActionChains        |\n\nThe ``modifier`` argument is new in SeleniumLibrary 3.2\nThe ``action_chain`` argument is new in SeleniumLibrary 4.1",
                "shortdoc": "Click the element identified by ``locator``.",
                "tags": [],
                "matched": true
            },
            {
                "name": "Click Element At Coordinates",
                "args": [
                    "locator",
                    "xoffset",
                    "yoffset"
                ],
                "doc": "Click the element ``locator`` at ``xoffset/yoffset``.\n\nThe Cursor is moved and the center of the element and x/y coordinates are\ncalculated from that point.\n\nSee the `Locating elements` section for details about the locator\nsyntax.",
                "shortdoc": "Click the element ``locator`` at ``xoffset/yoffset``.",
                "tags": [],
                "matched": true
            },
            {
                "name": "Click Element If Visible",
                "args": [
                    "locator: str"
                ],
                "doc": "Click element if it is visible\n\n``locator`` element locator\n\nExample:\n\n| Click Element If Visible | //button[@class=\"mybutton\"] |",
                "shortdoc": "Click element if it is visible",
                "tags": [],
                "matched": true
            },
            {
                "name": "Click Element When Visible",
                "args": [
                    "locator: str",
                    "modifier: str = None",
                    "action_chain: bool = False"
                ],
                "doc": "Click element identified by ``locator``, once it becomes visible.\n\n``locator`` element locator\n\n``modifier`` press given keys while clicking the element, e.g. CTRL\n\n``action_chain`` store action in Selenium ActionChain queue\n\nExample:\n\n| Click Element When Visible | q |\n| Click Element When Visible | id:button | CTRL+ALT |\n| Click Element When Visible | action_chain=True |",
                "shortdoc": "Click element identified by ``locator``, once it becomes visible.",
                "tags": [],
                "matched": true
            },
            {
                "name": "Click Image",
                "args": [
                    "locator",
                    "modifier=False"
                ],
                "doc": "Clicks an image identified by ``locator``.\n\nSee the `Locating elements` section for details about the locator\nsyntax. When using the default locator strategy, images are searched\nusing ``id``, ``name``, ``src`` and ``alt``.\n\nSee the `Click Element` keyword for details about the\n``modifier`` argument.\n\nThe ``modifier`` argument is new in SeleniumLibrary 3.3",
                "shortdoc": "Clicks an image identified by ``locator``.",
                "tags": [],
                "matched": true
            },
            {
                "name": "Click Link",
                "args": [
                    "locator",
                    "modifier=False"
                ],
                "doc": "Clicks a link identified by ``locator``.\n\nSee the `Locating elements` section for details about the locator\nsyntax. When using the default locator strategy, links are searched\nusing ``id``, ``name``, ``href`` and the link text.\n\nSee the `Click Element` keyword for details about the\n``modifier`` argument.\n\nThe ``modifier`` argument is new in SeleniumLibrary 3.3",
                "shortdoc": "Clicks a link identified by ``locator``.",
                "tags": [],
                "matched": true
            },
            {
                "name": "Close All Browsers",
                "args": [],
                "doc": "Closes all open browsers and resets the browser cache.\n\nAfter this keyword, new indexes returned from `Open Browser` keyword\nare reset to 1.\n\nThis keyword should be used in test or suite teardown to make sure\nall browsers are closed.",
                "shortdoc": "Closes all open browsers and resets the browser cache.",
                "tags": [],
                "matched": true
            },
            {
                "name": "Close Browser",
                "args": [],
                "doc": "Closes the current browser.",
                "shortdoc": "Closes the current browser.",
                "tags": [],
                "matched": true
            },
            {
                "name": "Close Window",
                "args": [],
                "doc": "Closes currently opened and selected browser window/tab.",
                "shortdoc": "Closes currently opened and selected browser window/tab.",
                "tags": [],
                "matched": true
            },
            {
                "name": "Cover Element",
                "args": [
                    "locator"
                ],
                "doc": "Will cover elements identified by ``locator`` with a blue div without breaking page layout.\n\nSee the `Locating elements` section for details about the locator\nsyntax.\n\nNew in SeleniumLibrary 3.3.0\n\nExample:\n|`Cover Element` | css:div#container |",
                "shortdoc": "Will cover elements identified by ``locator`` with a blue div without breaking page layout.",
                "tags": [],
                "matched": true
            },
            {
                "name": "Create Webdriver",
                "args": [
                    "driver_name",
                    "alias=None",
                    "kwargs={}",
                    "**init_kwargs"
                ],
                "doc": "Creates an instance of Selenium WebDriver.\n\nLike `Open Browser`, but allows passing arguments to the created\nWebDriver instance directly. This keyword should only be used if\nthe functionality provided by `Open Browser` is not adequate.\n\n``driver_name`` must be a WebDriver implementation name like Firefox,\nChrome, Ie, Opera, Safari, PhantomJS, or Remote.\n\nThe initialized WebDriver can be configured either with a Python\ndictionary ``kwargs`` or by using keyword arguments ``**init_kwargs``.\nThese arguments are passed directly to WebDriver without any\nprocessing. See [https://seleniumhq.github.io/selenium/docs/api/py/api.html|\nSelenium API documentation] for details about the supported arguments.\n\nExamples:\n| # Use proxy with Firefox   |                |                              |                                      |\n| ${proxy}=                  | `Evaluate`     | selenium.webdriver.Proxy()   | modules=selenium, selenium.webdriver |\n| ${proxy.http_proxy}=       | `Set Variable` | localhost:8888               |                                      |\n| `Create Webdriver`         | Firefox        | proxy=${proxy}               |                                      |\n| # Use proxy with PhantomJS |                |                              |                                      |\n| ${service args}=           | `Create List`  | --proxy=192.168.132.104:8888 |                                      |\n| `Create Webdriver`         | PhantomJS      | service_args=${service args} |                                      |\n\nReturns the index of this browser instance which can be used later to\nswitch back to it. Index starts from 1 and is reset back to it when\n`Close All Browsers` keyword is used. See `Switch Browser` for an\nexample.",
                "shortdoc": "Creates an instance of Selenium WebDriver.",
                "tags": [],
                "matched": true
            },
            {
                "name": "Current Frame Should Contain",
                "args": [
                    "text",
                    "loglevel=TRACE"
                ],
                "doc": "Verifies that the current frame contains ``text``.\n\nSee `Page Should Contain` for an explanation about the ``loglevel``\nargument.\n\nPrior to SeleniumLibrary 3.0 this keyword was named\n`Current Frame Contains`.",
                "shortdoc": "Verifies that the current frame contains ``text``.",
                "tags": [],
                "matched": true
            },
            {
                "name": "Current Frame Should Not Contain",
                "args": [
                    "text",
                    "loglevel=TRACE"
                ],
                "doc": "Verifies that the current frame does not contain ``text``.\n\nSee `Page Should Contain` for an explanation about the ``loglevel``\nargument.",
                "shortdoc": "Verifies that the current frame does not contain ``text``.",
                "tags": [],
                "matched": true
            },
            {
                "name": "Delete All Cookies",
                "args": [],
                "doc": "Deletes all cookies.",
                "shortdoc": "Deletes all cookies.",
                "tags": [],
                "matched": true
            },
            {
                "name": "Delete Cookie",
                "args": [
                    "name"
                ],
                "doc": "Deletes the cookie matching ``name``.\n\nIf the cookie is not found, nothing happens.",
                "shortdoc": "Deletes the cookie matching ``name``.",
                "tags": [],
                "matched": true
            },
            {
                "name": "Does Alert Contain",
                "args": [
                    "text: str = None",
                    "timeout: float = None"
                ],
                "doc": "Does alert contain text.\n\n``text`` check if alert includes text, will raise ValueError is text\ndoes not exist\n\nExample:\n\n| ${res} | Does Alert Contain | alert message |",
                "shortdoc": "Does alert contain text.",
                "tags": [],
                "matched": true
            },
            {
                "name": "Does Alert Not Contain",
                "args": [
                    "text: str = None",
                    "timeout: float = None"
                ],
                "doc": "Does alert not contain text.\n\n``text`` check that alert does not include text, will raise ValueError if text\ndoes exist\n\nExample:\n\n| ${res} | Does Alert Not Contain | unexpected message |",
                "shortdoc": "Does alert not contain text.",
                "tags": [],
                "matched": true
            },
            {
                "name": "Does Element Contain",
                "args": [
                    "locator: str",
                    "expected: str",
                    "ignore_case: bool = False"
                ],
                "doc": "Does element contain expected text\n\n``locator`` element locator\n\n``expected`` expected element text\n\n``ignore_case`` should check be case insensitive, default `False`\n\nExample:\n\n| ${res} | Does Element Contain | id:spec | specification complete | ignore_case=True |",
                "shortdoc": "Does element contain expected text",
                "tags": [],
                "matched": true
            },
            {
                "name": "Does Frame Contain",
                "args": [
                    "locator: str",
                    "text: str"
                ],
                "doc": "Does frame contain expected text\n\n``locator`` locator of the frame to check\n\n``text`` does frame contain this text\n\nExample:\n\n| ${res} | Does Frame Contain | id:myframe | secret |",
                "shortdoc": "Does frame contain expected text",
                "tags": [],
                "matched": true
            },
            {
                "name": "Does Location Contain",
                "args": [
                    "expected: str"
                ],
                "doc": "Does current URL contain expected\n\n``expected`` URL should contain this\n\nExample:\n\n| Open Available Browser | https://robocorp.com |\n| ${res} | Does Location Contain | robocorp |",
                "shortdoc": "Does current URL contain expected",
                "tags": [],
                "matched": true
            },
            {
                "name": "Does Page Contain",
                "args": [
                    "text: str"
                ],
                "doc": "Does page contain expected text\n\n``text`` page should contain this\n\nExample:\n\n| Open Available Browser | https://google.com |\n| ${res} | Does Page Contain | Gmail |",
                "shortdoc": "Does page contain expected text",
                "tags": [],
                "matched": true
            },
            {
                "name": "Does Page Contain Button",
                "args": [
                    "locator: str"
                ],
                "doc": "Does page contain expected button\n\n``locator`` element locator\n\nExample:\n\n| ${res} | Does Page Contain Button | search-button |",
                "shortdoc": "Does page contain expected button",
                "tags": [],
                "matched": true
            },
            {
                "name": "Does Page Contain Checkbox",
                "args": [
                    "locator: str"
                ],
                "doc": "Does page contain expected checkbox\n\n``locator`` element locator\n\nExample:\n\n| ${res} | Does Page Contain Checkbox | random-selection |",
                "shortdoc": "Does page contain expected checkbox",
                "tags": [],
                "matched": true
            },
            {
                "name": "Does Page Contain Element",
                "args": [
                    "locator: str",
                    "count: int = None"
                ],
                "doc": "Does page contain expected element\n\n``locator`` element locator\n\n``count`` how many times element is expected to appear on page\nby default one or more\n\nExample:\n\n| ${res} | Does Page Contain Element | textarea |\n| ${res} | Does Page Contain Element | button | count=4 |",
                "shortdoc": "Does page contain expected element",
                "tags": [],
                "matched": true
            },
            {
                "name": "Does Page Contain Image",
                "args": [
                    "locator: str"
                ],
                "doc": "Does page contain expected image\n\n``locator`` element locator\n\nExample:\n\n| Open Available Browser | https://google.com |\n| ${res} | Does Page Contain Image | Google |",
                "shortdoc": "Does page contain expected image",
                "tags": [],
                "matched": true
            },
            {
                "name": "Does Page Contain Link",
                "args": [
                    "locator: str"
                ],
                "doc": "Does page contain expected link\n\n``locator`` element locator\n\nExample:\n\n| ${res} | Does Page Contain Link | id:submit |",
                "shortdoc": "Does page contain expected link",
                "tags": [],
                "matched": true
            },
            {
                "name": "Does Page Contain List",
                "args": [
                    "locator: str"
                ],
                "doc": "Does page contain expected list\n\n``locator`` element locator\n\nExample:\n\n| ${res} | Does Page Contain List | class:selections |",
                "shortdoc": "Does page contain expected list",
                "tags": [],
                "matched": true
            },
            {
                "name": "Does Page Contain Radio Button",
                "args": [
                    "locator: str"
                ],
                "doc": "Does page contain expected radio button\n\n``locator`` element locator\n\nExample:\n\n| ${res} | Does Page Contain Radio Button | male |",
                "shortdoc": "Does page contain expected radio button",
                "tags": [],
                "matched": true
            },
            {
                "name": "Does Page Contain Textfield",
                "args": [
                    "locator: str"
                ],
                "doc": "Does page contain expected textfield\n\n``locator`` element locator\n\nExample:\n\n| ${res} | Does Page Contain Textfield | id:address |",
                "shortdoc": "Does page contain expected textfield",
                "tags": [],
                "matched": true
            },
            {
                "name": "Does Table Cell Contain",
                "args": [
                    "locator: str",
                    "row: int",
                    "column: int",
                    "expected: str"
                ],
                "doc": "Does table cell contain expected text\n\n``locator`` element locator for the table\n\n``row`` row index starting from 1 (beginning) or -1 (from the end)\n\n``column`` column index starting from 1 (beginning) or -1 (from the end)\n\n``expected`` expected text in table row\n\nExample:\n\n| ${res} | Does Table Cell Contain | //table | 1 | 1 | Company |",
                "shortdoc": "Does table cell contain expected text",
                "tags": [],
                "matched": true
            },
            {
                "name": "Does Table Column Contain",
                "args": [
                    "locator: str",
                    "column: int",
                    "expected: str"
                ],
                "doc": "Does table column contain expected text\n\n``locator`` element locator for the table\n\n``column`` column index starting from 1 (beginning) or -1 (from the end)\n\n``expected`` expected text in table column\n\nExample:\n\n| ${res} | Does Table Column Contain | //table | 1 | Nokia |",
                "shortdoc": "Does table column contain expected text",
                "tags": [],
                "matched": true
            },
            {
                "name": "Does Table Contain",
                "args": [
                    "locator: str",
                    "expected: str"
                ],
                "doc": "Does table contain expected text\n\n``locator`` element locator\n\n``expected`` expected text in table\n\nExample:\n\n| ${res} | Does Table Contain | //table | February |",
                "shortdoc": "Does table contain expected text",
                "tags": [],
                "matched": true
            },
            {
                "name": "Does Table Footer Contain",
                "args": [
                    "locator: str",
                    "expected: str"
                ],
                "doc": "Does table footer contain expected text\n\n``locator`` element locator for the table\n\n``expected`` expected text in table footer\n\nExample:\n\n| ${res} | Does Table Footer Contain | //table | Sum |",
                "shortdoc": "Does table footer contain expected text",
                "tags": [],
                "matched": true
            },
            {
                "name": "Does Table Header Contain",
                "args": [
                    "locator: str",
                    "expected: str"
                ],
                "doc": "Does table header contain expected text\n\n``locator`` element locator for the table\n\n``expected`` expected text in table header\n\nExample:\n\n| ${res} | Does Table Header Contain | //table | Month |",
                "shortdoc": "Does table header contain expected text",
                "tags": [],
                "matched": true
            },
            {
                "name": "Does Table Row Contain",
                "args": [
                    "locator: str",
                    "row: int",
                    "expected: str"
                ],
                "doc": "Does table row contain expected text\n\n``locator`` element locator for the table\n\n``row`` row index starting from 1 (beginning) or -1 (from the end)\n\n``expected`` expected text in table row\n\nExample:\n\n| ${res} | Does Table Row Contain | //table | 1 | Company |",
                "shortdoc": "Does table row contain expected text",
                "tags": [],
                "matched": true
            },
            {
                "name": "Does Textarea Contain",
                "args": [
                    "locator: str",
                    "expected: str"
                ],
                "doc": "Does textarea contain expected text\n\n``locator`` element locator\n\n``expected`` expected text in textarea\n\nExample:\n\n| ${res} | Does Textarea Contain | //textarea | sincerely |",
                "shortdoc": "Does textarea contain expected text",
                "tags": [],
                "matched": true
            },
            {
                "name": "Does Textfield Contain",
                "args": [
                    "locator: str",
                    "expected: str"
                ],
                "doc": "Does textfield contain expected text\n\n``locator`` element locator\n\n``expected`` expected text in textfield\n\nExample:\n\n| ${res} | Does Textfield Contain | id:lname | Last |",
                "shortdoc": "Does textfield contain expected text",
                "tags": [],
                "matched": true
            },
            {
                "name": "Double Click Element",
                "args": [
                    "locator"
                ],
                "doc": "Double clicks the element identified by ``locator``.\n\nSee the `Locating elements` section for details about the locator\nsyntax.",
                "shortdoc": "Double clicks the element identified by ``locator``.",
                "tags": [],
                "matched": true
            },
            {
                "name": "Drag And Drop",
                "args": [
                    "locator",
                    "target"
                ],
                "doc": "Drags the element identified by ``locator`` into the ``target`` element.\n\nThe ``locator`` argument is the locator of the dragged element\nand the ``target`` is the locator of the target. See the\n`Locating elements` section for details about the locator syntax.\n\nExample:\n| `Drag And Drop` | css:div#element | css:div.target |",
                "shortdoc": "Drags the element identified by ``locator`` into the ``target`` element.",
                "tags": [],
                "matched": true
            },
            {
                "name": "Drag And Drop By Offset",
                "args": [
                    "locator",
                    "xoffset",
                    "yoffset"
                ],
                "doc": "Drags the element identified with ``locator`` by ``xoffset/yoffset``.\n\nSee the `Locating elements` section for details about the locator\nsyntax.\n\nThe element will be moved by ``xoffset`` and ``yoffset``, each of which\nis a negative or positive number specifying the offset.\n\nExample:\n| `Drag And Drop By Offset` | myElem | 50 | -35 | # Move myElem 50px right and 35px down |",
                "shortdoc": "Drags the element identified with ``locator`` by ``xoffset/yoffset``.",
                "tags": [],
                "matched": true
            },
            {
                "name": "Element Attribute Value Should Be",
                "args": [
                    "locator",
                    "attribute",
                    "expected",
                    "message=None"
                ],
                "doc": "Verifies element identified by ``locator`` contains expected attribute value.\n\nSee the `Locating elements` section for details about the locator\nsyntax.\n\nExample:\n`Element Attribute Value Should Be` | css:img | href | value\n\nNew in SeleniumLibrary 3.2.",
                "shortdoc": "Verifies element identified by ``locator`` contains expected attribute value.",
                "tags": [],
                "matched": true
            },
            {
                "name": "Element Should Be Disabled",
                "args": [
                    "locator"
                ],
                "doc": "Verifies that element identified by ``locator`` is disabled.\n\nThis keyword considers also elements that are read-only to be\ndisabled.\n\nSee the `Locating elements` section for details about the locator\nsyntax.",
                "shortdoc": "Verifies that element identified by ``locator`` is disabled.",
                "tags": [],
                "matched": true
            },
            {
                "name": "Element Should Be Enabled",
                "args": [
                    "locator"
                ],
                "doc": "Verifies that element identified by ``locator`` is enabled.\n\nThis keyword considers also elements that are read-only to be\ndisabled.\n\nSee the `Locating elements` section for details about the locator\nsyntax.",
                "shortdoc": "Verifies that element identified by ``locator`` is enabled.",
                "tags": [],
                "matched": true
            },
            {
                "name": "Element Should Be Focused",
                "args": [
                    "locator"
                ],
                "doc": "Verifies that element identified by ``locator`` is focused.\n\nSee the `Locating elements` section for details about the locator\nsyntax.\n\nNew in SeleniumLibrary 3.0.",
                "shortdoc": "Verifies that element identified by ``locator`` is focused.",
                "tags": [],
                "matched": true
            },
            {
                "name": "Element Should Be Visible",
                "args": [
                    "locator",
                    "message=None"
                ],
                "doc": "Verifies that the element identified by ``locator`` is visible.\n\nHerein, visible means that the element is logically visible, not\noptically visible in the current browser viewport. For example,\nan element that carries ``display:none`` is not logically visible,\nso using this keyword on that element would fail.\n\nSee the `Locating elements` section for details about the locator\nsyntax.\n\nThe ``message`` argument can be used to override the default error\nmessage.",
                "shortdoc": "Verifies that the element identified by ``locator`` is visible.",
                "tags": [],
                "matched": true
            },
            {
                "name": "Element Should Contain",
                "args": [
                    "locator",
                    "expected",
                    "message=None",
                    "ignore_case=False"
                ],
                "doc": "Verifies that element ``locator`` contains text ``expected``.\n\nSee the `Locating elements` section for details about the locator\nsyntax.\n\nThe ``message`` argument can be used to override the default error\nmessage.\n\nThe ``ignore_case`` argument can be set to True to compare case\ninsensitive, default is False. New in SeleniumLibrary 3.1.\n\n``ignore_case`` argument is new in SeleniumLibrary 3.1.\n\nUse `Element Text Should Be` if you want to match the exact text,\nnot a substring.",
                "shortdoc": "Verifies that element ``locator`` contains text ``expected``.",
                "tags": [],
                "matched": true
            },
            {
                "name": "Element Should Not Be Visible",
                "args": [
                    "locator",
                    "message=None"
                ],
                "doc": "Verifies that the element identified by ``locator`` is NOT visible.\n\nPasses if the element does not exists. See `Element Should Be Visible`\nfor more information about visibility and supported arguments.",
                "shortdoc": "Verifies that the element identified by ``locator`` is NOT visible.",
                "tags": [],
                "matched": true
            },
            {
                "name": "Element Should Not Contain",
                "args": [
                    "locator",
                    "expected",
                    "message=None",
                    "ignore_case=False"
                ],
                "doc": "Verifies that element ``locator`` does not contain text ``expected``.\n\nSee the `Locating elements` section for details about the locator\nsyntax.\n\nThe ``message`` argument can be used to override the default error\nmessage.\n\nThe ``ignore_case`` argument can be set to True to compare case\ninsensitive, default is False.\n\n``ignore_case`` argument new in SeleniumLibrary 3.1.",
                "shortdoc": "Verifies that element ``locator`` does not contain text ``expected``.",
                "tags": [],
                "matched": true
            },
            {
                "name": "Element Text Should Be",
                "args": [
                    "locator",
                    "expected",
                    "message=None",
                    "ignore_case=False"
                ],
                "doc": "Verifies that element ``locator`` contains exact the text ``expected``.\n\nSee the `Locating elements` section for details about the locator\nsyntax.\n\nThe ``message`` argument can be used to override the default error\nmessage.\n\nThe ``ignore_case`` argument can be set to True to compare case\ninsensitive, default is False.\n\n``ignore_case`` argument is new in SeleniumLibrary 3.1.\n\nUse `Element Should Contain` if a substring match is desired.",
                "shortdoc": "Verifies that element ``locator`` contains exact the text ``expected``.",
                "tags": [],
                "matched": true
            },
            {
                "name": "Element Text Should Not Be",
                "args": [
                    "locator",
                    "not_expected",
                    "message=None",
                    "ignore_case=False"
                ],
                "doc": "Verifies that element ``locator`` does not contain exact the text ``not_expected``.\n\nSee the `Locating elements` section for details about the locator\nsyntax.\n\nThe ``message`` argument can be used to override the default error\nmessage.\n\nThe ``ignore_case`` argument can be set to True to compare case\ninsensitive, default is False.\n\nNew in SeleniumLibrary 3.1.1",
                "shortdoc": "Verifies that element ``locator`` does not contain exact the text ``not_expected``.",
                "tags": [],
                "matched": true
            },
            {
                "name": "Execute Async Javascript",
                "args": [
                    "*code"
                ],
                "doc": "Executes asynchronous JavaScript code with possible arguments.\n\nSimilar to `Execute Javascript` except that scripts executed with\nthis keyword must explicitly signal they are finished by invoking the\nprovided callback. This callback is always injected into the executed\nfunction as the last argument.\n\nScripts must complete within the script timeout or this keyword will\nfail. See the `Timeout` section for more information.\n\nStarting from SeleniumLibrary 3.2 it is possible to provide JavaScript\n[https://seleniumhq.github.io/selenium/docs/api/py/webdriver_remote/selenium.webdriver.remote.webdriver.html#selenium.webdriver.remote.webdriver.WebDriver.execute_async_script|\narguments] as part of ``code`` argument. See `Execute Javascript` for\nmore details.\n\nExamples:\n| `Execute Async JavaScript` | var callback = arguments[arguments.length - 1]; window.setTimeout(callback, 2000); |\n| `Execute Async JavaScript` | ${CURDIR}/async_js_to_execute.js |\n| ${result} = | `Execute Async JavaScript`                      |\n| ...         | var callback = arguments[arguments.length - 1]; |\n| ...         | function answer(){callback(\"text\");};           |\n| ...         | window.setTimeout(answer, 2000);                |\n| `Should Be Equal` | ${result} | text |",
                "shortdoc": "Executes asynchronous JavaScript code with possible arguments.",
                "tags": [],
                "matched": true
            },
            {
                "name": "Execute Javascript",
                "args": [
                    "*code"
                ],
                "doc": "Executes the given JavaScript code with possible arguments.\n\n``code`` may be divided into multiple cells in the test data and\n``code`` may contain multiple lines of code and arguments. In that case,\nthe JavaScript code parts are concatenated together without adding\nspaces and optional arguments are separated from ``code``.\n\nIf ``code`` is a path to an existing file, the JavaScript\nto execute will be read from that file. Forward slashes work as\na path separator on all operating systems.\n\nThe JavaScript executes in the context of the currently selected\nframe or window as the body of an anonymous function. Use ``window``\nto refer to the window of your application and ``document`` to refer\nto the document object of the current frame or window, e.g.\n``document.getElementById('example')``.\n\nThis keyword returns whatever the executed JavaScript code returns.\nReturn values are converted to the appropriate Python types.\n\nStarting from SeleniumLibrary 3.2 it is possible to provide JavaScript\n[https://seleniumhq.github.io/selenium/docs/api/py/webdriver_remote/selenium.webdriver.remote.webdriver.html#selenium.webdriver.remote.webdriver.WebDriver.execute_script|\narguments] as part of ``code`` argument. The JavaScript code and\narguments must be separated with `JAVASCRIPT` and `ARGUMENTS` markers\nand must be used exactly with this format. If the Javascript code is\nfirst, then the `JAVASCRIPT` marker is optional. The order of\n`JAVASCRIPT` and `ARGUMENTS` markers can be swapped, but if `ARGUMENTS`\nis the first marker, then `JAVASCRIPT` marker is mandatory. It is only\nallowed to use `JAVASCRIPT` and `ARGUMENTS` markers only one time in the\n``code`` argument.\n\nExamples:\n| `Execute JavaScript` | window.myFunc('arg1', 'arg2') |\n| `Execute JavaScript` | ${CURDIR}/js_to_execute.js    |\n| `Execute JavaScript` | alert(arguments[0]); | ARGUMENTS | 123 |\n| `Execute JavaScript` | ARGUMENTS | 123 | JAVASCRIPT | alert(arguments[0]); |",
                "shortdoc": "Executes the given JavaScript code with possible arguments.",
                "tags": [],
                "matched": true
            },
            {
                "name": "Frame Should Contain",
                "args": [
                    "locator",
                    "text",
                    "loglevel=TRACE"
                ],
                "doc": "Verifies that frame identified by ``locator`` contains ``text``.\n\nSee the `Locating elements` section for details about the locator\nsyntax.\n\nSee `Page Should Contain` for an explanation about the ``loglevel``\nargument.",
                "shortdoc": "Verifies that frame identified by ``locator`` contains ``text``.",
                "tags": [],
                "matched": true
            },
            {
                "name": "Get All Links",
                "args": [],
                "doc": "Returns a list containing ids of all links found in current page.\n\nIf a link has no id, an empty string will be in the list instead.",
                "shortdoc": "Returns a list containing ids of all links found in current page.",
                "tags": [],
                "matched": true
            },
            {
                "name": "Get Browser Aliases",
                "args": [],
                "doc": "Returns aliases of all active browser that has an alias as NormalizedDict.\nThe dictionary contains the aliases as keys and the index as value.\nThis can be accessed as dictionary ``${aliases.key}`` or as list ``@{aliases}[0]``.\n\nExample:\n| `Open Browser` | https://example.com   | alias=BrowserA | |\n| `Open Browser` | https://example.com   | alias=BrowserB | |\n| &{aliases}     | `Get Browser Aliases` |                | # &{aliases} = { BrowserA=1|BrowserB=2 } |\n| `Log`          | ${aliases.BrowserA}   |                | # logs ``1`` |\n| FOR            | ${alias}              | IN             | @{aliases} |\n|                | `Log`                 | ${alias}       | # logs ``BrowserA`` and ``BrowserB`` |\n| END            |                       |                | |\n\nSee `Switch Browser` for more information and examples.\n\nNew in SeleniumLibrary 4.0",
                "shortdoc": "Returns aliases of all active browser that has an alias as NormalizedDict. The dictionary contains the aliases as keys and the index as value. This can be accessed as dictionary ``${aliases.key}`` or as list ``@{aliases}[0]``.",
                "tags": [],
                "matched": true
            },
            {
                "name": "Get Browser Capabilities",
                "args": [],
                "doc": "Get dictionary of browser properties\n\nExample:\n\n| ${caps}= | Get Browser Capabilities |",
                "shortdoc": "Get dictionary of browser properties",
                "tags": [],
                "matched": true
            },
            {
                "name": "Get Browser Ids",
                "args": [],
                "doc": "Returns index of all active browser as list.\n\nExample:\n| @{browser_ids}= | Get Browser Ids   |                   |                |\n| FOR             | ${id}             | IN                | @{browser_ids} |\n|                 | @{window_titles}= | Get Window Titles | browser=${id}  |\n|                 | Log               | Browser ${id} has these windows: ${window_titles} | |\n| END             |                   |                   |                |\n\nSee `Switch Browser` for more information and examples.\n\nNew in SeleniumLibrary 4.0",
                "shortdoc": "Returns index of all active browser as list.",
                "tags": [],
                "matched": true
            },
            {
                "name": "Get Cookie",
                "args": [
                    "name"
                ],
                "doc": "Returns information of cookie with ``name`` as an object.\n\nIf no cookie is found with ``name``, keyword fails. The cookie object\ncontains details about the cookie. Attributes available in the object\nare documented in the table below.\n\n| = Attribute = |             = Explanation =                                |\n| name          | The name of a cookie.                                      |\n| value         | Value of the cookie.                                       |\n| path          | Indicates a URL path, for example ``/``.                   |\n| domain        | The domain, the cookie is visible to.                      |\n| secure        | When true, the cookie is only used with HTTPS connections. |\n| httpOnly      | When true, the cookie is not accessible via JavaScript.    |\n| expiry        | Python datetime object indicating when the cookie expires. |\n| extra         | Possible attributes outside of the WebDriver specification |\n\nSee the\n[https://w3c.github.io/webdriver/#cookies|WebDriver specification]\nfor details about the cookie information.\nNotice that ``expiry`` is specified as a\n[https://docs.python.org/3/library/datetime.html#datetime.datetime|datetime object],\nnot as seconds since Unix Epoch like WebDriver natively does.\n\nIn some cases, example when running a browser in the cloud, it is possible that\nthe cookie contains other attributes than is defined in the\n[https://w3c.github.io/webdriver/#cookies|WebDriver specification].\nThese other attributes are available in an ``extra`` attribute in the cookie\nobject and it contains a dictionary of the other attributes. The ``extra``\nattribute is new in SeleniumLibrary 4.0.\n\nExample:\n| `Add Cookie`      | foo             | bar |\n| ${cookie} =       | `Get Cookie`    | foo |\n| `Should Be Equal` | ${cookie.name}  | foo |\n| `Should Be Equal` | ${cookie.value} | bar |\n| `Should Be True`  | ${cookie.expiry.year} > 2017 |\n\nNew in SeleniumLibrary 3.0.",
                "shortdoc": "Returns information of cookie with ``name`` as an object.",
                "tags": [],
                "matched": true
            },
            {
                "name": "Get Cookies",
                "args": [
                    "as_dict=False"
                ],
                "doc": "Returns all cookies of the current page.\n\nIf ``as_dict`` argument evaluates as false, see `Boolean arguments`\nfor more details, then cookie information is returned as\na single string in format ``name1=value1; name2=value2; name3=value3``.\nWhen ``as_dict`` argument evaluates as true, cookie information\nis returned as Robot Framework dictionary format. The string format\ncan be used, for example, for logging purposes or in headers when\nsending HTTP requests. The dictionary format is helpful when\nthe result can be passed to requests library's Create Session\nkeyword's optional cookies parameter.\n\nThe `` as_dict`` argument is new in SeleniumLibrary 3.3",
                "shortdoc": "Returns all cookies of the current page.",
                "tags": [],
                "matched": true
            },
            {
                "name": "Get Element Attribute",
                "args": [
                    "locator",
                    "attribute"
                ],
                "doc": "Returns the value of ``attribute`` from the element ``locator``.\n\nSee the `Locating elements` section for details about the locator\nsyntax.\n\nExample:\n| ${id}= | `Get Element Attribute` | css:h1 | id |\n\nPassing attribute name as part of the ``locator`` was removed\nin SeleniumLibrary 3.2. The explicit ``attribute`` argument\nshould be used instead.",
                "shortdoc": "Returns the value of ``attribute`` from the element ``locator``.",
                "tags": [],
                "matched": true
            },
            {
                "name": "Get Element Count",
                "args": [
                    "locator"
                ],
                "doc": "Returns the number of elements matching ``locator``.\n\nIf you wish to assert the number of matching elements, use\n`Page Should Contain Element` with ``limit`` argument. Keyword will\nalways return an integer.\n\nExample:\n| ${count} =       | `Get Element Count` | name:div_name  |\n| `Should Be True` | ${count} > 2        |                |\n\nNew in SeleniumLibrary 3.0.",
                "shortdoc": "Returns the number of elements matching ``locator``.",
                "tags": [],
                "matched": true
            },
            {
                "name": "Get Element Size",
                "args": [
                    "locator"
                ],
                "doc": "Returns width and height of the element identified by ``locator``.\n\nSee the `Locating elements` section for details about the locator\nsyntax.\n\nBoth width and height are returned as integers.\n\nExample:\n| ${width} | ${height} = | `Get Element Size` | css:div#container |",
                "shortdoc": "Returns width and height of the element identified by ``locator``.",
                "tags": [],
                "matched": true
            },
            {
                "name": "Get Element Status",
                "args": [
                    "locator: str"
                ],
                "doc": "Return dictionary containing element status of:\n\n    - visible\n    - enabled\n    - disabled\n    - focused\n\n``locator`` element locator\n\nExample:\n\n| &{res}  | Get Element Status | class:special |\n| Log     | ${res.visible} |\n| Log     | ${res.enabled} |\n| Log     | ${res.disabled} |\n| Log     | ${res.focused} |",
                "shortdoc": "Return dictionary containing element status of:",
                "tags": [],
                "matched": true
            },
            {
                "name": "Get Horizontal Position",
                "args": [
                    "locator"
                ],
                "doc": "Returns the horizontal position of the element identified by ``locator``.\n\nSee the `Locating elements` section for details about the locator\nsyntax.\n\nThe position is returned in pixels off the left side of the page,\nas an integer.\n\nSee also `Get Vertical Position`.",
                "shortdoc": "Returns the horizontal position of the element identified by ``locator``.",
                "tags": [],
                "matched": true
            },
            {
                "name": "Get List Items",
                "args": [
                    "locator",
                    "values=False"
                ],
                "doc": "Returns all labels or values of selection list ``locator``.\n\nSee the `Locating elements` section for details about the locator\nsyntax.\n\nReturns visible labels by default, but values can be returned by\nsetting the ``values`` argument to a true value (see `Boolean\narguments`).\n\nExample:\n| ${labels} = | `Get List Items` | mylist              |             |\n| ${values} = | `Get List Items` | css:#example select | values=True |\n\nSupport to return values is new in SeleniumLibrary 3.0.",
                "shortdoc": "Returns all labels or values of selection list ``locator``.",
                "tags": [],
                "matched": true
            },
            {
                "name": "Get Location",
                "args": [],
                "doc": "Returns the current browser window URL.",
                "shortdoc": "Returns the current browser window URL.",
                "tags": [],
                "matched": true
            },
            {
                "name": "Get Locations",
                "args": [
                    "browser=CURRENT"
                ],
                "doc": "Returns and logs URLs of all windows of the selected browser.\n\n*Browser Scope:*\n\nThe ``browser`` argument specifies the browser that shall return\nits windows information.\n\n- ``browser`` can be ``index_or_alias`` like in `Switch Browser`.\n\n- If ``browser`` is ``CURRENT`` (default, case-insensitive)\n  the currently active browser is selected.\n\n- If ``browser`` is ``ALL`` (case-insensitive)\n  the window information of all windows of all opened browsers are returned.",
                "shortdoc": "Returns and logs URLs of all windows of the selected browser.",
                "tags": [],
                "matched": true
            },
            {
                "name": "Get Selected List Label",
                "args": [
                    "locator"
                ],
                "doc": "Returns the label of selected option from selection list ``locator``.\n\nIf there are multiple selected options, the label of the first option\nis returned.\n\nSee the `Locating elements` section for details about the locator\nsyntax.",
                "shortdoc": "Returns the label of selected option from selection list ``locator``.",
                "tags": [],
                "matched": true
            },
            {
                "name": "Get Selected List Labels",
                "args": [
                    "locator"
                ],
                "doc": "Returns labels of selected options from selection list ``locator``.\n\nStarting from SeleniumLibrary 3.0, returns an empty list if there\nare no selections. In earlier versions, this caused an error.\n\nSee the `Locating elements` section for details about the locator\nsyntax.",
                "shortdoc": "Returns labels of selected options from selection list ``locator``.",
                "tags": [],
                "matched": true
            },
            {
                "name": "Get Selected List Value",
                "args": [
                    "locator"
                ],
                "doc": "Returns the value of selected option from selection list ``locator``.\n\nIf there are multiple selected options, the value of the first option\nis returned.\n\nSee the `Locating elements` section for details about the locator\nsyntax.",
                "shortdoc": "Returns the value of selected option from selection list ``locator``.",
                "tags": [],
                "matched": true
            },
            {
                "name": "Get Selected List Values",
                "args": [
                    "locator"
                ],
                "doc": "Returns values of selected options from selection list ``locator``.\n\nStarting from SeleniumLibrary 3.0, returns an empty list if there\nare no selections. In earlier versions, this caused an error.\n\nSee the `Locating elements` section for details about the locator\nsyntax.",
                "shortdoc": "Returns values of selected options from selection list ``locator``.",
                "tags": [],
                "matched": true
            },
            {
                "name": "Get Selenium Implicit Wait",
                "args": [],
                "doc": "Gets the implicit wait value used by Selenium.\n\nThe value is returned as a human-readable string like ``1 second``.\n\nSee the `Implicit wait` section above for more information.",
                "shortdoc": "Gets the implicit wait value used by Selenium.",
                "tags": [],
                "matched": true
            },
            {
                "name": "Get Selenium Speed",
                "args": [],
                "doc": "Gets the delay that is waited after each Selenium command.\n\nThe value is returned as a human-readable string like ``1 second``.\n\nSee the `Selenium Speed` section above for more information.",
                "shortdoc": "Gets the delay that is waited after each Selenium command.",
                "tags": [],
                "matched": true
            },
            {
                "name": "Get Selenium Timeout",
                "args": [],
                "doc": "Gets the timeout that is used by various keywords.\n\nThe value is returned as a human-readable string like ``1 second``.\n\nSee the `Timeout` section above for more information.",
                "shortdoc": "Gets the timeout that is used by various keywords.",
                "tags": [],
                "matched": true
            },
            {
                "name": "Get Session Id",
                "args": [],
                "doc": "Returns the currently active browser session id.\n\nNew in SeleniumLibrary 3.2",
                "shortdoc": "Returns the currently active browser session id.",
                "tags": [],
                "matched": true
            },
            {
                "name": "Get Source",
                "args": [],
                "doc": "Returns the entire HTML source of the current page or frame.",
                "shortdoc": "Returns the entire HTML source of the current page or frame.",
                "tags": [],
                "matched": true
            },
            {
                "name": "Get Table Cell",
                "args": [
                    "locator",
                    "row",
                    "column",
                    "loglevel=TRACE"
                ],
                "doc": "Returns contents of a table cell.\n\nThe table is located using the ``locator`` argument and its cell\nfound using ``row`` and ``column``. See the `Locating elements`\nsection for details about the locator syntax.\n\nBoth row and column indexes start from 1, and header and footer\nrows are included in the count. It is possible to refer to rows\nand columns from the end by using negative indexes so that -1\nis the last row/column, -2 is the second last, and so on.\n\nAll ``<th>`` and ``<td>`` elements anywhere in the table are\nconsidered to be cells.\n\nSee `Page Should Contain` for an explanation about the ``loglevel``\nargument.",
                "shortdoc": "Returns contents of a table cell.",
                "tags": [],
                "matched": true
            },
            {
                "name": "Get Testability Status",
                "args": [],
                "doc": "Get SeleniumTestability plugin status",
                "shortdoc": "Get SeleniumTestability plugin status",
                "tags": [],
                "matched": true
            },
            {
                "name": "Get Text",
                "args": [
                    "locator"
                ],
                "doc": "Returns the text value of the element identified by ``locator``.\n\nSee the `Locating elements` section for details about the locator\nsyntax.",
                "shortdoc": "Returns the text value of the element identified by ``locator``.",
                "tags": [],
                "matched": true
            },
            {
                "name": "Get Title",
                "args": [],
                "doc": "Returns the title of the current page.",
                "shortdoc": "Returns the title of the current page.",
                "tags": [],
                "matched": true
            },
            {
                "name": "Get Value",
                "args": [
                    "locator"
                ],
                "doc": "Returns the value attribute of the element identified by ``locator``.\n\nSee the `Locating elements` section for details about the locator\nsyntax.",
                "shortdoc": "Returns the value attribute of the element identified by ``locator``.",
                "tags": [],
                "matched": true
            },
            {
                "name": "Get Vertical Position",
                "args": [
                    "locator"
                ],
                "doc": "Returns the vertical position of the element identified by ``locator``.\n\nSee the `Locating elements` section for details about the locator\nsyntax.\n\nThe position is returned in pixels off the top of the page,\nas an integer.\n\nSee also `Get Horizontal Position`.",
                "shortdoc": "Returns the vertical position of the element identified by ``locator``.",
                "tags": [],
                "matched": true
            },
            {
                "name": "Get WebElement",
                "args": [
                    "locator"
                ],
                "doc": "Returns the first WebElement matching the given ``locator``.\n\nSee the `Locating elements` section for details about the locator\nsyntax.",
                "shortdoc": "Returns the first WebElement matching the given ``locator``.",
                "tags": [],
                "matched": true
            },
            {
                "name": "Get WebElements",
                "args": [
                    "locator"
                ],
                "doc": "Returns a list of WebElement objects matching the ``locator``.\n\nSee the `Locating elements` section for details about the locator\nsyntax.\n\nStarting from SeleniumLibrary 3.0, the keyword returns an empty\nlist if there are no matching elements. In previous releases, the\nkeyword failed in this case.",
                "shortdoc": "Returns a list of WebElement objects matching the ``locator``.",
                "tags": [],
                "matched": true
            },
            {
                "name": "Get Window Handles",
                "args": [
                    "browser=CURRENT"
                ],
                "doc": "Returns all child window handles of the selected browser as a list.\n\nCan be used as a list of windows to exclude with `Select Window`.\n\nHow to select the ``browser`` scope of this keyword, see `Get Locations`.\n\nPrior to SeleniumLibrary 3.0, this keyword was named `List Windows`.",
                "shortdoc": "Returns all child window handles of the selected browser as a list.",
                "tags": [],
                "matched": true
            },
            {
                "name": "Get Window Identifiers",
                "args": [
                    "browser=CURRENT"
                ],
                "doc": "Returns and logs id attributes of all windows of the selected browser.\n\nHow to select the ``browser`` scope of this keyword, see `Get Locations`.",
                "shortdoc": "Returns and logs id attributes of all windows of the selected browser.",
                "tags": [],
                "matched": true
            },
            {
                "name": "Get Window Names",
                "args": [
                    "browser=CURRENT"
                ],
                "doc": "Returns and logs names of all windows of the selected browser.\n\nHow to select the ``browser`` scope of this keyword, see `Get Locations`.",
                "shortdoc": "Returns and logs names of all windows of the selected browser.",
                "tags": [],
                "matched": true
            },
            {
                "name": "Get Window Position",
                "args": [],
                "doc": "Returns current window position.\n\nThe position is relative to the top left corner of the screen. Returned\nvalues are integers. See also `Set Window Position`.\n\nExample:\n| ${x} | ${y}= | `Get Window Position` |",
                "shortdoc": "Returns current window position.",
                "tags": [],
                "matched": true
            },
            {
                "name": "Get Window Size",
                "args": [
                    "inner=False"
                ],
                "doc": "Returns current window width and height as integers.\n\nSee also `Set Window Size`.\n\nIf ``inner`` parameter is set to True, keyword returns\nHTML DOM window.innerWidth and window.innerHeight properties.\nSee `Boolean arguments` for more details on how to set boolean\narguments. The ``inner`` is new in SeleniumLibrary 4.0.\n\nExample:\n| ${width} | ${height}= | `Get Window Size` |      |\n| ${width} | ${height}= | `Get Window Size` | True |",
                "shortdoc": "Returns current window width and height as integers.",
                "tags": [],
                "matched": true
            },
            {
                "name": "Get Window Titles",
                "args": [
                    "browser=CURRENT"
                ],
                "doc": "Returns and logs titles of all windows of the selected browser.\n\nHow to select the ``browser`` scope of this keyword, see `Get Locations`.",
                "shortdoc": "Returns and logs titles of all windows of the selected browser.",
                "tags": [],
                "matched": true
            },
            {
                "name": "Go Back",
                "args": [],
                "doc": "Simulates the user clicking the back button on their browser.",
                "shortdoc": "Simulates the user clicking the back button on their browser.",
                "tags": [],
                "matched": true
            },
            {
                "name": "Go To",
                "args": [
                    "url"
                ],
                "doc": "Navigates the current browser window to the provided ``url``.",
                "shortdoc": "Navigates the current browser window to the provided ``url``.",
                "tags": [],
                "matched": true
            },
            {
                "name": "Handle Alert",
                "args": [
                    "action=ACCEPT",
                    "timeout=None"
                ],
                "doc": "Handles the current alert and returns its message.\n\nBy default, the alert is accepted, but this can be controlled\nwith the ``action`` argument that supports the following\ncase-insensitive values:\n\n- ``ACCEPT``: Accept the alert i.e. press ``Ok``. Default.\n- ``DISMISS``: Dismiss the alert i.e. press ``Cancel``.\n- ``LEAVE``: Leave the alert open.\n\nThe ``timeout`` argument specifies how long to wait for the alert\nto appear. If it is not given, the global default `timeout` is used\ninstead.\n\nExamples:\n| Handle Alert |                |       | # Accept alert.  |\n| Handle Alert | action=DISMISS |       | # Dismiss alert. |\n| Handle Alert | timeout=10 s   |       | # Use custom timeout and accept alert.  |\n| Handle Alert | DISMISS        | 1 min | # Use custom timeout and dismiss alert. |\n| ${message} = | Handle Alert   |       | # Accept alert and get its message.     |\n| ${message} = | Handle Alert   | LEAVE | # Leave alert open and get its message. |\n\nNew in SeleniumLibrary 3.0.",
                "shortdoc": "Handles the current alert and returns its message.",
                "tags": [],
                "matched": true
            },
            {
                "name": "Highlight Elements",
                "args": [
                    "locator: str",
                    "width: str = 2px",
                    "style: str = dotted",
                    "color: str = blue"
                ],
                "doc": "Highlight all matching elements by locator.\n\nHighlighing is done by adding a colored outline\naround the elements with CSS styling.\n\n``locator``  element locator\n``width``    highlight outline width\n``style``    highlight outline style\n``color``    highlight outline color\n\nExample:\n\n| Highlight Elements | xpath://h2 |",
                "shortdoc": "Highlight all matching elements by locator.",
                "tags": [],
                "matched": true
            },
            {
                "name": "Input Password",
                "args": [
                    "locator",
                    "password",
                    "clear=True"
                ],
                "doc": "Types the given password into the text field identified by ``locator``.\n\nSee the `Locating elements` section for details about the locator\nsyntax. See `Input Text` for ``clear`` argument details.\n\nDifference compared to `Input Text` is that this keyword does not\nlog the given password on the INFO level. Notice that if you use\nthe keyword like\n\n| Input Password | password_field | password |\n\nthe password is shown as a normal keyword argument. A way to avoid\nthat is using variables like\n\n| Input Password | password_field | ${PASSWORD} |\n\nPlease notice that Robot Framework logs all arguments using\nthe TRACE level and tests must not be executed using level below\nDEBUG if the password should not be logged in any format.\n\nThe `clear` argument is new in SeleniumLibrary 4.0. Hiding password\nlogging from Selenium logs is new in SeleniumLibrary 4.2.",
                "shortdoc": "Types the given password into the text field identified by ``locator``.",
                "tags": [],
                "matched": true
            },
            {
                "name": "Input Text",
                "args": [
                    "locator",
                    "text",
                    "clear=True"
                ],
                "doc": "Types the given ``text`` into the text field identified by ``locator``.\n\nWhen ``clear`` is true, the input element is cleared before\nthe text is typed into the element. When false, the previous text\nis not cleared from the element. Use `Input Password` if you\ndo not want the given ``text`` to be logged.\n\nIf [https://github.com/SeleniumHQ/selenium/wiki/Grid2|Selenium Grid]\nis used and the ``text`` argument points to a file in the file system,\nthen this keyword prevents the Selenium to transfer the file to the\nSelenium Grid hub. Instead, this keyword will send the ``text`` string\nas is to the element. If a file should be transferred to the hub and\nupload should be performed, please use `Choose File` keyword.\n\nSee the `Locating elements` section for details about the locator\nsyntax. See the `Boolean arguments` section how Boolean values are\nhandled.\n\nDisabling the file upload the Selenium Grid node and the `clear`\nargument are new in SeleniumLibrary 4.0",
                "shortdoc": "Types the given ``text`` into the text field identified by ``locator``.",
                "tags": [],
                "matched": true
            },
            {
                "name": "Input Text Into Alert",
                "args": [
                    "text",
                    "action=ACCEPT",
                    "timeout=None"
                ],
                "doc": "Types the given ``text`` into an input field in an alert.\n\nThe alert is accepted by default, but that behavior can be controlled\nby using the ``action`` argument same way as with `Handle Alert`.\n\n``timeout`` specifies how long to wait for the alert to appear.\nIf it is not given, the global default `timeout` is used instead.\n\nNew in SeleniumLibrary 3.0.",
                "shortdoc": "Types the given ``text`` into an input field in an alert.",
                "tags": [],
                "matched": true
            },
            {
                "name": "Input Text When Element Is Visible",
                "args": [
                    "locator: str",
                    "text: str"
                ],
                "doc": "Input text into locator after it has become visible.\n\n``locator`` element locator\n\n``text`` insert text to locator\n\nExample:\n\n| Input Text When Element Is Visible | //input[@id=\"freetext\"]  | my feedback |",
                "shortdoc": "Input text into locator after it has become visible.",
                "tags": [],
                "matched": true
            },
            {
                "name": "Is Alert Present",
                "args": [
                    "text: str = None",
                    "action: str = ACCEPT"
                ],
                "doc": "Is alert box present, which can be identified with text\nand action can also be done which by default is ACCEPT.\n\nOther possible actions are DISMISS and LEAVE.\n\n``text`` check if alert text is matching to this, if `None`\nwill check if alert is present at all\n\n``action`` possible action if alert is present, default ACCEPT\n\nExample:\n\n| ${res} | Is Alert Present | alert message |",
                "shortdoc": "Is alert box present, which can be identified with text and action can also be done which by default is ACCEPT.",
                "tags": [],
                "matched": true
            },
            {
                "name": "Is Checkbox Selected",
                "args": [
                    "locator: str"
                ],
                "doc": "Is checkbox selected\n\n``locator`` element locator\n\nExample:\n\n| ${res} |  Is Checkbox Selected  | id:taxes-paid |",
                "shortdoc": "Is checkbox selected",
                "tags": [],
                "matched": true
            },
            {
                "name": "Is Element Attribute Equal To",
                "args": [
                    "locator: str",
                    "attribute: str",
                    "expected: str"
                ],
                "doc": "Is element attribute equal to expected value\n\n``locator`` element locator\n\n``attribute`` element attribute to check for\n\n``expected`` is attribute value equal to this\n\nExample:\n\n| ${res} | Is Element Attribute Equal To | h1 | id | main |",
                "shortdoc": "Is element attribute equal to expected value",
                "tags": [],
                "matched": true
            },
            {
                "name": "Is Element Disabled",
                "args": [
                    "locator: str",
                    "missing_ok: bool = True"
                ],
                "doc": "Is element disabled\n\n``locator`` element locator\n``missing_ok`` default True, set to False if keyword should\nFail if element does not exist\n\nExample:\n\n| ${res} | Is Element Disabled | //input[@type=\"submit\"] |",
                "shortdoc": "Is element disabled",
                "tags": [],
                "matched": true
            },
            {
                "name": "Is Element Enabled",
                "args": [
                    "locator: str",
                    "missing_ok: bool = True"
                ],
                "doc": "Is element enabled\n\n``locator`` element locator\n``missing_ok`` default True, set to False if keyword should\nFail if element does not exist\n\nExample:\n\n| ${res} | Is Element Enabled | input.field1 |",
                "shortdoc": "Is element enabled",
                "tags": [],
                "matched": true
            },
            {
                "name": "Is Element Focused",
                "args": [
                    "locator: str",
                    "missing_ok: bool = True"
                ],
                "doc": "Is element focused\n\n``locator`` element locator\n``missing_ok`` default True, set to False if keyword should\nFail if element does not exist\n\nExample:\n\n| ${res} | Is Element Focused | //input[@id=\"freetext\"] |",
                "shortdoc": "Is element focused",
                "tags": [],
                "matched": true
            },
            {
                "name": "Is Element Text",
                "args": [
                    "locator: str",
                    "expected: str",
                    "ignore_case: bool = False"
                ],
                "doc": "Is element text expected\n\n``locator`` element locator\n\n``expected`` expected element text\n\n``ignore_case`` should check be case insensitive, default `False`\n\nExample:\n\n| ${res} | Is Element Text | id:name | john doe |\n| ${res} | Is Element Text | id:name | john doe | ignore_case=True |",
                "shortdoc": "Is element text expected",
                "tags": [],
                "matched": true
            },
            {
                "name": "Is Element Visible",
                "args": [
                    "locator: str",
                    "missing_ok: bool = True"
                ],
                "doc": "Is element visible\n\n``locator`` element locator\n``missing_ok`` default True, set to False if keyword should\nFail if element does not exist\n\nExample:\n\n| ${res} | Is Element Visible | id:confirmation |",
                "shortdoc": "Is element visible",
                "tags": [],
                "matched": true
            },
            {
                "name": "Is List Selected",
                "args": [
                    "locator: str"
                ],
                "doc": "Is any option selected in the\n\n``locator`` element locator\n\nExample:\n\n| ${res} | Is List Selected | id:cars |",
                "shortdoc": "Is any option selected in the",
                "tags": [],
                "matched": true
            },
            {
                "name": "Is List Selection",
                "args": [
                    "locator: str",
                    "*expected: str"
                ],
                "doc": "Is list selected with expected values\n\n``locator`` element locator\n\n``expected`` expected selected options\n\nExample:\n\n| ${res} | Is List Selection | id:cars | Ford |",
                "shortdoc": "Is list selected with expected values",
                "tags": [],
                "matched": true
            },
            {
                "name": "Is Location",
                "args": [
                    "url: str"
                ],
                "doc": "Is current URL expected url\n\n``url`` expected current URL\n\nExample:\n\n| Open Available Browser | https://www.robocorp.com |\n| ${res} | Is Location | https://www.robocorp.com |",
                "shortdoc": "Is current URL expected url",
                "tags": [],
                "matched": true
            },
            {
                "name": "Is Radio Button Selected",
                "args": [
                    "group_name: str"
                ],
                "doc": "Is any radio button selected in the button group\n\n``group_name`` radio button group name\n\nExample:\n\n| ${res} | Is Radio Button Selected | group_name=gender |",
                "shortdoc": "Is any radio button selected in the button group",
                "tags": [],
                "matched": true
            },
            {
                "name": "Is Radio Button Set To",
                "args": [
                    "group_name: str",
                    "value: str"
                ],
                "doc": "Is radio button group set to expected value\n\n``group_name`` radio button group name\n\n``value`` expected value\n\nExample:\n\n| ${res} | Is Radio Button Set To | group_name=gender | value=female |",
                "shortdoc": "Is radio button group set to expected value",
                "tags": [],
                "matched": true
            },
            {
                "name": "Is Textarea Value",
                "args": [
                    "locator: str",
                    "expected: str"
                ],
                "doc": "Is textarea matching expected value\n\n``locator`` element locator\n\n``expected`` expected textarea value\n\nExample:\n\n| ${res} | Is Textarea Value | //textarea | Yours sincerely |",
                "shortdoc": "Is textarea matching expected value",
                "tags": [],
                "matched": true
            },
            {
                "name": "Is Textfield Value",
                "args": [
                    "locator: str",
                    "expected: str"
                ],
                "doc": "Is textfield value expected\n\n``locator`` element locator\n\n``expected`` expected textfield value\n\nExample:\n\n| ${res} | Is Textfield Value | id:lname | Lastname |",
                "shortdoc": "Is textfield value expected",
                "tags": [],
                "matched": true
            },
            {
                "name": "Is Title",
                "args": [
                    "title: str"
                ],
                "doc": "Is page title expected\n\n``title`` expected title value\n\nExample:\n\n| ${res} | Is Title | Webpage title text |",
                "shortdoc": "Is page title expected",
                "tags": [],
                "matched": true
            },
            {
                "name": "List Selection Should Be",
                "args": [
                    "locator",
                    "*expected"
                ],
                "doc": "Verifies selection list ``locator`` has ``expected`` options selected.\n\nIt is possible to give expected options both as visible labels and\nas values. Starting from SeleniumLibrary 3.0, mixing labels and\nvalues is not possible. Order of the selected options is not\nvalidated.\n\nIf no expected options are given, validates that the list has\nno selections. A more explicit alternative is using `List Should\nHave No Selections`.\n\nSee the `Locating elements` section for details about the locator\nsyntax.\n\nExamples:\n| `List Selection Should Be` | gender    | Female          |        |\n| `List Selection Should Be` | interests | Test Automation | Python |",
                "shortdoc": "Verifies selection list ``locator`` has ``expected`` options selected.",
                "tags": [],
                "matched": true
            },
            {
                "name": "List Should Have No Selections",
                "args": [
                    "locator"
                ],
                "doc": "Verifies selection list ``locator`` has no options selected.\n\nSee the `Locating elements` section for details about the locator\nsyntax.",
                "shortdoc": "Verifies selection list ``locator`` has no options selected.",
                "tags": [],
                "matched": true
            },
            {
                "name": "Location Should Be",
                "args": [
                    "url",
                    "message=None"
                ],
                "doc": "Verifies that the current URL is exactly ``url``.\n\nThe ``url`` argument contains the exact url that should exist in browser.\n\nThe ``message`` argument can be used to override the default error\nmessage.\n\n``message`` argument is new in SeleniumLibrary 3.2.0.",
                "shortdoc": "Verifies that the current URL is exactly ``url``.",
                "tags": [],
                "matched": true
            },
            {
                "name": "Location Should Contain",
                "args": [
                    "expected",
                    "message=None"
                ],
                "doc": "Verifies that the current URL contains ``expected``.\n\nThe ``expected`` argument contains the expected value in url.\n\nThe ``message`` argument can be used to override the default error\nmessage.\n\n``message`` argument is new in SeleniumLibrary 3.2.0.",
                "shortdoc": "Verifies that the current URL contains ``expected``.",
                "tags": [],
                "matched": true
            },
            {
                "name": "Locator Should Match X Times",
                "args": [
                    "locator",
                    "x",
                    "message=None",
                    "loglevel=TRACE"
                ],
                "doc": "*DEPRECATED in SeleniumLibrary 4.0.*, use `Page Should Contain Element` with ``limit`` argument instead.",
                "shortdoc": "*DEPRECATED in SeleniumLibrary 4.0.*, use `Page Should Contain Element` with ``limit`` argument instead.",
                "tags": [],
                "matched": true
            },
            {
                "name": "Log Location",
                "args": [],
                "doc": "Logs and returns the current browser window URL.",
                "shortdoc": "Logs and returns the current browser window URL.",
                "tags": [],
                "matched": true
            },
            {
                "name": "Log Source",
                "args": [
                    "loglevel=INFO"
                ],
                "doc": "Logs and returns the HTML source of the current page or frame.\n\nThe ``loglevel`` argument defines the used log level. Valid log\nlevels are ``WARN``, ``INFO`` (default), ``DEBUG``, ``TRACE``\nand ``NONE`` (no logging).",
                "shortdoc": "Logs and returns the HTML source of the current page or frame.",
                "tags": [],
                "matched": true
            },
            {
                "name": "Log Title",
                "args": [],
                "doc": "Logs and returns the title of the current page.",
                "shortdoc": "Logs and returns the title of the current page.",
                "tags": [],
                "matched": true
            },
            {
                "name": "Maximize Browser Window",
                "args": [],
                "doc": "Maximizes current browser window.",
                "shortdoc": "Maximizes current browser window.",
                "tags": [],
                "matched": true
            },
            {
                "name": "Mouse Down",
                "args": [
                    "locator"
                ],
                "doc": "Simulates pressing the left mouse button on the element ``locator``.\n\nSee the `Locating elements` section for details about the locator\nsyntax.\n\nThe element is pressed without releasing the mouse button.\n\nSee also the more specific keywords `Mouse Down On Image` and\n`Mouse Down On Link`.",
                "shortdoc": "Simulates pressing the left mouse button on the element ``locator``.",
                "tags": [],
                "matched": true
            },
            {
                "name": "Mouse Down On Image",
                "args": [
                    "locator"
                ],
                "doc": "Simulates a mouse down event on an image identified by ``locator``.\n\nSee the `Locating elements` section for details about the locator\nsyntax. When using the default locator strategy, images are searched\nusing ``id``, ``name``, ``src`` and ``alt``.",
                "shortdoc": "Simulates a mouse down event on an image identified by ``locator``.",
                "tags": [],
                "matched": true
            },
            {
                "name": "Mouse Down On Link",
                "args": [
                    "locator"
                ],
                "doc": "Simulates a mouse down event on a link identified by ``locator``.\n\nSee the `Locating elements` section for details about the locator\nsyntax. When using the default locator strategy, links are searched\nusing ``id``, ``name``, ``href`` and the link text.",
                "shortdoc": "Simulates a mouse down event on a link identified by ``locator``.",
                "tags": [],
                "matched": true
            },
            {
                "name": "Mouse Out",
                "args": [
                    "locator"
                ],
                "doc": "Simulates moving the mouse away from the element ``locator``.\n\nSee the `Locating elements` section for details about the locator\nsyntax.",
                "shortdoc": "Simulates moving the mouse away from the element ``locator``.",
                "tags": [],
                "matched": true
            },
            {
                "name": "Mouse Over",
                "args": [
                    "locator"
                ],
                "doc": "Simulates hovering the mouse over the element ``locator``.\n\nSee the `Locating elements` section for details about the locator\nsyntax.",
                "shortdoc": "Simulates hovering the mouse over the element ``locator``.",
                "tags": [],
                "matched": true
            },
            {
                "name": "Mouse Up",
                "args": [
                    "locator"
                ],
                "doc": "Simulates releasing the left mouse button on the element ``locator``.\n\nSee the `Locating elements` section for details about the locator\nsyntax.",
                "shortdoc": "Simulates releasing the left mouse button on the element ``locator``.",
                "tags": [],
                "matched": true
            },
            {
                "name": "Open Available Browser",
                "args": [
                    "url: str",
                    "use_profile: bool = False",
                    "headless: bool = None",
                    "maximized: bool = False",
                    "browser_selection: typing.Any = AUTO",
                    "alias: str = None",
                    "profile_name: str = None",
                    "profile_path: str = None",
                    "preferences: dict = None",
                    "proxy: str = None"
                ],
                "doc": "Opens the first available browser in the system in preferred order, or the\ngiven browser (``browser_selection``).\n\n``url`` URL to open\n\n``use_profile`` Set browser profile, default ``False`` (Chrome/Chromium only)\n\n``headless`` Run in headless mode, default ``False``\n\n``maximized`` Run window maximized, default ``False``\n\n``browser_selection`` browser name, default ``AUTOMATIC_BROWSER_SELECTION``\n\n``alias`` Custom name for browser\n\n``profile_name`` Name of profile (if profile enabled)\n\n``profile_path`` Path to profiles (if profile enabled)\n\n``preferences`` Profile preferences (Chrome/Chromium only)\n\n``proxy`` Proxy server address (Chrome only)\n\nReturns an index of the webdriver session.\n\n=== Process of opening a browser ===\n\n1. Get the order of browsers\n\n2. Loop the list of preferred browsers\n\n    a. Set the webdriver options for the browser\n\n    b. Create the webdriver using existing installation\n\n    c. (If step b. failed) Download and install webdriver, try again\n\n    d. (If step c. failed) Try starting webdriver in headless mode\n\n3. Open the URL\n\nReturns index or custom alias for the browser instance.\n\nRaises ``BrowserNotFoundError`` if unable to open the browser.\n\nFor information about Safari webdriver setup, see\nhttps://developer.apple.com/documentation/webkit/testing_with_webdriver_in_safari\n\nExample:\n\n| ${idx1} | Open Available Browser | https://www.robocorp.com |\n| ${idx2} | Open Available Browser | ${URL} | browser_selection=opera,firefox |\n| Open Available Browser | ${URL} | headless=True | proxy=localhost:8899 |",
                "shortdoc": "Opens the first available browser in the system in preferred order, or the given browser (``browser_selection``).",
                "tags": [],
                "matched": true
            },
            {
                "name": "Open Browser",
                "args": [
                    "url=None",
                    "browser=firefox",
                    "alias=None",
                    "remote_url=False",
                    "desired_capabilities=None",
                    "ff_profile_dir=None",
                    "options=None",
                    "service_log_path=None",
                    "executable_path=None"
                ],
                "doc": "Opens a new browser instance to the optional ``url``.\n\nThe ``browser`` argument specifies which browser to use. The\nsupported browsers are listed in the table below. The browser names\nare case-insensitive and some browsers have multiple supported names.\n\n|    = Browser =    |        = Name(s) =       |\n| Firefox           | firefox, ff              |\n| Google Chrome     | googlechrome, chrome, gc |\n| Headless Firefox  | headlessfirefox          |\n| Headless Chrome   | headlesschrome           |\n| Internet Explorer | internetexplorer, ie     |\n| Edge              | edge                     |\n| Safari            | safari                   |\n| Opera             | opera                    |\n| Android           | android                  |\n| Iphone            | iphone                   |\n| PhantomJS         | phantomjs                |\n| HTMLUnit          | htmlunit                 |\n| HTMLUnit with Javascript | htmlunitwithjs    |\n\nTo be able to actually use one of these browsers, you need to have\na matching Selenium browser driver available. See the\n[https://github.com/robotframework/SeleniumLibrary#browser-drivers|\nproject documentation] for more details. Headless Firefox and\nHeadless Chrome are new additions in SeleniumLibrary 3.1.0\nand require Selenium 3.8.0 or newer.\n\nAfter opening the browser, it is possible to use optional\n``url`` to navigate the browser to the desired address.\n\nOptional ``alias`` is an alias given for this browser instance and\nit can be used for switching between browsers. When same ``alias``\nis given with two `Open Browser` keywords, the first keyword will\nopen a new browser, but the second one will switch to the already\nopened browser and will not open a new browser. The ``alias``\ndefinition overrules ``browser`` definition. When same ``alias``\nis used but a different ``browser`` is defined, then switch to\na browser with same alias is done and new browser is not opened.\nAn alternative approach for switching is using an index returned\nby this keyword. These indices start from 1, are incremented when new\nbrowsers are opened, and reset back to 1 when `Close All Browsers`\nis called. See `Switch Browser` for more information and examples.\n\nOptional ``remote_url`` is the URL for a\n[https://github.com/SeleniumHQ/selenium/wiki/Grid2|Selenium Grid].\n\nOptional ``desired_capabilities`` can be used to configure, for example,\nlogging preferences for a browser or a browser and operating system\nwhen using [http://saucelabs.com|Sauce Labs]. Desired capabilities can\nbe given either as a Python dictionary or as a string in the format\n``key1:value1,key2:value2``.\n[https://github.com/SeleniumHQ/selenium/wiki/DesiredCapabilities|\nSelenium documentation] lists possible capabilities that can be\nenabled.\n\nOptional ``ff_profile_dir`` is the path to the Firefox profile\ndirectory if you wish to overwrite the default profile Selenium\nuses. Notice that prior to SeleniumLibrary 3.0, the library\ncontained its own profile that was used by default. The\n``ff_profile_dir`` can also be an instance of the\n[https://seleniumhq.github.io/selenium/docs/api/py/webdriver_firefox/selenium.webdriver.firefox.firefox_profile.html|selenium.webdriver.FirefoxProfile]\n. As a third option, it is possible to use `FirefoxProfile` methods\nand attributes to define the profile using methods and attributes\nin the same way as with ``options`` argument. Example: It is possible\nto use FirefoxProfile `set_preference` to define different\nprofile settings. See ``options`` argument documentation in below\nhow to handle backslash escaping.\n\nOptional ``options`` argument allows defining browser specific\nSelenium options. Example for Chrome, the ``options`` argument\nallows defining the following\n[https://seleniumhq.github.io/selenium/docs/api/py/webdriver_chrome/selenium.webdriver.chrome.options.html#selenium.webdriver.chrome.options.Options|methods and attributes]\nand for Firefox these\n[https://seleniumhq.github.io/selenium/docs/api/py/webdriver_firefox/selenium.webdriver.firefox.options.html?highlight=firefox#selenium.webdriver.firefox.options.Options|methods and attributes]\nare available. Please note that not all browsers, supported by the\nSeleniumLibrary, have Selenium options available. Therefore please\nconsult the Selenium documentation which browsers do support\nthe Selenium options. If ``browser`` argument is `android` then\n[https://seleniumhq.github.io/selenium/docs/api/py/webdriver_chrome/selenium.webdriver.chrome.options.html#selenium.webdriver.chrome.options.Options|Chrome options]\nis used. Selenium options are also supported, when ``remote_url``\nargument is used.\n\nThe SeleniumLibrary ``options`` argument accepts Selenium\noptions in two different formats: as a string and as Python object\nwhich is an instance of the Selenium options class.\n\nThe string format allows defining Selenium options methods\nor attributes and their arguments in Robot Framework test data.\nThe method and attributes names are case and space sensitive and\nmust match to the Selenium options methods and attributes names.\nWhen defining a method, it must be defined in a similar way as in\npython: method name, opening parenthesis, zero to many arguments\nand closing parenthesis. If there is a need to define multiple\narguments for a single method, arguments must be separated with\ncomma, just like in Python. Example: `add_argument(\"--headless\")`\nor `add_experimental_option(\"key\", \"value\")`. Attributes are\ndefined in a similar way as in Python: attribute name, equal sign,\nand attribute value. Example, `headless=True`. Multiple methods\nand attributes must be separated by a semicolon. Example:\n`add_argument(\"--headless\");add_argument(\"--start-maximized\")`.\n\nArguments allow defining Python data types and arguments are\nevaluated by using Python\n[https://docs.python.org/3/library/ast.html#ast.literal_eval|ast.literal_eval].\nStrings must be quoted with single or double quotes, example \"value\"\nor 'value'. It is also possible to define other Python builtin\ndata types, example `True` or `None`, by not using quotes\naround the arguments.\n\nThe string format is space friendly. Usually, spaces do not alter\nthe defining methods or attributes. There are two exceptions.\nIn some Robot Framework test data formats, two or more spaces are\nconsidered as cell separator and instead of defining a single\nargument, two or more arguments may be defined. Spaces in string\narguments are not removed and are left as is. Example\n`add_argument ( \"--headless\" )` is same as\n`add_argument(\"--headless\")`. But `add_argument(\" --headless \")` is\nnot same same as `add_argument ( \"--headless\" )`, because\nspaces inside of quotes are not removed. Please note that if\noptions string contains backslash, example a Windows OS path,\nthe backslash needs escaping both in Robot Framework data and\nin Python side. This means single backslash must be writen using\nfour backslash characters. Example, Windows path:\n\"C:\\path\\to\\profile\" must be written as\n\"C:\\\\\\\\path\\\\\\to\\\\\\\\profile\". Another way to write\nbackslash is use Python\n[https://docs.python.org/3/reference/lexical_analysis.html#string-and-bytes-literals|raw strings]\nand example write: r\"C:\\\\path\\\\to\\\\profile\".\n\nAs last format, ``options`` argument also supports receiving\nthe Selenium options as Python class instance. In this case, the\ninstance is used as-is and the SeleniumLibrary will not convert\nthe instance to other formats.\nFor example, if the following code return value is saved to\n`${options}` variable in the Robot Framework data:\n| options = webdriver.ChromeOptions()\n| options.add_argument('--disable-dev-shm-usage')\n| return options\n\nThen the `${options}` variable can be used as an argument to\n``options``.\n\nExample the ``options`` argument can be used to launch Chomium-based\napplications which utilize the\n[https://bitbucket.org/chromiumembedded/cef/wiki/UsingChromeDriver|Chromium Embedded Framework]\n. To lauch Chomium-based application, use ``options`` to define\n`binary_location` attribute and use `add_argument` method to define\n`remote-debugging-port` port for the application. Once the browser\nis opened, the test can interact with the embedded web-content of\nthe system under test.\n\nOptional ``service_log_path`` argument defines the name of the\nfile where to write the browser driver logs. If the\n``service_log_path``  argument contain a  marker ``{index}``, it\nwill be automatically replaced with unique running\nindex preventing files to be overwritten. Indices start's from 1,\nand how they are represented can be customized using Python's\n[https://docs.python.org/3/library/string.html#format-string-syntax|\nformat string syntax].\n\nOptional ``executable_path`` argument defines the path to the driver\nexecutable, example to a chromedriver or a geckodriver. If not defined\nit is assumed the executable is in the\n[https://en.wikipedia.org/wiki/PATH_(variable)|$PATH].\n\nExamples:\n| `Open Browser` | http://example.com | Chrome  |                                         |\n| `Open Browser` | http://example.com | Firefox | alias=Firefox                           |\n| `Open Browser` | http://example.com | Edge    | remote_url=http://127.0.0.1:4444/wd/hub |\n| `Open Browser` | about:blank        |         |                                         |\n| `Open Browser` | browser=Chrome     |         |                                         |\n\nAlias examples:\n| ${1_index} =    | `Open Browser` | http://example.com | Chrome  | alias=Chrome     | # Opens new browser because alias is new.         |\n| ${2_index} =    | `Open Browser` | http://example.com | Firefox |                  | # Opens new browser because alias is not defined. |\n| ${3_index} =    | `Open Browser` | http://example.com | Chrome  | alias=Chrome     | # Switches to the browser with Chrome alias.      |\n| ${4_index} =    | `Open Browser` | http://example.com | Chrome  | alias=${1_index} | # Switches to the browser with Chrome alias.      |\n| Should Be Equal | ${1_index}     | ${3_index}         |         |                  |                                                   |\n| Should Be Equal | ${1_index}     | ${4_index}         |         |                  |                                                   |\n| Should Be Equal | ${2_index}     | ${2}               |         |                  |                                                   |\n\nExample when using\n[https://seleniumhq.github.io/selenium/docs/api/py/webdriver_chrome/selenium.webdriver.chrome.options.html#selenium.webdriver.chrome.options.Options|Chrome options]\nmethod:\n| `Open Browser` | http://example.com | Chrome | options=add_argument(\"--disable-popup-blocking\"); add_argument(\"--ignore-certificate-errors\") | # Sting format.                    |\n|  ${options} =  |     Get Options    |        |                                                                                               | # Selenium options instance.       |\n| `Open Browser` | http://example.com | Chrome | options=${options}                                                                            |                                    |\n| `Open Browser` | None               | Chrome | options=binary_location=\"/path/to/binary\";add_argument(\"remote-debugging-port=port\")          | # Start Chomium-based application. |\n| `Open Browser` | None               | Chrome | options=binary_location=r\"C:\\\\path\\\\to\\\\binary\"                                         | # Windows OS path escaping.        |\n\nExample for FirefoxProfile\n| `Open Browser` | http://example.com | Firefox | ff_profile_dir=/path/to/profile                                                  | # Using profile from disk.                       |\n| `Open Browser` | http://example.com | Firefox | ff_profile_dir=${FirefoxProfile_instance}                                        | # Using instance of FirefoxProfile.              |\n| `Open Browser` | http://example.com | Firefox | ff_profile_dir=set_preference(\"key\", \"value\");set_preference(\"other\", \"setting\") | # Defining profile using FirefoxProfile mehtods. |\n\nIf the provided configuration options are not enough, it is possible\nto use `Create Webdriver` to customize browser initialization even\nmore.\n\nApplying ``desired_capabilities`` argument also for local browser is\nnew in SeleniumLibrary 3.1.\n\nUsing ``alias`` to decide, is the new browser opened is new\nin SeleniumLibrary 4.0. The ``options`` and ``service_log_path``\nare new in SeleniumLibrary 4.0. Support for ``ff_profile_dir``\naccepting an instance of the `selenium.webdriver.FirefoxProfile`\nand support defining FirefoxProfile with methods and\nattributes are new in SeleniumLibrary 4.0.\n\nMaking ``url`` optional is new in SeleniumLibrary 4.1.\n\nThe ``executable_path`` argument is new in SeleniumLibrary 4.2.",
                "shortdoc": "Opens a new browser instance to the optional ``url``.",
                "tags": [],
                "matched": true
            },
            {
                "name": "Open Chrome Browser",
                "args": [
                    "url: str",
                    "use_profile: bool = False",
                    "headless: bool = False",
                    "maximized: bool = False",
                    "alias: str = None",
                    "profile_name: str = None",
                    "profile_path: str = None",
                    "preferences: dict = None",
                    "proxy: str = None"
                ],
                "doc": "Open Chrome browser. See ``Open Available Browser`` for\ndescriptions of arguments.",
                "shortdoc": "Open Chrome browser. See ``Open Available Browser`` for descriptions of arguments.",
                "tags": [],
                "matched": true
            },
            {
                "name": "Open Context Menu",
                "args": [
                    "locator"
                ],
                "doc": "Opens the context menu on the element identified by ``locator``.",
                "shortdoc": "Opens the context menu on the element identified by ``locator``.",
                "tags": [],
                "matched": true
            },
            {
                "name": "Open Headless Chrome Browser",
                "args": [
                    "url: str"
                ],
                "doc": "Open Chrome browser in headless mode.\n\n``url`` URL to open\n\nExample:\n\n| ${idx} | Open Headless Chrome Browser | https://www.google.com |",
                "shortdoc": "Open Chrome browser in headless mode.",
                "tags": [],
                "matched": true
            },
            {
                "name": "Open User Browser",
                "args": [
                    "url: str",
                    "tab=True"
                ],
                "doc": "Open URL with user's default browser\n\n``url`` URL to open\n``tab`` defines is url is opened in a tab (default `True`) or\n        in new window (`False`)\n\nExample:\n\n| Open User Browser  | https://www.google.com?q=rpa |\n| Open User Browser  | https://www.google.com?q=rpa | tab=False |",
                "shortdoc": "Open URL with user's default browser",
                "tags": [],
                "matched": true
            },
            {
                "name": "Page Should Contain",
                "args": [
                    "text",
                    "loglevel=TRACE"
                ],
                "doc": "Verifies that current page contains ``text``.\n\nIf this keyword fails, it automatically logs the page source\nusing the log level specified with the optional ``loglevel``\nargument. Valid log levels are ``DEBUG``, ``INFO`` (default),\n``WARN``, and ``NONE``. If the log level is ``NONE`` or below\nthe current active log level the source will not be logged.",
                "shortdoc": "Verifies that current page contains ``text``.",
                "tags": [],
                "matched": true
            },
            {
                "name": "Page Should Contain Button",
                "args": [
                    "locator",
                    "message=None",
                    "loglevel=TRACE"
                ],
                "doc": "Verifies button ``locator`` is found from current page.\n\nSee `Page Should Contain Element` for an explanation about ``message``\nand ``loglevel`` arguments.\n\nSee the `Locating elements` section for details about the locator\nsyntax. When using the default locator strategy, buttons are\nsearched using ``id``, ``name``, and ``value``.",
                "shortdoc": "Verifies button ``locator`` is found from current page.",
                "tags": [],
                "matched": true
            },
            {
                "name": "Page Should Contain Checkbox",
                "args": [
                    "locator",
                    "message=None",
                    "loglevel=TRACE"
                ],
                "doc": "Verifies checkbox ``locator`` is found from the current page.\n\nSee `Page Should Contain Element` for an explanation about ``message``\nand ``loglevel`` arguments.\n\nSee the `Locating elements` section for details about the locator\nsyntax.",
                "shortdoc": "Verifies checkbox ``locator`` is found from the current page.",
                "tags": [],
                "matched": true
            },
            {
                "name": "Page Should Contain Element",
                "args": [
                    "locator",
                    "message=None",
                    "loglevel=TRACE",
                    "limit=None"
                ],
                "doc": "Verifies that element ``locator`` is found on the current page.\n\nSee the `Locating elements` section for details about the locator\nsyntax.\n\nThe ``message`` argument can be used to override the default error\nmessage.\n\nThe ``limit`` argument can used to define how many elements the\npage should contain. When ``limit`` is ``None`` (default) page can\ncontain one or more elements. When limit is a number, page must\ncontain same number of elements.\n\nSee `Page Should Contain` for an explanation about the ``loglevel``\nargument.\n\nExamples assumes that locator matches to two elements.\n| `Page Should Contain Element` | div_name | limit=1    | # Keyword fails.                  |\n| `Page Should Contain Element` | div_name | limit=2    | # Keyword passes.                 |\n| `Page Should Contain Element` | div_name | limit=none | # None is considered one or more. |\n| `Page Should Contain Element` | div_name |            | # Same as above.                  |\n\nThe ``limit`` argument is new in SeleniumLibrary 3.0.",
                "shortdoc": "Verifies that element ``locator`` is found on the current page.",
                "tags": [],
                "matched": true
            },
            {
                "name": "Page Should Contain Image",
                "args": [
                    "locator",
                    "message=None",
                    "loglevel=TRACE"
                ],
                "doc": "Verifies image identified by ``locator`` is found from current page.\n\nSee the `Locating elements` section for details about the locator\nsyntax. When using the default locator strategy, images are searched\nusing ``id``, ``name``, ``src`` and ``alt``.\n\nSee `Page Should Contain Element` for an explanation about ``message``\nand ``loglevel`` arguments.",
                "shortdoc": "Verifies image identified by ``locator`` is found from current page.",
                "tags": [],
                "matched": true
            },
            {
                "name": "Page Should Contain Link",
                "args": [
                    "locator",
                    "message=None",
                    "loglevel=TRACE"
                ],
                "doc": "Verifies link identified by ``locator`` is found from current page.\n\nSee the `Locating elements` section for details about the locator\nsyntax. When using the default locator strategy, links are searched\nusing ``id``, ``name``, ``href`` and the link text.\n\nSee `Page Should Contain Element` for an explanation about ``message``\nand ``loglevel`` arguments.",
                "shortdoc": "Verifies link identified by ``locator`` is found from current page.",
                "tags": [],
                "matched": true
            },
            {
                "name": "Page Should Contain List",
                "args": [
                    "locator",
                    "message=None",
                    "loglevel=TRACE"
                ],
                "doc": "Verifies selection list ``locator`` is found from current page.\n\nSee `Page Should Contain Element` for an explanation about ``message``\nand ``loglevel`` arguments.\n\nSee the `Locating elements` section for details about the locator\nsyntax.",
                "shortdoc": "Verifies selection list ``locator`` is found from current page.",
                "tags": [],
                "matched": true
            },
            {
                "name": "Page Should Contain Radio Button",
                "args": [
                    "locator",
                    "message=None",
                    "loglevel=TRACE"
                ],
                "doc": "Verifies radio button ``locator`` is found from current page.\n\nSee `Page Should Contain Element` for an explanation about ``message``\nand ``loglevel`` arguments.\n\nSee the `Locating elements` section for details about the locator\nsyntax. When using the default locator strategy, radio buttons are\nsearched using ``id``, ``name`` and ``value``.",
                "shortdoc": "Verifies radio button ``locator`` is found from current page.",
                "tags": [],
                "matched": true
            },
            {
                "name": "Page Should Contain Textfield",
                "args": [
                    "locator",
                    "message=None",
                    "loglevel=TRACE"
                ],
                "doc": "Verifies text field ``locator`` is found from current page.\n\nSee `Page Should Contain Element` for an explanation about ``message``\nand ``loglevel`` arguments.\n\nSee the `Locating elements` section for details about the locator\nsyntax.",
                "shortdoc": "Verifies text field ``locator`` is found from current page.",
                "tags": [],
                "matched": true
            },
            {
                "name": "Page Should Not Contain",
                "args": [
                    "text",
                    "loglevel=TRACE"
                ],
                "doc": "Verifies the current page does not contain ``text``.\n\nSee `Page Should Contain` for an explanation about the ``loglevel``\nargument.",
                "shortdoc": "Verifies the current page does not contain ``text``.",
                "tags": [],
                "matched": true
            },
            {
                "name": "Page Should Not Contain Button",
                "args": [
                    "locator",
                    "message=None",
                    "loglevel=TRACE"
                ],
                "doc": "Verifies button ``locator`` is not found from current page.\n\nSee `Page Should Contain Element` for an explanation about ``message``\nand ``loglevel`` arguments.\n\nSee the `Locating elements` section for details about the locator\nsyntax. When using the default locator strategy, buttons are\nsearched using ``id``, ``name``, and ``value``.",
                "shortdoc": "Verifies button ``locator`` is not found from current page.",
                "tags": [],
                "matched": true
            },
            {
                "name": "Page Should Not Contain Checkbox",
                "args": [
                    "locator",
                    "message=None",
                    "loglevel=TRACE"
                ],
                "doc": "Verifies checkbox ``locator`` is not found from the current page.\n\nSee `Page Should Contain Element` for an explanation about ``message``\nand ``loglevel`` arguments.\n\nSee the `Locating elements` section for details about the locator\nsyntax.",
                "shortdoc": "Verifies checkbox ``locator`` is not found from the current page.",
                "tags": [],
                "matched": true
            },
            {
                "name": "Page Should Not Contain Element",
                "args": [
                    "locator",
                    "message=None",
                    "loglevel=TRACE"
                ],
                "doc": "Verifies that element ``locator`` is not found on the current page.\n\nSee the `Locating elements` section for details about the locator\nsyntax.\n\nSee `Page Should Contain` for an explanation about ``message`` and\n``loglevel`` arguments.",
                "shortdoc": "Verifies that element ``locator`` is not found on the current page.",
                "tags": [],
                "matched": true
            },
            {
                "name": "Page Should Not Contain Image",
                "args": [
                    "locator",
                    "message=None",
                    "loglevel=TRACE"
                ],
                "doc": "Verifies image identified by ``locator`` is not found from current page.\n\nSee the `Locating elements` section for details about the locator\nsyntax. When using the default locator strategy, images are searched\nusing ``id``, ``name``, ``src`` and ``alt``.\n\nSee `Page Should Contain Element` for an explanation about ``message``\nand ``loglevel`` arguments.",
                "shortdoc": "Verifies image identified by ``locator`` is not found from current page.",
                "tags": [],
                "matched": true
            },
            {
                "name": "Page Should Not Contain Link",
                "args": [
                    "locator",
                    "message=None",
                    "loglevel=TRACE"
                ],
                "doc": "Verifies link identified by ``locator`` is not found from current page.\n\nSee the `Locating elements` section for details about the locator\nsyntax. When using the default locator strategy, links are searched\nusing ``id``, ``name``, ``href`` and the link text.\n\nSee `Page Should Contain Element` for an explanation about ``message``\nand ``loglevel`` arguments.",
                "shortdoc": "Verifies link identified by ``locator`` is not found from current page.",
                "tags": [],
                "matched": true
            },
            {
                "name": "Page Should Not Contain List",
                "args": [
                    "locator",
                    "message=None",
                    "loglevel=TRACE"
                ],
                "doc": "Verifies selection list ``locator`` is not found from current page.\n\nSee `Page Should Contain Element` for an explanation about ``message``\nand ``loglevel`` arguments.\n\nSee the `Locating elements` section for details about the locator\nsyntax.",
                "shortdoc": "Verifies selection list ``locator`` is not found from current page.",
                "tags": [],
                "matched": true
            },
            {
                "name": "Page Should Not Contain Radio Button",
                "args": [
                    "locator",
                    "message=None",
                    "loglevel=TRACE"
                ],
                "doc": "Verifies radio button ``locator`` is not found from current page.\n\nSee `Page Should Contain Element` for an explanation about ``message``\nand ``loglevel`` arguments.\n\nSee the `Locating elements` section for details about the locator\nsyntax. When using the default locator strategy, radio buttons are\nsearched using ``id``, ``name`` and ``value``.",
                "shortdoc": "Verifies radio button ``locator`` is not found from current page.",
                "tags": [],
                "matched": true
            },
            {
                "name": "Page Should Not Contain Textfield",
                "args": [
                    "locator",
                    "message=None",
                    "loglevel=TRACE"
                ],
                "doc": "Verifies text field ``locator`` is not found from current page.\n\nSee `Page Should Contain Element` for an explanation about ``message``\nand ``loglevel`` arguments.\n\nSee the `Locating elements` section for details about the locator\nsyntax.",
                "shortdoc": "Verifies text field ``locator`` is not found from current page.",
                "tags": [],
                "matched": true
            },
            {
                "name": "Press Key",
                "args": [
                    "locator",
                    "key"
                ],
                "doc": "*DEPRECATED in SeleniumLibrary 4.0.* use `Press Keys` instead.",
                "shortdoc": "*DEPRECATED in SeleniumLibrary 4.0.* use `Press Keys` instead.",
                "tags": [],
                "matched": true
            },
            {
                "name": "Press Keys",
                "args": [
                    "locator=None",
                    "*keys"
                ],
                "doc": "Simulates the user pressing key(s) to an element or on the active browser.\n\nIf ``locator`` evaluates as false, see `Boolean arguments` for more\ndetails, then the ``keys`` are sent to the currently active browser.\nOtherwise element is searched and ``keys`` are send to the element\nidentified by the ``locator``. In later case, keyword fails if element\nis not found. See the `Locating elements` section for details about\nthe locator syntax.\n\n``keys`` arguments can contain one or many strings, but it can not\nbe empty. ``keys`` can also be a combination of\n[https://seleniumhq.github.io/selenium/docs/api/py/webdriver/selenium.webdriver.common.keys.html|Selenium Keys]\nand strings or a single Selenium Key. If Selenium Key is combined\nwith strings, Selenium key and strings must be separated by the\n`+` character, like in `CONTROL+c`. Selenium Keys\nare space and case sensitive and Selenium Keys are not parsed\ninside of the string. Example AALTO, would send string `AALTO`\nand `ALT` not parsed inside of the string. But `A+ALT+O` would\nfound Selenium ALT key from the ``keys`` argument. It also possible\nto press many Selenium Keys down at the same time, example\n'ALT+ARROW_DOWN`.\n\nIf Selenium Keys are detected in the ``keys`` argument, keyword\nwill press the Selenium Key down, send the strings and\n then release the Selenium Key. If keyword needs to send a Selenium\nKey as a string, then each character must be separated with\n`+` character, example `E+N+D`.\n\n`CTRL` is alias for\n[https://seleniumhq.github.io/selenium/docs/api/py/webdriver/selenium.webdriver.common.keys.html#selenium.webdriver.common.keys.Keys.CONTROL|Selenium CONTROL]\nand ESC is alias for\n[https://seleniumhq.github.io/selenium/docs/api/py/webdriver/selenium.webdriver.common.keys.html#selenium.webdriver.common.keys.Keys.ESCAPE|Selenium ESCAPE]\n\nNew in SeleniumLibrary 3.3\n\nExamples:\n| `Press Keys` | text_field | AAAAA          |            | # Sends string \"AAAAA\" to element.                                                |\n| `Press Keys` | None       | BBBBB          |            | # Sends string \"BBBBB\" to currently active browser.                               |\n| `Press Keys` | text_field | E+N+D          |            | # Sends string \"END\" to element.                                                  |\n| `Press Keys` | text_field | XXX            | YY         | # Sends strings \"XXX\" and \"YY\" to element.                                        |\n| `Press Keys` | text_field | XXX+YY         |            | # Same as above.                                                                  |\n| `Press Keys` | text_field | ALT+ARROW_DOWN |            | # Pressing \"ALT\" key down, then pressing ARROW_DOWN and then releasing both keys. |\n| `Press Keys` | text_field | ALT            | ARROW_DOWN | # Pressing \"ALT\" key and then pressing ARROW_DOWN.                                |\n| `Press Keys` | text_field | CTRL+c         |            | # Pressing CTRL key down, sends string \"c\" and then releases CTRL key.            |\n| `Press Keys` | button     | RETURN         |            | # Pressing \"ENTER\" key to element.                                                |",
                "shortdoc": "Simulates the user pressing key(s) to an element or on the active browser.",
                "tags": [],
                "matched": true
            },
            {
                "name": "Radio Button Should Be Set To",
                "args": [
                    "group_name",
                    "value"
                ],
                "doc": "Verifies radio button group ``group_name`` is set to ``value``.\n\n``group_name`` is the ``name`` of the radio button group.",
                "shortdoc": "Verifies radio button group ``group_name`` is set to ``value``.",
                "tags": [],
                "matched": true
            },
            {
                "name": "Radio Button Should Not Be Selected",
                "args": [
                    "group_name"
                ],
                "doc": "Verifies radio button group ``group_name`` has no selection.\n\n``group_name`` is the ``name`` of the radio button group.",
                "shortdoc": "Verifies radio button group ``group_name`` has no selection.",
                "tags": [],
                "matched": true
            },
            {
                "name": "Register Keyword To Run On Failure",
                "args": [
                    "keyword"
                ],
                "doc": "Sets the keyword to execute, when a SeleniumLibrary keyword fails.\n\n``keyword`` is the name of a keyword that will be executed if a\nSeleniumLibrary keyword fails. It is possible to use any available\nkeyword, including user keywords or keywords from other libraries,\nbut the keyword must not take any arguments.\n\nThe initial keyword to use is set when `importing` the library, and\nthe keyword that is used by default is `Capture Page Screenshot`.\nTaking a screenshot when something failed is a very useful\nfeature, but notice that it can slow down the execution.\n\nIt is possible to use string ``NOTHING`` or ``NONE``,\ncase-insensitively, as well as Python ``None`` to disable this\nfeature altogether.\n\nThis keyword returns the name of the previously registered\nfailure keyword or Python ``None`` if this functionality was\npreviously disabled. The return value can be always used to\nrestore the original value later.\n\nExample:\n| `Register Keyword To Run On Failure`  | Log Source |\n| ${previous kw}= | `Register Keyword To Run On Failure`  | NONE |\n| `Register Keyword To Run On Failure`  | ${previous kw} |\n\nChanges in SeleniumLibrary 3.0:\n- Possible to use string ``NONE`` or Python ``None`` to disable the\n  functionality.\n- Return Python ``None`` when the functionality was disabled earlier.\n  In previous versions special value ``No Keyword`` was returned and\n  it could not be used to restore the original state.",
                "shortdoc": "Sets the keyword to execute, when a SeleniumLibrary keyword fails.",
                "tags": [],
                "matched": true
            },
            {
                "name": "Reload Page",
                "args": [],
                "doc": "Simulates user reloading page.",
                "shortdoc": "Simulates user reloading page.",
                "tags": [],
                "matched": true
            },
            {
                "name": "Remove Location Strategy",
                "args": [
                    "strategy_name"
                ],
                "doc": "Removes a previously added custom location strategy.\n\nSee `Custom locators` for information on how to create and use\ncustom strategies.",
                "shortdoc": "Removes a previously added custom location strategy.",
                "tags": [],
                "matched": true
            },
            {
                "name": "Screenshot",
                "args": [
                    "locator: str = None",
                    "filename: str = "
                ],
                "doc": "Capture page and/or element screenshot.\n\n``locator`` if defined, take element screenshot, if not takes page screenshot\n\n``filename`` filename for the screenshot, by default creates file `screenshot-timestamp-element/page.png`\nif set to `None` then file is not saved at all\n\nExample:\n\n| Screenshot | locator=//img[@alt=\"Google\"] | filename=locator.png |             # element screenshot, defined filename\n| Screenshot | filename=page.png        |                                    # page screenshot, defined filename\n| Screenshot | filename=${NONE}         |                                    # page screenshot, NO file will be created\n| Screenshot |                          |                                    # page screenshot, default filename\n| Screenshot | locator=//img[@alt=\"Google\"] |                                    # element screenshot, default filename\n| Screenshot | locator=//img[@alt=\"Google\"] | filename=${CURDIR}/subdir/loc.png  # element screenshot, create dirs if not existing",
                "shortdoc": "Capture page and/or element screenshot.",
                "tags": [],
                "matched": true
            },
            {
                "name": "Scroll Element Into View",
                "args": [
                    "locator"
                ],
                "doc": "Scrolls the element identified by ``locator`` into view.\n\nSee the `Locating elements` section for details about the locator\nsyntax.\n\nNew in SeleniumLibrary 3.2.0",
                "shortdoc": "Scrolls the element identified by ``locator`` into view.",
                "tags": [],
                "matched": true
            },
            {
                "name": "Select All From List",
                "args": [
                    "locator"
                ],
                "doc": "Selects all options from multi-selection list ``locator``.\n\nSee the `Locating elements` section for details about the locator\nsyntax.",
                "shortdoc": "Selects all options from multi-selection list ``locator``.",
                "tags": [],
                "matched": true
            },
            {
                "name": "Select Checkbox",
                "args": [
                    "locator"
                ],
                "doc": "Selects the checkbox identified by ``locator``.\n\nDoes nothing if checkbox is already selected.\n\nSee the `Locating elements` section for details about the locator\nsyntax.",
                "shortdoc": "Selects the checkbox identified by ``locator``.",
                "tags": [],
                "matched": true
            },
            {
                "name": "Select Frame",
                "args": [
                    "locator"
                ],
                "doc": "Sets frame identified by ``locator`` as the current frame.\n\nSee the `Locating elements` section for details about the locator\nsyntax.\n\nWorks both with frames and iframes. Use `Unselect Frame` to cancel\nthe frame selection and return to the main frame.\n\nExample:\n| `Select Frame`   | top-frame | # Select frame with id or name 'top-frame'   |\n| `Click Link`     | example   | # Click link 'example' in the selected frame |\n| `Unselect Frame` |           | # Back to main frame.                        |\n| `Select Frame`   | //iframe[@name='xxx'] | # Select frame using xpath       |",
                "shortdoc": "Sets frame identified by ``locator`` as the current frame.",
                "tags": [],
                "matched": true
            },
            {
                "name": "Select From List By Index",
                "args": [
                    "locator",
                    "*indexes"
                ],
                "doc": "Selects options from selection list ``locator`` by ``indexes``.\n\nIndexes of list options start from 0.\n\nIf more than one option is given for a single-selection list,\nthe last value will be selected. With multi-selection lists all\nspecified options are selected, but possible old selections are\nnot cleared.\n\nSee the `Locating elements` section for details about the locator\nsyntax.",
                "shortdoc": "Selects options from selection list ``locator`` by ``indexes``.",
                "tags": [],
                "matched": true
            },
            {
                "name": "Select From List By Label",
                "args": [
                    "locator",
                    "*labels"
                ],
                "doc": "Selects options from selection list ``locator`` by ``labels``.\n\nIf more than one option is given for a single-selection list,\nthe last value will be selected. With multi-selection lists all\nspecified options are selected, but possible old selections are\nnot cleared.\n\nSee the `Locating elements` section for details about the locator\nsyntax.",
                "shortdoc": "Selects options from selection list ``locator`` by ``labels``.",
                "tags": [],
                "matched": true
            },
            {
                "name": "Select From List By Value",
                "args": [
                    "locator",
                    "*values"
                ],
                "doc": "Selects options from selection list ``locator`` by ``values``.\n\nIf more than one option is given for a single-selection list,\nthe last value will be selected. With multi-selection lists all\nspecified options are selected, but possible old selections are\nnot cleared.\n\nSee the `Locating elements` section for details about the locator\nsyntax.",
                "shortdoc": "Selects options from selection list ``locator`` by ``values``.",
                "tags": [],
                "matched": true
            },
            {
                "name": "Select Radio Button",
                "args": [
                    "group_name",
                    "value"
                ],
                "doc": "Sets the radio button group ``group_name`` to ``value``.\n\nThe radio button to be selected is located by two arguments:\n- ``group_name`` is the name of the radio button group.\n- ``value`` is the ``id`` or ``value`` attribute of the actual\n  radio button.\n\nExamples:\n| `Select Radio Button` | size    | XL    |\n| `Select Radio Button` | contact | email |",
                "shortdoc": "Sets the radio button group ``group_name`` to ``value``.",
                "tags": [],
                "matched": true
            },
            {
                "name": "Select Window",
                "args": [
                    "locator=MAIN",
                    "timeout=None"
                ],
                "doc": "DEPRECATED in SeleniumLibrary 4.0. , use `Switch Window` instead.",
                "shortdoc": "DEPRECATED in SeleniumLibrary 4.0. , use `Switch Window` instead.",
                "tags": [],
                "matched": true
            },
            {
                "name": "Set Browser Implicit Wait",
                "args": [
                    "value"
                ],
                "doc": "Sets the implicit wait value used by Selenium.\n\nSame as `Set Selenium Implicit Wait` but only affects the current\nbrowser.",
                "shortdoc": "Sets the implicit wait value used by Selenium.",
                "tags": [],
                "matched": true
            },
            {
                "name": "Set Download Directory",
                "args": [
                    "directory: str = None",
                    "download_pdf: bool = True"
                ],
                "doc": "Set browser download directory\n\n``directory``    target directory for downloads, defaults to None which means\n                 that setting is removed\n``download_pdf`` if `True` then PDF is downloaded instead of shown with\n                 browser's internal viewer",
                "shortdoc": "Set browser download directory",
                "tags": [],
                "matched": true
            },
            {
                "name": "Set Focus To Element",
                "args": [
                    "locator"
                ],
                "doc": "Sets the focus to the element identified by ``locator``.\n\nSee the `Locating elements` section for details about the locator\nsyntax.\n\nPrior to SeleniumLibrary 3.0 this keyword was named `Focus`.",
                "shortdoc": "Sets the focus to the element identified by ``locator``.",
                "tags": [],
                "matched": true
            },
            {
                "name": "Set Screenshot Directory",
                "args": [
                    "path"
                ],
                "doc": "Sets the directory for captured screenshots.\n\n``path`` argument specifies the absolute path to a directory where\nthe screenshots should be written to. If the directory does not\nexist, it will be created. The directory can also be set when\n`importing` the library. If it is not configured anywhere,\nscreenshots are saved to the same directory where Robot Framework's\nlog file is written.\n\nIf ``path`` equals to EMBED (case insensitive) and\n`Capture Page Screenshot` or `capture Element Screenshot` keywords\nfilename argument is not changed from the default value, then\nthe page or element screenshot is embedded as Base64 image to\nthe log.html.\n\nThe previous value is returned and can be used to restore\nthe original value later if needed.\n\nReturning the previous value is new in SeleniumLibrary 3.0.\nThe persist argument was removed in SeleniumLibrary 3.2 and\nEMBED is new in SeleniumLibrary 4.2.",
                "shortdoc": "Sets the directory for captured screenshots.",
                "tags": [],
                "matched": true
            },
            {
                "name": "Set Selenium Implicit Wait",
                "args": [
                    "value"
                ],
                "doc": "Sets the implicit wait value used by Selenium.\n\nThe value can be given as a number that is considered to be\nseconds or as a human-readable string like ``1 second``.\nThe previous value is returned and can be used to restore\nthe original value later if needed.\n\nThis keyword sets the implicit wait for all opened browsers.\nUse `Set Browser Implicit Wait` to set it only to the current\nbrowser.\n\nSee the `Implicit wait` section above for more information.\n\nExample:\n| ${orig wait} = | `Set Selenium Implicit Wait` | 10 seconds |\n| `Perform AJAX call that is slow` |\n| `Set Selenium Implicit Wait` | ${orig wait} |",
                "shortdoc": "Sets the implicit wait value used by Selenium.",
                "tags": [],
                "matched": true
            },
            {
                "name": "Set Selenium Speed",
                "args": [
                    "value"
                ],
                "doc": "Sets the delay that is waited after each Selenium command.\n\nThe value can be given as a number that is considered to be\nseconds or as a human-readable string like ``1 second``.\nThe previous value is returned and can be used to restore\nthe original value later if needed.\n\nSee the `Selenium Speed` section above for more information.\n\nExample:\n| `Set Selenium Speed` | 0.5 seconds |",
                "shortdoc": "Sets the delay that is waited after each Selenium command.",
                "tags": [],
                "matched": true
            },
            {
                "name": "Set Selenium Timeout",
                "args": [
                    "value"
                ],
                "doc": "Sets the timeout that is used by various keywords.\n\nThe value can be given as a number that is considered to be\nseconds or as a human-readable string like ``1 second``.\nThe previous value is returned and can be used to restore\nthe original value later if needed.\n\nSee the `Timeout` section above for more information.\n\nExample:\n| ${orig timeout} = | `Set Selenium Timeout` | 15 seconds |\n| `Open page that loads slowly` |\n| `Set Selenium Timeout` | ${orig timeout} |",
                "shortdoc": "Sets the timeout that is used by various keywords.",
                "tags": [],
                "matched": true
            },
            {
                "name": "Set Window Position",
                "args": [
                    "x",
                    "y"
                ],
                "doc": "Sets window position using ``x`` and ``y`` coordinates.\n\nThe position is relative to the top left corner of the screen,\nbut some browsers exclude possible task bar set by the operating\nsystem from the calculation. The actual position may thus be\ndifferent with different browsers.\n\nValues can be given using strings containing numbers or by using\nactual numbers. See also `Get Window Position`.\n\nExample:\n| `Set Window Position` | 100 | 200 |",
                "shortdoc": "Sets window position using ``x`` and ``y`` coordinates.",
                "tags": [],
                "matched": true
            },
            {
                "name": "Set Window Size",
                "args": [
                    "width",
                    "height",
                    "inner=False"
                ],
                "doc": "Sets current windows size to given ``width`` and ``height``.\n\nValues can be given using strings containing numbers or by using\nactual numbers. See also `Get Window Size`.\n\nBrowsers have a limit on their minimum size. Trying to set them\nsmaller will cause the actual size to be bigger than the requested\nsize.\n\nIf ``inner`` parameter is set to True, keyword sets the necessary\nwindow width and height to have the desired HTML DOM _window.innerWidth_\nand _window.innerHeight_. See `Boolean arguments` for more details on how to set boolean\narguments.\n\nThe ``inner`` argument is new since SeleniumLibrary 4.0.\n\nThis ``inner`` argument does not support Frames. If a frame is selected,\nswitch to default before running this.\n\nExample:\n| `Set Window Size` | 800 | 600 |      |\n| `Set Window Size` | 800 | 600 | True |",
                "shortdoc": "Sets current windows size to given ``width`` and ``height``.",
                "tags": [],
                "matched": true
            },
            {
                "name": "Simulate Event",
                "args": [
                    "locator",
                    "event"
                ],
                "doc": "Simulates ``event`` on the element identified by ``locator``.\n\nThis keyword is useful if element has ``OnEvent`` handler that\nneeds to be explicitly invoked.\n\nSee the `Locating elements` section for details about the locator\nsyntax.\n\nPrior to SeleniumLibrary 3.0 this keyword was named `Simulate`.",
                "shortdoc": "Simulates ``event`` on the element identified by ``locator``.",
                "tags": [],
                "matched": true
            },
            {
                "name": "Submit Form",
                "args": [
                    "locator=None"
                ],
                "doc": "Submits a form identified by ``locator``.\n\nIf ``locator`` is not given, first form on the page is submitted.\n\nSee the `Locating elements` section for details about the locator\nsyntax.",
                "shortdoc": "Submits a form identified by ``locator``.",
                "tags": [],
                "matched": true
            },
            {
                "name": "Switch Browser",
                "args": [
                    "index_or_alias"
                ],
                "doc": "Switches between active browsers using ``index_or_alias``.\n\nIndices are returned by the `Open Browser` keyword and aliases can\nbe given to it explicitly. Indices start from 1.\n\nExample:\n| `Open Browser`        | http://google.com | ff       |\n| `Location Should Be`  | http://google.com |          |\n| `Open Browser`        | http://yahoo.com  | ie       | alias=second |\n| `Location Should Be`  | http://yahoo.com  |          |\n| `Switch Browser`      | 1                 | # index  |\n| `Page Should Contain` | I'm feeling lucky |          |\n| `Switch Browser`      | second            | # alias  |\n| `Page Should Contain` | More Yahoo!       |          |\n| `Close All Browsers`  |                   |          |\n\nAbove example expects that there was no other open browsers when\nopening the first one because it used index ``1`` when switching to\nit later. If you are not sure about that, you can store the index\ninto a variable as below.\n\n| ${index} =         | `Open Browser` | http://google.com |\n| # Do something ... |                |                   |\n| `Switch Browser`   | ${index}       |                   |",
                "shortdoc": "Switches between active browsers using ``index_or_alias``.",
                "tags": [],
                "matched": true
            },
            {
                "name": "Switch Window",
                "args": [
                    "locator=MAIN",
                    "timeout=None",
                    "browser=CURRENT"
                ],
                "doc": "Switches to browser window matching ``locator``.\n\nIf the window is found, all subsequent commands use the selected\nwindow, until this keyword is used again. If the window is not\nfound, this keyword fails. The previous windows handle is returned\nand can be used to switch back to it later.\n\nNotice that alerts should be handled with\n`Handle Alert` or other alert related keywords.\n\nThe ``locator`` can be specified using different strategies somewhat\nsimilarly as when `locating elements` on pages.\n\n- By default, the ``locator`` is matched against window handle, name,\n  title, and URL. Matching is done in that order and the first\n  matching window is selected.\n\n- The ``locator`` can specify an explicit strategy by using the format\n  ``strategy:value`` (recommended) or ``strategy=value``. Supported\n  strategies are ``name``, ``title``, and ``url``. These matches windows\n  using their name, title, or URL, respectively. Additionally, ``default``\n  can be used to explicitly use the default strategy explained above.\n\n- If the ``locator`` is ``NEW`` (case-insensitive), the latest\n  opened window is selected. It is an error if this is the same\n  as the current window.\n\n- If the ``locator`` is ``MAIN`` (default, case-insensitive),\n  the main window is selected.\n\n- If the ``locator`` is ``CURRENT`` (case-insensitive), nothing is\n  done. This effectively just returns the current window handle.\n\n- If the ``locator`` is not a string, it is expected to be a list\n  of window handles _to exclude_. Such a list of excluded windows\n  can be got from `Get Window Handles` before doing an action that\n  opens a new window.\n\nThe ``timeout`` is used to specify how long keyword will poll to select\nthe new window. The ``timeout`` is new in SeleniumLibrary 3.2.\n\nExample:\n| `Click Link`      | popup1      |      | # Open new window |\n| `Switch Window`   | example     |      | # Select window using default strategy |\n| `Title Should Be` | Pop-up 1    |      |\n| `Click Button`    | popup2      |      | # Open another window |\n| ${handle} = | `Switch Window`   | NEW  | # Select latest opened window |\n| `Title Should Be` | Pop-up 2    |      |\n| `Switch Window`   | ${handle}   |      | # Select window using handle |\n| `Title Should Be` | Pop-up 1    |      |\n| `Switch Window`   | MAIN        |      | # Select the main window |\n| `Title Should Be` | Main        |      |\n| ${excludes} = | `Get Window Handles` | | # Get list of current windows |\n| `Click Link`      | popup3      |      | # Open one more window |\n| `Switch Window`   | ${excludes} |      | # Select window using excludes |\n| `Title Should Be` | Pop-up 3    |      |\n\nThe ``browser`` argument allows with ``index_or_alias`` to implicitly switch to\na specific browser when switching to a window. See `Switch Browser`\n\n- If the ``browser`` is ``CURRENT`` (case-insensitive), no other browser is\n  selected.\n\n*NOTE:*\n\n- The ``strategy:value`` syntax is only supported by SeleniumLibrary\n  3.0 and newer.\n- Prior to SeleniumLibrary 3.0 matching windows by name, title\n  and URL was case-insensitive.\n- Earlier versions supported aliases ``None``, ``null`` and the\n  empty string for selecting the main window, and alias ``self``\n  for selecting the current window. Support for these aliases was\n  removed in SeleniumLibrary 3.2.",
                "shortdoc": "Switches to browser window matching ``locator``.",
                "tags": [],
                "matched": true
            },
            {
                "name": "Table Cell Should Contain",
                "args": [
                    "locator",
                    "row",
                    "column",
                    "expected",
                    "loglevel=TRACE"
                ],
                "doc": "Verifies table cell contains text ``expected``.\n\nSee `Get Table Cell` that this keyword uses internally for\nan explanation about accepted arguments.",
                "shortdoc": "Verifies table cell contains text ``expected``.",
                "tags": [],
                "matched": true
            },
            {
                "name": "Table Column Should Contain",
                "args": [
                    "locator",
                    "column",
                    "expected",
                    "loglevel=TRACE"
                ],
                "doc": "Verifies table column contains text ``expected``.\n\nThe table is located using the ``locator`` argument and its column\nfound using ``column``. See the `Locating elements` section for\ndetails about the locator syntax.\n\nColumn indexes start from 1. It is possible to refer to columns\nfrom the end by using negative indexes so that -1 is the last column,\n-2 is the second last, and so on.\n\nIf a table contains cells that span multiple columns, those merged\ncells count as a single column.\n\nSee `Page Should Contain Element` for an explanation about the\n``loglevel`` argument.",
                "shortdoc": "Verifies table column contains text ``expected``.",
                "tags": [],
                "matched": true
            },
            {
                "name": "Table Footer Should Contain",
                "args": [
                    "locator",
                    "expected",
                    "loglevel=TRACE"
                ],
                "doc": "Verifies table footer contains text ``expected``.\n\nAny ``<td>`` element inside ``<tfoot>`` element is considered to\nbe part of the footer.\n\nThe table is located using the ``locator`` argument. See the\n`Locating elements` section for details about the locator syntax.\n\nSee `Page Should Contain Element` for an explanation about the\n``loglevel`` argument.",
                "shortdoc": "Verifies table footer contains text ``expected``.",
                "tags": [],
                "matched": true
            },
            {
                "name": "Table Header Should Contain",
                "args": [
                    "locator",
                    "expected",
                    "loglevel=TRACE"
                ],
                "doc": "Verifies table header contains text ``expected``.\n\nAny ``<th>`` element anywhere in the table is considered to be\npart of the header.\n\nThe table is located using the ``locator`` argument. See the\n`Locating elements` section for details about the locator syntax.\n\nSee `Page Should Contain Element` for an explanation about the\n``loglevel`` argument.",
                "shortdoc": "Verifies table header contains text ``expected``.",
                "tags": [],
                "matched": true
            },
            {
                "name": "Table Row Should Contain",
                "args": [
                    "locator",
                    "row",
                    "expected",
                    "loglevel=TRACE"
                ],
                "doc": "Verifies that table row contains text ``expected``.\n\nThe table is located using the ``locator`` argument and its column\nfound using ``column``. See the `Locating elements` section for\ndetails about the locator syntax.\n\nRow indexes start from 1. It is possible to refer to rows\nfrom the end by using negative indexes so that -1 is the last row,\n-2 is the second last, and so on.\n\nIf a table contains cells that span multiple rows, a match\nonly occurs for the uppermost row of those merged cells.\n\nSee `Page Should Contain Element` for an explanation about the\n``loglevel`` argument.",
                "shortdoc": "Verifies that table row contains text ``expected``.",
                "tags": [],
                "matched": true
            },
            {
                "name": "Table Should Contain",
                "args": [
                    "locator",
                    "expected",
                    "loglevel=TRACE"
                ],
                "doc": "Verifies table contains text ``expected``.\n\nThe table is located using the ``locator`` argument. See the\n`Locating elements` section for details about the locator syntax.\n\nSee `Page Should Contain Element` for an explanation about the\n``loglevel`` argument.",
                "shortdoc": "Verifies table contains text ``expected``.",
                "tags": [],
                "matched": true
            },
            {
                "name": "Textarea Should Contain",
                "args": [
                    "locator",
                    "expected",
                    "message=None"
                ],
                "doc": "Verifies text area ``locator`` contains text ``expected``.\n\n``message`` can be used to override default error message.\n\nSee the `Locating elements` section for details about the locator\nsyntax.",
                "shortdoc": "Verifies text area ``locator`` contains text ``expected``.",
                "tags": [],
                "matched": true
            },
            {
                "name": "Textarea Value Should Be",
                "args": [
                    "locator",
                    "expected",
                    "message=None"
                ],
                "doc": "Verifies text area ``locator`` has exactly text ``expected``.\n\n``message`` can be used to override default error message.\n\nSee the `Locating elements` section for details about the locator\nsyntax.",
                "shortdoc": "Verifies text area ``locator`` has exactly text ``expected``.",
                "tags": [],
                "matched": true
            },
            {
                "name": "Textfield Should Contain",
                "args": [
                    "locator",
                    "expected",
                    "message=None"
                ],
                "doc": "Verifies text field ``locator`` contains text ``expected``.\n\n``message`` can be used to override the default error message.\n\nSee the `Locating elements` section for details about the locator\nsyntax.",
                "shortdoc": "Verifies text field ``locator`` contains text ``expected``.",
                "tags": [],
                "matched": true
            },
            {
                "name": "Textfield Value Should Be",
                "args": [
                    "locator",
                    "expected",
                    "message=None"
                ],
                "doc": "Verifies text field ``locator`` has exactly text ``expected``.\n\n``message`` can be used to override default error message.\n\nSee the `Locating elements` section for details about the locator\nsyntax.",
                "shortdoc": "Verifies text field ``locator`` has exactly text ``expected``.",
                "tags": [],
                "matched": true
            },
            {
                "name": "Title Should Be",
                "args": [
                    "title",
                    "message=None"
                ],
                "doc": "Verifies that the current page title equals ``title``.\n\nThe ``message`` argument can be used to override the default error\nmessage.\n\n``message`` argument is new in SeleniumLibrary 3.1.",
                "shortdoc": "Verifies that the current page title equals ``title``.",
                "tags": [],
                "matched": true
            },
            {
                "name": "Unselect All From List",
                "args": [
                    "locator"
                ],
                "doc": "Unselects all options from multi-selection list ``locator``.\n\nSee the `Locating elements` section for details about the locator\nsyntax.\n\nNew in SeleniumLibrary 3.0.",
                "shortdoc": "Unselects all options from multi-selection list ``locator``.",
                "tags": [],
                "matched": true
            },
            {
                "name": "Unselect Checkbox",
                "args": [
                    "locator"
                ],
                "doc": "Removes the selection of checkbox identified by ``locator``.\n\nDoes nothing if the checkbox is not selected.\n\nSee the `Locating elements` section for details about the locator\nsyntax.",
                "shortdoc": "Removes the selection of checkbox identified by ``locator``.",
                "tags": [],
                "matched": true
            },
            {
                "name": "Unselect Frame",
                "args": [],
                "doc": "Sets the main frame as the current frame.\n\nIn practice cancels the previous `Select Frame` call.",
                "shortdoc": "Sets the main frame as the current frame.",
                "tags": [],
                "matched": true
            },
            {
                "name": "Unselect From List By Index",
                "args": [
                    "locator",
                    "*indexes"
                ],
                "doc": "Unselects options from selection list ``locator`` by ``indexes``.\n\nIndexes of list options start from 0. This keyword works only with\nmulti-selection lists.\n\nSee the `Locating elements` section for details about the locator\nsyntax.",
                "shortdoc": "Unselects options from selection list ``locator`` by ``indexes``.",
                "tags": [],
                "matched": true
            },
            {
                "name": "Unselect From List By Label",
                "args": [
                    "locator",
                    "*labels"
                ],
                "doc": "Unselects options from selection list ``locator`` by ``labels``.\n\nThis keyword works only with multi-selection lists.\n\nSee the `Locating elements` section for details about the locator\nsyntax.",
                "shortdoc": "Unselects options from selection list ``locator`` by ``labels``.",
                "tags": [],
                "matched": true
            },
            {
                "name": "Unselect From List By Value",
                "args": [
                    "locator",
                    "*values"
                ],
                "doc": "Unselects options from selection list ``locator`` by ``values``.\n\nThis keyword works only with multi-selection lists.\n\nSee the `Locating elements` section for details about the locator\nsyntax.",
                "shortdoc": "Unselects options from selection list ``locator`` by ``values``.",
                "tags": [],
                "matched": true
            },
            {
                "name": "Wait And Click Button",
                "args": [
                    "locator: str",
                    "modifier: str = None"
                ],
                "doc": "Click button identified by ``locator``, once it becomes visible.\n\n``locator`` element locator\n\n``modifier`` press given keys while clicking the element, e.g. CTRL\n\nExample:\n\n| Click Button When Visible  | //button[@class=\"mybutton\"] |",
                "shortdoc": "Click button identified by ``locator``, once it becomes visible.",
                "tags": [],
                "matched": true
            },
            {
                "name": "Wait For Condition",
                "args": [
                    "condition",
                    "timeout=None",
                    "error=None"
                ],
                "doc": "Waits until ``condition`` is true or ``timeout`` expires.\n\nThe condition can be arbitrary JavaScript expression but it\nmust return a value to be evaluated. See `Execute JavaScript` for\ninformation about accessing content on pages.\n\nFails if the timeout expires before the condition becomes true. See\nthe `Timeouts` section for more information about using timeouts\nand their default value.\n\n``error`` can be used to override the default error message.\n\nExamples:\n| `Wait For Condition` | return document.title == \"New Title\" |\n| `Wait For Condition` | return jQuery.active == 0            |\n| `Wait For Condition` | style = document.querySelector('h1').style; return style.background == \"red\" && style.color == \"white\" |",
                "shortdoc": "Waits until ``condition`` is true or ``timeout`` expires.",
                "tags": [],
                "matched": true
            },
            {
                "name": "Wait Until Element Contains",
                "args": [
                    "locator",
                    "text",
                    "timeout=None",
                    "error=None"
                ],
                "doc": "Waits until the element ``locator`` contains ``text``.\n\nFails if ``timeout`` expires before the text appears. See\nthe `Timeouts` section for more information about using timeouts and\ntheir default value and the `Locating elements` section for details\nabout the locator syntax.\n\n``error`` can be used to override the default error message.",
                "shortdoc": "Waits until the element ``locator`` contains ``text``.",
                "tags": [],
                "matched": true
            },
            {
                "name": "Wait Until Element Does Not Contain",
                "args": [
                    "locator",
                    "text",
                    "timeout=None",
                    "error=None"
                ],
                "doc": "Waits until the element ``locator`` does not contain ``text``.\n\nFails if ``timeout`` expires before the text disappears. See\nthe `Timeouts` section for more information about using timeouts and\ntheir default value and the `Locating elements` section for details\nabout the locator syntax.\n\n``error`` can be used to override the default error message.",
                "shortdoc": "Waits until the element ``locator`` does not contain ``text``.",
                "tags": [],
                "matched": true
            },
            {
                "name": "Wait Until Element Is Enabled",
                "args": [
                    "locator",
                    "timeout=None",
                    "error=None"
                ],
                "doc": "Waits until the element ``locator`` is enabled.\n\nElement is considered enabled if it is not disabled nor read-only.\n\nFails if ``timeout`` expires before the element is enabled. See\nthe `Timeouts` section for more information about using timeouts and\ntheir default value and the `Locating elements` section for details\nabout the locator syntax.\n\n``error`` can be used to override the default error message.\n\nConsidering read-only elements to be disabled is a new feature\nin SeleniumLibrary 3.0.",
                "shortdoc": "Waits until the element ``locator`` is enabled.",
                "tags": [],
                "matched": true
            },
            {
                "name": "Wait Until Element Is Not Visible",
                "args": [
                    "locator",
                    "timeout=None",
                    "error=None"
                ],
                "doc": "Waits until the element ``locator`` is not visible.\n\nFails if ``timeout`` expires before the element is not visible. See\nthe `Timeouts` section for more information about using timeouts and\ntheir default value and the `Locating elements` section for details\nabout the locator syntax.\n\n``error`` can be used to override the default error message.",
                "shortdoc": "Waits until the element ``locator`` is not visible.",
                "tags": [],
                "matched": true
            },
            {
                "name": "Wait Until Element Is Visible",
                "args": [
                    "locator",
                    "timeout=None",
                    "error=None"
                ],
                "doc": "Waits until the element ``locator`` is visible.\n\nFails if ``timeout`` expires before the element is visible. See\nthe `Timeouts` section for more information about using timeouts and\ntheir default value and the `Locating elements` section for details\nabout the locator syntax.\n\n``error`` can be used to override the default error message.",
                "shortdoc": "Waits until the element ``locator`` is visible.",
                "tags": [],
                "matched": true
            },
            {
                "name": "Wait Until Location Contains",
                "args": [
                    "expected",
                    "timeout=None",
                    "message=None"
                ],
                "doc": "Waits until the current URL contains ``expected``.\n\nThe ``expected`` argument contains the expected value in url.\n\nFails if ``timeout`` expires before the location contains. See\nthe `Timeouts` section for more information about using timeouts\nand their default value.\n\nThe ``message`` argument can be used to override the default error\nmessage.\n\nNew in SeleniumLibrary 4.0",
                "shortdoc": "Waits until the current URL contains ``expected``.",
                "tags": [],
                "matched": true
            },
            {
                "name": "Wait Until Location Does Not Contain",
                "args": [
                    "location",
                    "timeout=None",
                    "message=None"
                ],
                "doc": "Waits until the current URL does not contains ``location``.\n\nThe ``location`` argument contains value not expected in url.\n\nFails if ``timeout`` expires before the location not contains. See\nthe `Timeouts` section for more information about using timeouts\nand their default value.\n\nThe ``message`` argument can be used to override the default error\nmessage.\n\nNew in SeleniumLibrary 4.3",
                "shortdoc": "Waits until the current URL does not contains ``location``.",
                "tags": [],
                "matched": true
            },
            {
                "name": "Wait Until Location Is",
                "args": [
                    "expected",
                    "timeout=None",
                    "message=None"
                ],
                "doc": "Waits until the current URL is ``expected``.\n\nThe ``expected`` argument is the expected value in url.\n\nFails if ``timeout`` expires before the location is. See\nthe `Timeouts` section for more information about using timeouts\nand their default value.\n\nThe ``message`` argument can be used to override the default error\nmessage.\n\nNew in SeleniumLibrary 4.0",
                "shortdoc": "Waits until the current URL is ``expected``.",
                "tags": [],
                "matched": true
            },
            {
                "name": "Wait Until Location Is Not",
                "args": [
                    "location",
                    "timeout=None",
                    "message=None"
                ],
                "doc": "Waits until the current URL is not ``location``.\n\nThe ``location`` argument is the unexpected value in url.\n\nFails if ``timeout`` expires before the location is not. See\nthe `Timeouts` section for more information about using timeouts\nand their default value.\n\nThe ``message`` argument can be used to override the default error\nmessage.\n\nNew in SeleniumLibrary 4.3",
                "shortdoc": "Waits until the current URL is not ``location``.",
                "tags": [],
                "matched": true
            },
            {
                "name": "Wait Until Page Contains",
                "args": [
                    "text",
                    "timeout=None",
                    "error=None"
                ],
                "doc": "Waits until ``text`` appears on the current page.\n\nFails if ``timeout`` expires before the text appears. See\nthe `Timeouts` section for more information about using timeouts\nand their default value.\n\n``error`` can be used to override the default error message.",
                "shortdoc": "Waits until ``text`` appears on the current page.",
                "tags": [],
                "matched": true
            },
            {
                "name": "Wait Until Page Contains Element",
                "args": [
                    "locator",
                    "timeout=None",
                    "error=None",
                    "limit=None"
                ],
                "doc": "Waits until the element ``locator`` appears on the current page.\n\nFails if ``timeout`` expires before the element appears. See\nthe `Timeouts` section for more information about using timeouts and\ntheir default value and the `Locating elements` section for details\nabout the locator syntax.\n\n``error`` can be used to override the default error message.\n\nThe ``limit`` argument can used to define how many elements the\npage should contain. When ``limit`` is `None` (default) page can\ncontain one or more elements. When limit is a number, page must\ncontain same number of elements.\n\n``limit`` is new in SeleniumLibrary 4.4",
                "shortdoc": "Waits until the element ``locator`` appears on the current page.",
                "tags": [],
                "matched": true
            },
            {
                "name": "Wait Until Page Does Not Contain",
                "args": [
                    "text",
                    "timeout=None",
                    "error=None"
                ],
                "doc": "Waits until ``text`` disappears from the current page.\n\nFails if ``timeout`` expires before the text disappears. See\nthe `Timeouts` section for more information about using timeouts\nand their default value.\n\n``error`` can be used to override the default error message.",
                "shortdoc": "Waits until ``text`` disappears from the current page.",
                "tags": [],
                "matched": true
            },
            {
                "name": "Wait Until Page Does Not Contain Element",
                "args": [
                    "locator",
                    "timeout=None",
                    "error=None",
                    "limit=None"
                ],
                "doc": "Waits until the element ``locator`` disappears from the current page.\n\nFails if ``timeout`` expires before the element disappears. See\nthe `Timeouts` section for more information about using timeouts and\ntheir default value and the `Locating elements` section for details\nabout the locator syntax.\n\n``error`` can be used to override the default error message.\n\nThe ``limit`` argument can used to define how many elements the\npage should not contain. When ``limit`` is `None` (default) page can`t\ncontain any elements. When limit is a number, page must not\ncontain same number of elements.\n\n``limit`` is new in SeleniumLibrary 4.4",
                "shortdoc": "Waits until the element ``locator`` disappears from the current page.",
                "tags": [],
                "matched": true
            }
        ],
        "all_tags": [],
        "contains_tags": false
    },
    "RPA.Cloud.AWS": {
        "name": "RPA.Cloud.AWS",
        "doc": "`AWS` is a library for operating with Amazon AWS services S3, SQS,\nTextract and Comprehend.\n\nServices are initialized with keywords like ``Init S3 Client`` for S3.\n\n**AWS authentication**\n\nAuthentication for AWS is set with `key id` and `access key` which can be given to the library\nin three different ways.\n\n- Method 1 as environment variables, ``AWS_KEY_ID`` and ``AWS_KEY``.\n- Method 2 as keyword parameters to ``Init Textract Client`` for example.\n- Method 3 as Robocloud vault secret. The vault name needs to be given in library init or\n  with keyword ``Set Robocloud Vault``. Secret keys are expected to match environment variable\n  names.\n\nMethod 1. credentials using environment variable\n\n.. code-block:: robotframework\n\n    *** Settings ***\n    Library   RPA.Cloud.AWS\n\n    *** Tasks ***\n    Init AWS services\n        # NO parameters for client, expecting to get credentials\n        # with AWS_KEY and AWS_KEY_ID environment variable\n        Init S3 Client\n\nMethod 2. credentials with keyword parameter\n\n.. code-block:: robotframework\n\n    *** Settings ***\n    Library   RPA.Cloud.AWS\n\n    *** Tasks ***\n    Init AWS services\n        Init S3 Client  aws_key_id=${AWS_KEY_ID}  aws_key=${AWS_KEY}\n\nMethod 3. setting Robocloud Vault in the library init\n\n.. code-block:: robotframework\n\n    *** Settings ***\n    Library   RPA.Cloud.AWS  robocloud_vault_name=aws\n\n    *** Tasks ***\n    Init AWS services\n        Init S3 Client  use_robocloud_vault=${TRUE}\n\nMethod 3. setting Robocloud Vault with keyword\n\n.. code-block:: robotframework\n\n    *** Settings ***\n    Library   RPA.Cloud.AWS\n\n    *** Tasks ***\n    Init Azure services\n        Set Robocloud Vault         vault_name=aws\n        Init Textract Client  use_robocloud_vault=${TRUE}\n\n**Requirements**\n\nThe default installation depends on `boto3`_ library. Due to the size of the\ndependency, this library has been set as an optional package for ``rpaframework``.\n\nThis can be installed by opting in to the `aws` dependency:\n\n``pip install rpaframework[aws]``\n\n.. _boto3:\n    https://boto3.amazonaws.com/v1/documentation/api/latest/index.html\n\n**Example**\n\n.. code-block:: robotframework\n\n    *** Settings ***\n    Library   RPA.Cloud.AWS   region=us-east-1\n\n    *** Variables ***\n    ${BUCKET_NAME}        testbucket12213123123\n\n    *** Tasks ***\n    Upload a file into S3 bucket\n        [Setup]   Init S3 Client\n        Upload File      ${BUCKET_NAME}   ${/}path${/}to${/}file.pdf\n        @{files}         List Files   ${BUCKET_NAME}\n        FOR   ${file}  IN   @{files}\n            Log  ${file}\n        END",
        "version": "",
        "named_args": true,
        "scope": "GLOBAL",
        "generated": "2020-12-01 14:53:06",
        "inits": [
            {
                "name": "Init",
                "args": [
                    "region: str = eu-west-1",
                    "robocloud_vault_name: str = None"
                ],
                "doc": "Initialize self.  See help(type(self)) for accurate signature.",
                "shortdoc": "Initialize self.  See help(type(self)) for accurate signature.",
                "tags": [],
                "matched": true
            }
        ],
        "keywords": [
            {
                "name": "Analyze Document",
                "args": [
                    "image_file: str = None",
                    "json_file: str = None",
                    "bucket_name: str = None"
                ],
                "doc": "Analyzes an input document for relationships between detected items\n\n:param image_file: filepath (or object name) of image file\n:param json_file: filepath to resulting json file\n:param bucket_name: if given then using `image_file` from the bucket\n:return: analysis response in json",
                "shortdoc": "Analyzes an input document for relationships between detected items",
                "tags": [],
                "matched": true
            },
            {
                "name": "Create Bucket",
                "args": [
                    "bucket_name: str = None"
                ],
                "doc": "Create S3 bucket with name\n\n:param bucket_name: name for the bucket\n:return: boolean indicating status of operation",
                "shortdoc": "Create S3 bucket with name",
                "tags": [],
                "matched": true
            },
            {
                "name": "Create Queue",
                "args": [
                    "queue_name: str = None"
                ],
                "doc": "Create queue with name\n\n:param queue_name: [description], defaults to None\n:return: create queue response as dict",
                "shortdoc": "Create queue with name",
                "tags": [],
                "matched": true
            },
            {
                "name": "Delete Bucket",
                "args": [
                    "bucket_name: str = None"
                ],
                "doc": "Delete S3 bucket with name\n\n:param bucket_name: name for the bucket\n:return: boolean indicating status of operation",
                "shortdoc": "Delete S3 bucket with name",
                "tags": [],
                "matched": true
            },
            {
                "name": "Delete Files",
                "args": [
                    "bucket_name: str = None",
                    "files: list = None"
                ],
                "doc": "Delete files in the bucket\n\n:param bucket_name: name for the bucket\n:param files: list of files to delete\n:return: number of files deleted or `False`",
                "shortdoc": "Delete files in the bucket",
                "tags": [],
                "matched": true
            },
            {
                "name": "Delete Message",
                "args": [
                    "receipt_handle: str = None"
                ],
                "doc": "Delete message in the queue\n\n:param receipt_handle: message handle to delete\n:return: delete message response as dict",
                "shortdoc": "Delete message in the queue",
                "tags": [],
                "matched": true
            },
            {
                "name": "Delete Queue",
                "args": [
                    "queue_name: str = None"
                ],
                "doc": "Delete queue with name\n\n:param queue_name: [description], defaults to None\n:return: delete queue response as dict",
                "shortdoc": "Delete queue with name",
                "tags": [],
                "matched": true
            },
            {
                "name": "Detect Document Text",
                "args": [
                    "image_file: str = None",
                    "json_file: str = None",
                    "bucket_name: str = None"
                ],
                "doc": "Detects text in the input document.\n\n:param image_file: filepath (or object name) of image file\n:param json_file: filepath to resulting json file\n:param bucket_name: if given then using `image_file` from the bucket\n:return: analysis response in json",
                "shortdoc": "Detects text in the input document.",
                "tags": [],
                "matched": true
            },
            {
                "name": "Detect Entities",
                "args": [
                    "text: str = None",
                    "lang=en"
                ],
                "doc": "Inspects text for named entities, and returns information about them\n\n:param text: A UTF-8 text string. Each string must contain fewer\n    that 5,000 bytes of UTF-8 encoded characters\n:param lang: language code of the text, defaults to \"en\"",
                "shortdoc": "Inspects text for named entities, and returns information about them",
                "tags": [],
                "matched": true
            },
            {
                "name": "Detect Sentiment",
                "args": [
                    "text: str = None",
                    "lang=en"
                ],
                "doc": "Inspects text and returns an inference of the prevailing sentiment\n\n:param text: A UTF-8 text string. Each string must contain fewer\n    that 5,000 bytes of UTF-8 encoded characters\n:param lang: language code of the text, defaults to \"en\"",
                "shortdoc": "Inspects text and returns an inference of the prevailing sentiment",
                "tags": [],
                "matched": true
            },
            {
                "name": "Download Files",
                "args": [
                    "bucket_name: str = None",
                    "files: list = None",
                    "target_directory: str = None"
                ],
                "doc": "Download files from bucket to local filesystem\n\n:param bucket_name: name for the bucket\n:param files: list of S3 object names\n:param target_directory: location for the downloaded files, default\n    current directory\n:return: number of files downloaded",
                "shortdoc": "Download files from bucket to local filesystem",
                "tags": [],
                "matched": true
            },
            {
                "name": "Get Cells",
                "args": [],
                "doc": "[summary]\n\n:return: [description]",
                "shortdoc": "[summary]",
                "tags": [],
                "matched": true
            },
            {
                "name": "Get Document Analysis",
                "args": [
                    "job_id: str = None",
                    "max_results: int = 1000",
                    "next_token: str = None"
                ],
                "doc": "Get the results of Textract asynchronous `Document Analysis` operation\n\n:param job_id: job identifier, defaults to None\n:param max_results: number of blocks to get at a time, defaults to 1000\n:param next_token: pagination token for getting next set of results,\n       defaults to None\n:return: dictionary\n\nResponse dictionary has key `JobStatus` with value `SUCCEEDED` when analysis\nhas been completed.\n\nExample:\n\n.. code-block:: robotframework\n\n    Init Textract Client  %{AWS_KEY_ID}  %{AWS_KEY_SECRET}  %{AWS_REGION}\n    ${jobid}=    Start Document Analysis  s3bucket_name  invoice.pdf\n    FOR    ${i}    IN RANGE    50\n        ${response}    Get Document Analysis  ${jobid}\n        Exit For Loop If    \"${response}[JobStatus]\" == \"SUCCEEDED\"\n        Sleep    1s\n    END",
                "shortdoc": "Get the results of Textract asynchronous `Document Analysis` operation",
                "tags": [],
                "matched": true
            },
            {
                "name": "Get Document Text Detection",
                "args": [
                    "job_id: str = None",
                    "max_results: int = 1000",
                    "next_token: str = None"
                ],
                "doc": "Get the results of Textract asynchronous `Document Text Detection` operation\n\n:param job_id: job identifier, defaults to None\n:param max_results: number of blocks to get at a time, defaults to 1000\n:param next_token: pagination token for getting next set of results,\n       defaults to None\n:return: dictionary\n\nResponse dictionary has key `JobStatus` with value `SUCCEEDED` when analysis\nhas been completed.\n\nExample:\n\n.. code-block:: robotframework\n\n    Init Textract Client  %{AWS_KEY_ID}  %{AWS_KEY_SECRET}  %{AWS_REGION}\n    ${jobid}=    Start Document Text Detection  s3bucket_name  invoice.pdf\n    FOR    ${i}    IN RANGE    50\n        ${response}    Get Document Text Detection    ${jobid}\n        Exit For Loop If    \"${response}[JobStatus]\" == \"SUCCEEDED\"\n        Sleep    1s\n    END",
                "shortdoc": "Get the results of Textract asynchronous `Document Text Detection` operation",
                "tags": [],
                "matched": true
            },
            {
                "name": "Get Pages And Text",
                "args": [
                    "textract_response: dict"
                ],
                "doc": "Get pages and text out of Textract response json\n\n:param textract_response: JSON from Textract\n:return: dictionary, page numbers as keys and value is a list\n         of text lines",
                "shortdoc": "Get pages and text out of Textract response json",
                "tags": [],
                "matched": true
            },
            {
                "name": "Get Tables",
                "args": [],
                "doc": "[summary]\n\n:return: [description]",
                "shortdoc": "[summary]",
                "tags": [],
                "matched": true
            },
            {
                "name": "Get Words",
                "args": [],
                "doc": "[summary]\n\n:return: [description]",
                "shortdoc": "[summary]",
                "tags": [],
                "matched": true
            },
            {
                "name": "Init Comprehend Client",
                "args": [
                    "aws_key_id: str = None",
                    "aws_key: str = None",
                    "region: str = None",
                    "use_robocloud_vault: bool = False"
                ],
                "doc": "Initialize AWS Comprehend client\n\n:param aws_key_id: access key ID\n:param aws_key: secret access key\n:param region: AWS region\n:param use_robocloud_vault: use secret stored into `Robocloud Vault`",
                "shortdoc": "Initialize AWS Comprehend client",
                "tags": [],
                "matched": true
            },
            {
                "name": "Init S3 Client",
                "args": [
                    "aws_key_id: str = None",
                    "aws_key: str = None",
                    "region: str = None",
                    "use_robocloud_vault: bool = False"
                ],
                "doc": "Initialize AWS S3 client\n\n:param aws_key_id: access key ID\n:param aws_key: secret access key\n:param region: AWS region\n:param use_robocloud_vault: use secret stored into `Robocloud Vault`",
                "shortdoc": "Initialize AWS S3 client",
                "tags": [],
                "matched": true
            },
            {
                "name": "Init Sqs Client",
                "args": [
                    "aws_key_id: str = None",
                    "aws_key: str = None",
                    "region: str = None",
                    "queue_url: str = None",
                    "use_robocloud_vault: bool = False"
                ],
                "doc": "Initialize AWS SQS client\n\n:param aws_key_id: access key ID\n:param aws_key: secret access key\n:param region: AWS region\n:param queue_url: SQS queue url\n:param use_robocloud_vault: use secret stored into `Robocloud Vault`",
                "shortdoc": "Initialize AWS SQS client",
                "tags": [],
                "matched": true
            },
            {
                "name": "Init Textract Client",
                "args": [
                    "aws_key_id: str = None",
                    "aws_key: str = None",
                    "region: str = None",
                    "use_robocloud_vault: bool = False"
                ],
                "doc": "Initialize AWS Textract client\n\n:param aws_key_id: access key ID\n:param aws_key: secret access key\n:param region: AWS region\n:param use_robocloud_vault: use secret stored into `Robocloud Vault`",
                "shortdoc": "Initialize AWS Textract client",
                "tags": [],
                "matched": true
            },
            {
                "name": "List Buckets",
                "args": [],
                "doc": "List all buckets for this account\n\n:return: list of buckets",
                "shortdoc": "List all buckets for this account",
                "tags": [],
                "matched": true
            },
            {
                "name": "List Files",
                "args": [
                    "bucket_name"
                ],
                "doc": "List files in the bucket\n\n:param bucket_name: name for the bucket\n:return: list of files",
                "shortdoc": "List files in the bucket",
                "tags": [],
                "matched": true
            },
            {
                "name": "Receive Message",
                "args": [],
                "doc": "Receive message from queue\n\n:return: message as dict",
                "shortdoc": "Receive message from queue",
                "tags": [],
                "matched": true
            },
            {
                "name": "Send Message",
                "args": [
                    "message: str = None",
                    "message_attributes: dict = None"
                ],
                "doc": "Send message to the queue\n\n:param message: body of the message\n:param message_attributes: attributes of the message\n:return: send message response as dict",
                "shortdoc": "Send message to the queue",
                "tags": [],
                "matched": true
            },
            {
                "name": "Set Robocloud Vault",
                "args": [
                    "vault_name"
                ],
                "doc": "Set Robocloud Vault name\n\n:param vault_name: Robocloud Vault name",
                "shortdoc": "Set Robocloud Vault name",
                "tags": [],
                "matched": true
            },
            {
                "name": "Start Document Analysis",
                "args": [
                    "bucket_name_in: str = None",
                    "object_name_in: str = None",
                    "object_version_in: str = None",
                    "bucket_name_out: str = None",
                    "prefix_object_out: str = textract_output"
                ],
                "doc": "Starts the asynchronous analysis of an input document\nfor relationships between detected items such as key-value pairs,\ntables, and selection elements.\n\n:param bucket_name_in: name of the S3 bucket for the input object,\n    defaults to None\n:param object_name_in: name of the input object, defaults to None\n:param object_version_in: version of the input object, defaults to None\n:param bucket_name_out: name of the S3 bucket where to save analysis result\n    object, defaults to None\n:param prefix_object_out: name of the S3 bucket for the analysis result object,\n:return: job identifier\n\nInput object can be in JPEG, PNG or PDF format. Documents should\nbe located in the Amazon S3 bucket.\n\nBy default Amazon Textract will save the analysis result internally\nto be accessed by keyword ``Get Document Analysis``. This can\nbe overridden by giving parameter ``bucket_name_out``.",
                "shortdoc": "Starts the asynchronous analysis of an input document for relationships between detected items such as key-value pairs, tables, and selection elements.",
                "tags": [],
                "matched": true
            },
            {
                "name": "Start Document Text Detection",
                "args": [
                    "bucket_name_in: str = None",
                    "object_name_in: str = None",
                    "object_version_in: str = None",
                    "bucket_name_out: str = None",
                    "prefix_object_out: str = textract_output"
                ],
                "doc": "Starts the asynchronous detection of text in a document.\nAmazon Textract can detect lines of text and the words that make up a\nline of text.\n\n:param bucket_name_in: name of the S3 bucket for the input object,\n    defaults to None\n:param object_name_in: name of the input object, defaults to None\n:param object_version_in: version of the input object, defaults to None\n:param bucket_name_out: name of the S3 bucket where to save analysis result\n    object, defaults to None\n:param prefix_object_out: name of the S3 bucket for the analysis result object,\n:return: job identifier\n\nInput object can be in JPEG, PNG or PDF format. Documents should\nbe located in the Amazon S3 bucket.\n\nBy default Amazon Textract will save the analysis result internally\nto be accessed by keyword ``Get Document Text Detection``. This can\nbe overridden by giving parameter ``bucket_name_out``.",
                "shortdoc": "Starts the asynchronous detection of text in a document. Amazon Textract can detect lines of text and the words that make up a line of text.",
                "tags": [],
                "matched": true
            },
            {
                "name": "Upload File",
                "args": [
                    "bucket_name: str = None",
                    "filename: str = None",
                    "object_name: str = None"
                ],
                "doc": "Upload single file into bucket\n\n:param bucket_name: name for the bucket\n:param filename: filepath for the file to be uploaded\n:param object_name: name of the object in the bucket, defaults to None\n:return: tuple of upload status and error\n\nIf `object_name` is not given then basename of the file is\nused as `object_name`.",
                "shortdoc": "Upload single file into bucket",
                "tags": [],
                "matched": true
            },
            {
                "name": "Upload Files",
                "args": [
                    "bucket_name: str = None",
                    "files: list = None"
                ],
                "doc": "Upload multiple files into bucket\n\n:param bucket_name: name for the bucket\n:param files: list of files (2 possible ways, see above)\n:return: number of files uploaded\n\nGiving files as list of filepaths:\n    ['/path/to/file1.txt', '/path/to/file2.txt']\n\nGiving files as list of dictionaries (including filepath and object name):\n    [{'filepath':'/path/to/file1.txt', 'object_name': 'file1.txt'},\n    {'filepath': '/path/to/file2.txt', 'object_name': 'file2.txt'}]",
                "shortdoc": "Upload multiple files into bucket",
                "tags": [],
                "matched": true
            }
        ],
        "all_tags": [],
        "contains_tags": false
    },
    "RPA.Cloud.Azure": {
        "name": "RPA.Cloud.Azure",
        "doc": "`Azure` is a library for operating with Microsoft Azure API endpoints.\n\nList of supported service names:\n\n- computervision (`Azure Computer Vision API`_)\n- face (`Azure Face API`_)\n- speech (`Azure Speech Services API`_)\n- textanalytics (`Azure Text Analytics API`_)\n\n**Azure authentication**\n\nAuthentication for Azure is set with `service subscription key` which can be given to the library\nin two different ways.\n\n- Method 1 as environment variables, either service specific environment variable\n  for example ``AZURE_TEXTANALYTICS_KEY`` or with common key ``AZURE_SUBSCRIPTION_KEY`` which\n  will be used for all the services.\n- Method 2 as Robocloud vault secret. The vault name needs to be given in library init or\n  with keyword ``Set Robocloud Vault``. Secret keys are expected to match environment variable\n  names.\n\nMethod 1. subscription key using environment variable\n\n.. code-block:: robotframework\n\n    *** Settings ***\n    Library   RPA.Cloud.Azure\n\n    *** Tasks ***\n    Init Azure services\n        # NO parameters for client, expecting to get subscription key\n        # with AZURE_TEXTANALYTICS_KEY or AZURE_SUBSCRIPTION_KEY environment variable\n        Init Text Analytics Service\n\nMethod 2. setting Robocloud Vault in the library init\n\n.. code-block:: robotframework\n\n    *** Settings ***\n    Library   RPA.Cloud.Azure  robocloud_vault_name=azure\n\n    *** Tasks ***\n    Init Azure services\n        Init Text Analytics Service  use_robocloud_vault=${TRUE}\n\nMethod 2. setting Robocloud Vault with keyword\n\n.. code-block:: robotframework\n\n    *** Settings ***\n    Library   RPA.Cloud.Azure\n\n    *** Tasks ***\n    Init Azure services\n        Set Robocloud Vault          vault_name=googlecloud\n        Init Text Analytics Service  use_robocloud_vault=${TRUE}\n\n**References**\n\nList of supported language locales - `Azure locale list`_\n\nList of supported region identifiers - `Azure region list`_\n\n.. _Azure Computer Vision API: https://docs.microsoft.com/en-us/azure/cognitive-services/computer-vision/\n.. _Azure Face API: https://docs.microsoft.com/en-us/azure/cognitive-services/face/\n.. _Azure Speech Services API: https://docs.microsoft.com/en-us/azure/cognitive-services/speech-service/\n.. _Azure Text Analytics API: https://docs.microsoft.com/en-us/azure/cognitive-services/text-analytics/\n.. _Azure locale list: https://docs.microsoft.com/en-gb/azure/cognitive-services/speech-service/language-support#speech-to-text\n.. _Azure region list: https://docs.microsoft.com/en-gb/azure/cognitive-services/speech-service/regions#speech-to-text-text-to-speech-and-translation\n\n**Examples**\n\n**Robot Framework**\n\nThis is a section which describes how to use the library in your\nRobot Framework tasks.\n\n.. code-block:: robotframework\n\n   *** Settings ***\n   Library  RPA.Cloud.Azure\n\n   *** Variables ***\n   ${IMAGE_URL}   IMAGE_URL\n   ${FEATURES}    Faces,ImageType\n\n   *** Tasks ***\n   Visioning image information\n      Init Computer Vision Service\n      &{result}   Vision Analyze  image_url=${IMAGE_URL}  visual_features=${FEATURES}\n      @{faces}    Set Variable  ${result}[faces]\n      FOR  ${face}  IN   @{faces}\n         Log  Age: ${face}[age], Gender: ${face}[gender], Rectangle: ${face}[faceRectangle]\n      END\n\n**Python**\n\nThis is a section which describes how to use the library in your\nown Python modules.\n\n.. code-block:: python\n\n   library = Azure()\n   library.init_text_analytics_service()\n   library.init_face_service()\n   library.init_computer_vision_service()\n   library.init_speech_service(\"westeurope\")\n\n   response = library.sentiment_analyze(\n      text=\"The rooms were wonderful and the staff was helpful.\"\n   )\n   response = library.detect_face(\n      image_file=PATH_TO_FILE,\n      face_attributes=\"age,gender,smile,hair,facialHair,emotion\",\n   )\n   for item in response:\n      gender = item[\"faceAttributes\"][\"gender\"]\n      age = item[\"faceAttributes\"][\"age\"]\n      print(f\"Detected a face, gender:{gender}, age: {age}\")\n\n   response = library.vision_analyze(\n      image_url=URL_TO_IMAGE,\n      visual_features=\"Faces,ImageType\",\n   )\n   meta = response['metadata']\n   print(\n      f\"Image dimensions meta['width']}x{meta['height']} pixels\"\n   )\n\n   for face in response[\"faces\"]:\n      left = face[\"faceRectangle\"][\"left\"]\n      top = face[\"faceRectangle\"][\"top\"]\n      width = face[\"faceRectangle\"][\"width\"]\n      height = face[\"faceRectangle\"][\"height\"]\n      print(f\"Detected a face, gender:{face['gender']}, age: {face['age']}\")\n      print(f\"      Face rectangle: (left={left}, top={top})\")\n      print(f\"      Face rectangle: (width={width}, height={height})\")\n\n   library.text_to_speech(\n       text=\"Developer tools for open-source RPA leveraging the Robot Framework ecosystem\",\n       neural_voice_style=\"cheerful\",\n       target_file='output.mp3'\n   )",
        "version": "",
        "named_args": true,
        "scope": "GLOBAL",
        "generated": "2020-12-01 14:53:06",
        "inits": [
            {
                "name": "Init",
                "args": [
                    "region: str = northeurope",
                    "robocloud_vault_name: str = None"
                ],
                "doc": "Initialize self.  See help(type(self)) for accurate signature.",
                "shortdoc": "Initialize self.  See help(type(self)) for accurate signature.",
                "tags": [],
                "matched": true
            }
        ],
        "keywords": [
            {
                "name": "Detect Face",
                "args": [
                    "image_file: str = None",
                    "image_url: str = None",
                    "face_attributes: str = None",
                    "face_landmarks: bool = False",
                    "recognition_model: str = recognition_02",
                    "json_file: str = None"
                ],
                "doc": "Detect facial attributes in the image\n\n:param image_file: filepath of image file\n:param image_url: URI to image, if given will be used instead of `image_file`\n:param face_attributes: comma separated list of attributes,\n    for example. \"age,gender,smile\"\n:param face_landmarks: return face landmarks of the detected faces\n    or not. The default value is `False`\n:param recognition_model: model used by Azure to detech faces, options\n    are \"recognition_01\" or \"recognition_02\", default is \"recognition_02\"\n:param json_file: filepath to write results into\n:return: analysis in json format\n\nRead more about `face_attributes` at `Face detection explained`_:\n\n- age\n- gender\n- smile\n- facialHair\n- headPose\n- glasses\n- emotion\n- hair\n- makeup\n- accessories\n- blur\n- exposure\n- nouse\n\n.. _Face detection explained: https://docs.microsoft.com/en-us/azure/cognitive-services/face/concepts/face-detection",
                "shortdoc": "Detect facial attributes in the image",
                "tags": [],
                "matched": true
            },
            {
                "name": "Detect Language",
                "args": [
                    "text: str",
                    "json_file: str = None"
                ],
                "doc": "Detect languages in the given text\n\n:param text: A UTF-8 text string\n:param json_file: filepath to write results into\n:return: analysis in json format",
                "shortdoc": "Detect languages in the given text",
                "tags": [],
                "matched": true
            },
            {
                "name": "Find Entities",
                "args": [
                    "text: str",
                    "language: str = None",
                    "json_file=None"
                ],
                "doc": "Detect entities in the given text\n\n:param text: A UTF-8 text string\n:param language: if input language is known\n:param json_file: filepath to write results into\n:return: analysis in json format",
                "shortdoc": "Detect entities in the given text",
                "tags": [],
                "matched": true
            },
            {
                "name": "Init Computer Vision Service",
                "args": [
                    "region: str = None",
                    "use_robocloud_vault: bool = False"
                ],
                "doc": "Initialize Azure Computer Vision\n\n:param region: identifier for service region\n:param use_robocloud_vault: use secret stored into `Robocloud Vault`",
                "shortdoc": "Initialize Azure Computer Vision",
                "tags": [],
                "matched": true
            },
            {
                "name": "Init Face Service",
                "args": [
                    "region: str = None",
                    "use_robocloud_vault: bool = False"
                ],
                "doc": "Initialize Azure Face\n\n:param region: identifier for service region\n:param use_robocloud_vault: use secret stored into `Robocloud Vault`",
                "shortdoc": "Initialize Azure Face",
                "tags": [],
                "matched": true
            },
            {
                "name": "Init Speech Service",
                "args": [
                    "region: str = None",
                    "use_robocloud_vault: bool = False"
                ],
                "doc": "Initialize Azure Speech\n\n:param region: identifier for service region\n:param use_robocloud_vault: use secret stored into `Robocloud Vault`",
                "shortdoc": "Initialize Azure Speech",
                "tags": [],
                "matched": true
            },
            {
                "name": "Init Text Analytics Service",
                "args": [
                    "region: str = None",
                    "use_robocloud_vault: bool = False"
                ],
                "doc": "Initialize Azure Text Analyticts\n\n:param region: identifier for service region\n:param use_robocloud_vault: use secret stored into `Robocloud Vault`",
                "shortdoc": "Initialize Azure Text Analyticts",
                "tags": [],
                "matched": true
            },
            {
                "name": "Key Phrases",
                "args": [
                    "text: str",
                    "language: str = None",
                    "json_file: str = None"
                ],
                "doc": "Detect key phrases in the given text\n\n:param text: A UTF-8 text string\n:param language: if input language is known\n:param json_file: filepath to write results into\n:return: analysis in json format",
                "shortdoc": "Detect key phrases in the given text",
                "tags": [],
                "matched": true
            },
            {
                "name": "List Supported Voices",
                "args": [
                    "locale: str = None",
                    "neural_only: bool = False",
                    "json_file: str = None"
                ],
                "doc": "List supported voices for Azure API Speech Services.\n\n:param locale: list only voices specific to locale, by default return all voices\n:param neural_only: `True` if only neural voices should be returned,\n    `False` by default\n:param json_file: filepath to write results into\n:return: voices in json\n\nAvailable voice selection might differ between regions.",
                "shortdoc": "List supported voices for Azure API Speech Services.",
                "tags": [],
                "matched": true
            },
            {
                "name": "Sentiment Analyze",
                "args": [
                    "text: str",
                    "language: str = None",
                    "json_file: str = None"
                ],
                "doc": "Analyze sentiments in the given text\n\n:param text: A UTF-8 text string\n:param language: if input language is known\n:param json_file: filepath to write results into\n:return: analysis in json format",
                "shortdoc": "Analyze sentiments in the given text",
                "tags": [],
                "matched": true
            },
            {
                "name": "Set Robocloud Vault",
                "args": [
                    "vault_name"
                ],
                "doc": "Set Robocloud Vault name\n\n:param vault_name: Robocloud Vault name",
                "shortdoc": "Set Robocloud Vault name",
                "tags": [],
                "matched": true
            },
            {
                "name": "Text To Speech",
                "args": [
                    "text: str",
                    "language: str = en-US",
                    "name: str = en-US-AriaRUS",
                    "gender: str = FEMALE",
                    "encoding: str = MP3",
                    "neural_voice_style: typing.Any = None",
                    "target_file: str = synthesized.mp3"
                ],
                "doc": "Synthesize speech synchronously\n\n:param text: input text to synthesize\n:param language: voice language, defaults to \"en-US\"\n:param name: voice name, defaults to \"en-US-AriaRUS\"\n:param gender: voice gender, defaults to \"FEMALE\"\n:param encoding: result encoding type, defaults to \"MP3\"\n:param neural_voice_style: if given then neural voice is used,\n    example style. \"cheerful\"\n:param target_file: save synthesized output to file,\n    defaults to \"synthesized.mp3\"\n:return: synthesized output in bytes\n\nNeural voices are only supported for Speech resources created in\nEast US, South East Asia, and West Europe regions.",
                "shortdoc": "Synthesize speech synchronously",
                "tags": [],
                "matched": true
            },
            {
                "name": "Vision Analyze",
                "args": [
                    "image_file: str = None",
                    "image_url: str = None",
                    "visual_features: str = None",
                    "json_file: str = None"
                ],
                "doc": "Identify features in the image\n\n:param image_file: filepath of image file\n:param image_url: URI to image, if given will be used instead of `image_file`\n:param visual_features: comma separated list of features,\n    for example. \"Categories,Description,Color\"\n:param json_file: filepath to write results into\n:return: analysis in json format\n\nSee `Computer Vision API`_ for valid feature names and their explanations:\n\n- Adult\n- Brands\n- Categories\n- Color\n- Description\n- Faces\n- ImageType\n- Objects\n- Tags\n\n.. _Computer Vision API: https://westcentralus.dev.cognitive.microsoft.com/docs/services/computer-vision-v3-ga",
                "shortdoc": "Identify features in the image",
                "tags": [],
                "matched": true
            },
            {
                "name": "Vision Describe",
                "args": [
                    "image_file: str = None",
                    "image_url: str = None",
                    "json_file: str = None"
                ],
                "doc": "Describe image with tags and captions\n\n:param image_file: filepath of image file\n:param image_url: URI to image, if given will be used instead of `image_file`\n:param json_file: filepath to write results into\n:return: analysis in json format",
                "shortdoc": "Describe image with tags and captions",
                "tags": [],
                "matched": true
            },
            {
                "name": "Vision Detect Objects",
                "args": [
                    "image_file: str = None",
                    "image_url: str = None",
                    "json_file: str = None"
                ],
                "doc": "Detect objects in the image\n\n:param image_file: filepath of image file\n:param image_url: URI to image, if given will be used instead of `image_file`\n:param json_file: filepath to write results into\n:return: analysis in json format",
                "shortdoc": "Detect objects in the image",
                "tags": [],
                "matched": true
            },
            {
                "name": "Vision Ocr",
                "args": [
                    "image_file: str = None",
                    "image_url: str = None",
                    "json_file: str = None"
                ],
                "doc": "Optical Character Recognition (OCR) detects text in an image\n\n:param image_file: filepath of image file\n:param image_url: URI to image, if given will be used instead of `image_file`\n:param json_file: filepath to write results into\n:return: analysis in json format",
                "shortdoc": "Optical Character Recognition (OCR) detects text in an image",
                "tags": [],
                "matched": true
            }
        ],
        "all_tags": [],
        "contains_tags": false
    },
    "RPA.Cloud.Google": {
        "name": "RPA.Cloud.Google",
        "doc": "`Google` is a library for operating with Google API endpoints.\n\nUsage requires the following steps:\n\n- Create a GCP project\n- Create a service account key file (JSON) and save it to a place the robot\n  can use it\n- Enable APIs\n- Install rpaframework[google]\n\n**Google authentication**\n\nAuthentication for Google is set with `service credentials JSON file` which can be given to the library\nin three different ways.\n\n- Method 1 as environment variables, ``GOOGLE_APPLICATION_CREDENTIALS`` with path to JSON file.\n- Method 2 as keyword parameter to ``Init Storage Client`` for example.\n- Method 3 as Robocloud vault secret. The vault name and secret key name needs to be given in library init\n  or with keyword ``Set Robocloud Vault``. Secret value should contain JSON file contents.\n\nMethod 1. service credentials using environment variable\n\n.. code-block:: robotframework\n\n    *** Settings ***\n    Library   RPA.Cloud.Google\n\n    *** Tasks ***\n    Init Google services\n        # NO parameters for Vision Client, expecting to get JSON\n        # with GOOGLE_APPLICATION_CREDENTIALS environment variable\n        Init Vision Client\n\nMethod 2. service credentials with keyword parameter\n\n.. code-block:: robotframework\n\n    *** Settings ***\n    Library   RPA.Cloud.Google\n\n    *** Tasks ***\n    Init Google services\n        Init Speech To Text Client  /path/to/service_credentials.json\n\nMethod 3. setting Robocloud Vault in the library init\n\n.. code-block:: robotframework\n\n    *** Settings ***\n    Library   RPA.Cloud.Google\n    ...       robocloud_vault_name=googlecloud\n    ...       robocloud_vault_secret_key=servicecreds\n\n    *** Tasks ***\n    Init Google services\n        Init Storage Client   use_robocloud_vault=${TRUE}\n\nMethod 3. setting Robocloud Vault with keyword\n\n.. code-block:: robotframework\n\n    *** Settings ***\n    Library   RPA.Cloud.Google\n\n    *** Tasks ***\n    Init Google services\n        Set Robocloud Vault   vault_name=googlecloud  vault_secret_key=servicecreds\n        Init Storage Client   use_robocloud_vault=${TRUE}\n\n**Requirements**\n\nDue to number of dependencies related to Google Cloud services this library has been set as\nan optional package for ``rpaframework``.\n\nThis can be installed by opting in to the `google` dependency:\n\n``pip install rpaframework[google]``\n\n**Examples**\n\n**Robot Framework**\n\n.. code-block:: robotframework\n\n    *** Settings ***\n    Library   RPA.Cloud.Google\n\n    *** Variables ***\n    ${SERVICE CREDENTIALS}    ${/}path${/}to${/}service_credentials.json\n    ${BUCKET_NAME}            testbucket12213123123\n\n    *** Tasks ***\n    Upload a file into a new storage bucket\n        [Setup]   Init Storage Client   ${SERVICE CREDENTIALS}\n        Create Bucket    ${BUCKET_NAME}\n        Upload File      ${BUCKET_NAME}   ${/}path${/}to${/}file.pdf  myfile.pdf\n        @{files}         List Files   ${BUCKET_NAME}\n        FOR   ${file}  IN   @{files}\n            Log  ${file}\n        END\n\n**Python**\n\n.. code-block:: python\n\n    from RPA.Cloud.Google import Google\n\n    library = Google\n    service_credentials = '/path/to/service_credentials.json'\n\n    library.init_vision_client(service_credentials)\n    library.init_text_to_speech(service_credentials)\n\n    response = library.detect_text('imagefile.png', 'result.json')\n    library.synthesize_speech('I want this said aloud', target_file='said.mp3')",
        "version": "",
        "named_args": true,
        "scope": "GLOBAL",
        "generated": "2020-12-01 14:53:06",
        "inits": [
            {
                "name": "Init",
                "args": [
                    "robocloud_vault_name: str = None",
                    "robocloud_vault_secret_key: str = None"
                ],
                "doc": "Initialize self.  See help(type(self)) for accurate signature.",
                "shortdoc": "Initialize self.  See help(type(self)) for accurate signature.",
                "tags": [],
                "matched": true
            }
        ],
        "keywords": [
            {
                "name": "Analyze Sentiment",
                "args": [
                    "text_file: str",
                    "file_type: str = text",
                    "json_file: str = None",
                    "lang=None"
                ],
                "doc": "Analyze sentiment in a text file\n\n:param text_file: source text file\n:param json_file: json target to save result, defaults to None\n:param lang: language code of the source, defaults to None\n:return: analysis response",
                "shortdoc": "Analyze sentiment in a text file",
                "tags": [],
                "matched": true
            },
            {
                "name": "Annotate Image",
                "args": [
                    "image_uri: str",
                    "json_file: str = None"
                ],
                "doc": "Annotate image\n\n:param image_file: source image file\n:param json_file: json target to save result, defaults to None\n:return: detection response",
                "shortdoc": "Annotate image",
                "tags": [],
                "matched": true
            },
            {
                "name": "Annotate Video",
                "args": [
                    "video_uri: str = None",
                    "video_file: str = None",
                    "json_file: str = None",
                    "features: list = None"
                ],
                "doc": "Annotate video\n\nPossible values for features:\n- FEATURE_UNSPECIFIED, Unspecified.\n- LABEL_DETECTION, Label detection. Detect objects, such as dog or flower.\n- SHOT_CHANGE_DETECTION, Shot change detection.\n- EXPLICIT_CONTENT_DETECTION, Explicit content detection.\n- SPEECH_TRANSCRIPTION, Speech transcription.\n- TEXT_DETECTION, OCR text detection and tracking.\n- OBJECT_TRACKING, Object detection and tracking.\n- LOGO_RECOGNITION, Logo detection, tracking, and recognition.\n\nIf `video_uri` is given then that is used even if `video_file` is None.\n\n:param video_uri: Google Cloud Storage URI\n:param video_file: filepath to video\n:param json_file: json target to save result, defaults to None\n:param features: list of annotation features to detect,\n    defaults to [\"LABEL_DETECTION\", \"SHOT_CHANGE_DETECTION\"]\n:return: annotate result",
                "shortdoc": "Annotate video",
                "tags": [],
                "matched": true
            },
            {
                "name": "Classify Text",
                "args": [
                    "text_file",
                    "json_file",
                    "lang=None"
                ],
                "doc": "Classify text\n\n:param text_file: source text file\n:param json_file: json target to save result, defaults to None\n:param lang: language code of the source, defaults to None\n:return: classify response",
                "shortdoc": "Classify text",
                "tags": [],
                "matched": true
            },
            {
                "name": "Clear Values",
                "args": [
                    "sheet_id: str",
                    "sheet_range: str"
                ],
                "doc": "Clear cell values for range of cells within a sheet\n\n:param sheet_id: target sheet\n:param sheet_range: target sheet range",
                "shortdoc": "Clear cell values for range of cells within a sheet",
                "tags": [],
                "matched": true
            },
            {
                "name": "Create Bucket",
                "args": [
                    "bucket_name: str"
                ],
                "doc": "Create Google Cloud Storage bucket\n\n:param bucket_name: name as string\n:return: bucket",
                "shortdoc": "Create Google Cloud Storage bucket",
                "tags": [],
                "matched": true
            },
            {
                "name": "Create Sheet",
                "args": [
                    "title: str"
                ],
                "doc": "Create empty sheet with a title\n\n:param title: name as string\n:return: created `sheet_id`",
                "shortdoc": "Create empty sheet with a title",
                "tags": [],
                "matched": true
            },
            {
                "name": "Delete Bucket",
                "args": [
                    "bucket_name: str"
                ],
                "doc": "Delete Google Cloud Storage bucket\n\nBucket needs to be empty before it can be deleted.\n\n:param bucket_name: name as string",
                "shortdoc": "Delete Google Cloud Storage bucket",
                "tags": [],
                "matched": true
            },
            {
                "name": "Delete Files",
                "args": [
                    "bucket_name: str",
                    "files: typing.Any"
                ],
                "doc": "Delete files in the bucket\n\nFiles need to be object name in the bucket.\n\n:param bucket_name: name as string\n:param files: single file, list of files or\n    comma separated list of files\n:return: list of files which could not be deleted,\n    or True if all were deleted",
                "shortdoc": "Delete files in the bucket",
                "tags": [],
                "matched": true
            },
            {
                "name": "Detect Document",
                "args": [
                    "image_file: str",
                    "json_file: str = None"
                ],
                "doc": "Detect document\n\n:param image_file: source image file\n:param json_file: json target to save result, defaults to None\n:return: detection response",
                "shortdoc": "Detect document",
                "tags": [],
                "matched": true
            },
            {
                "name": "Detect Labels",
                "args": [
                    "image_file: str",
                    "json_file: str = None"
                ],
                "doc": "Detect labels in the image\n\n:param image_file: source image file\n:param json_file: json target to save result, defaults to None\n:return: detection response",
                "shortdoc": "Detect labels in the image",
                "tags": [],
                "matched": true
            },
            {
                "name": "Detect Text",
                "args": [
                    "image_file: str",
                    "json_file: str = None"
                ],
                "doc": "Detect text in the image\n\n:param image_file: source image file\n:param json_file: json target to save result, defaults to None\n:return: detection response",
                "shortdoc": "Detect text in the image",
                "tags": [],
                "matched": true
            },
            {
                "name": "Download Files",
                "args": [
                    "bucket_name: str",
                    "files: typing.Any"
                ],
                "doc": "Download files from a bucket\n\nExample `files`:\nfiles = {\"mytestimg\": \"image1.png\", \"mydoc\": \"google.pdf\n\n:param bucket_name: name as string\n:param files: list of object names or dictionary of\n    object names and target files\n:return: list of files which could not be downloaded, or\n    True if all were downloaded",
                "shortdoc": "Download files from a bucket",
                "tags": [],
                "matched": true
            },
            {
                "name": "Face Detection",
                "args": [
                    "image_uri: str",
                    "json_file: str = None"
                ],
                "doc": "Detect faces\n\n:param image_uri: Google Cloud Storage URI\n:param json_file: json target to save result, defaults to None\n:return: detection response",
                "shortdoc": "Detect faces",
                "tags": [],
                "matched": true
            },
            {
                "name": "Get Bucket",
                "args": [
                    "bucket_name: str"
                ],
                "doc": "Get Google Cloud Storage bucket\n\n:param bucket_name: name as string\n:return: bucket",
                "shortdoc": "Get Google Cloud Storage bucket",
                "tags": [],
                "matched": true
            },
            {
                "name": "Get Values",
                "args": [
                    "sheet_id: str",
                    "sheet_range: str",
                    "value_render_option: str = UNFORMATTED_VALUE",
                    "datetime_render_option: str = FORMATTED_STRING"
                ],
                "doc": "Get values from the range in the sheet\n\n:param sheet_id: target sheet\n:param sheet_range: target sheet range\n:param value_render_option: how values should be represented\n    in the output defaults to \"UNFORMATTED_VALUE\"\n:param datetime_render_option: ow dates, times, and durations should\n    be represented in the outpu, defaults to \"FORMATTED_STRING\"",
                "shortdoc": "Get values from the range in the sheet",
                "tags": [],
                "matched": true
            },
            {
                "name": "Init Natural Language Client",
                "args": [
                    "service_credentials_file: str = None",
                    "use_robocloud_vault: bool = False"
                ],
                "doc": "Initialize Google Cloud Natural Language client\n\n:param service_credentials_file: filepath to credentials JSON\n:param use_robocloud_vault: use json stored into `Robocloud Vault`",
                "shortdoc": "Initialize Google Cloud Natural Language client",
                "tags": [],
                "matched": true
            },
            {
                "name": "Init Sheets Client",
                "args": [
                    "service_credentials_file: str = None",
                    "use_robocloud_vault: bool = False"
                ],
                "doc": "Initialize Google Sheets client\n\n:param service_credentials_file: filepath to credentials JSON\n:param use_robocloud_vault: use json stored into `Robocloud Vault`",
                "shortdoc": "Initialize Google Sheets client",
                "tags": [],
                "matched": true
            },
            {
                "name": "Init Speech To Text Client",
                "args": [
                    "service_credentials_file: str = None",
                    "use_robocloud_vault: bool = False"
                ],
                "doc": "Initialize Google Cloud Speech to Text client\n\n:param service_credentials_file: filepath to credentials JSON\n:param use_robocloud_vault: use json stored into `Robocloud Vault`",
                "shortdoc": "Initialize Google Cloud Speech to Text client",
                "tags": [],
                "matched": true
            },
            {
                "name": "Init Storage Client",
                "args": [
                    "service_credentials_file: str = None",
                    "use_robocloud_vault: bool = False"
                ],
                "doc": "Initialize Google Cloud Storage client\n\n:param service_credentials_file: filepath to credentials JSON\n:param use_robocloud_vault: use json stored into `Robocloud Vault`",
                "shortdoc": "Initialize Google Cloud Storage client",
                "tags": [],
                "matched": true
            },
            {
                "name": "Init Text To Speech Client",
                "args": [
                    "service_credentials_file: str = None",
                    "use_robocloud_vault: bool = False"
                ],
                "doc": "Initialize Google Cloud Text to Speech client\n\n:param service_credentials_file: filepath to credentials JSON\n:param use_robocloud_vault: use json stored into `Robocloud Vault`",
                "shortdoc": "Initialize Google Cloud Text to Speech client",
                "tags": [],
                "matched": true
            },
            {
                "name": "Init Translation Client",
                "args": [
                    "service_credentials_file: str = None",
                    "project_identifier: str = None",
                    "use_robocloud_vault: bool = False"
                ],
                "doc": "Initialize Google Cloud Translation client\n\n:param service_credentials_file: filepath to credentials JSON\n:param project_identifier: identifier for Translation project\n:param use_robocloud_vault: use json stored into `Robocloud Vault`",
                "shortdoc": "Initialize Google Cloud Translation client",
                "tags": [],
                "matched": true
            },
            {
                "name": "Init Video Intelligence Client",
                "args": [
                    "service_credentials_file: str = None",
                    "use_robocloud_vault: bool = False"
                ],
                "doc": "Initialize Google Cloud Video Intelligence client\n\n:param service_credentials_file: filepath to credentials JSON\n:param use_robocloud_vault: use json stored into `Robocloud Vault`",
                "shortdoc": "Initialize Google Cloud Video Intelligence client",
                "tags": [],
                "matched": true
            },
            {
                "name": "Init Vision Client",
                "args": [
                    "service_credentials_file: str = None",
                    "use_robocloud_vault: bool = False"
                ],
                "doc": "Initialize Google Cloud Vision client\n\n:param service_credentials_file: filepath to credentials JSON\n:param use_robocloud_vault: use json stored into `Robocloud Vault`",
                "shortdoc": "Initialize Google Cloud Vision client",
                "tags": [],
                "matched": true
            },
            {
                "name": "Insert Values",
                "args": [
                    "sheet_id: str",
                    "sheet_range: str",
                    "values: list",
                    "major_dimension: str = COLUMNS",
                    "value_input_option: str = USER_ENTERED"
                ],
                "doc": "Insert values into sheet cells\n\n:param sheet_id: target sheet\n:param sheet_range: target sheet range\n:param values: list of values to insert into sheet\n:param major_dimension: major dimension of the values, default `COLUMNS`\n:param value_input_option: controls whether input strings are parsed or not,\n    default `USER_ENTERED`",
                "shortdoc": "Insert values into sheet cells",
                "tags": [],
                "matched": true
            },
            {
                "name": "List Buckets",
                "args": [],
                "doc": "List Google Cloud Storage buckets\n\n:return: list of buckets",
                "shortdoc": "List Google Cloud Storage buckets",
                "tags": [],
                "matched": true
            },
            {
                "name": "List Files",
                "args": [
                    "bucket_name: str"
                ],
                "doc": "List files in the bucket\n\n:param bucket_name: name as string\n:return: list of object names in the bucket",
                "shortdoc": "List files in the bucket",
                "tags": [],
                "matched": true
            },
            {
                "name": "List Supported Voices",
                "args": [
                    "language_code: str = None"
                ],
                "doc": "List supported voices for the speech\n\n:param language_code: voice languages to list, defaults to None (all)\n:return: list of supported voices",
                "shortdoc": "List supported voices for the speech",
                "tags": [],
                "matched": true
            },
            {
                "name": "Recognize",
                "args": [
                    "audio_file_uri",
                    "encoding: str = FLAC",
                    "language_code: str = en_US",
                    "audio_channel_count=2"
                ],
                "doc": "Recognize text in the audio file\n\n:param audio_file_uri: Google Cloud Storage URI\n:return: recognized texts",
                "shortdoc": "Recognize text in the audio file",
                "tags": [],
                "matched": true
            },
            {
                "name": "Set Robocloud Vault",
                "args": [
                    "vault_name",
                    "vault_secret_key"
                ],
                "doc": "Set Robocloud Vault name and secret key name\n\n:param vault_name: Robocloud Vault name\n:param vault_secret_key: Rococloud Vault secret key name",
                "shortdoc": "Set Robocloud Vault name and secret key name",
                "tags": [],
                "matched": true
            },
            {
                "name": "Synthesize Speech",
                "args": [
                    "text",
                    "language=en-US",
                    "name=en-US-Standard-B",
                    "gender=MALE",
                    "encoding=MP3",
                    "target_file=synthesized.mp3"
                ],
                "doc": "Synthesize speech synchronously\n\n:param text: input text to synthesize\n:param language: voice language, defaults to \"en-US\"\n:param name: voice name, defaults to \"en-US-Standard-B\"\n:param gender: voice gender, defaults to \"MALE\"\n:param encoding: result encoding type, defaults to \"MP3\"\n:param target_file: save synthesized output to file,\n    defaults to \"synthesized.mp3\"\n:return: synthesized output in bytes",
                "shortdoc": "Synthesize speech synchronously",
                "tags": [],
                "matched": true
            },
            {
                "name": "Translate",
                "args": [
                    "text: typing.Any",
                    "source_language: str = None",
                    "target_language: str = None"
                ],
                "doc": "Translate text\n\n:param text: text to translate\n:param source_language: language code, defaults to None\n:param target_language: language code, defaults to None\n:return: translated text",
                "shortdoc": "Translate text",
                "tags": [],
                "matched": true
            },
            {
                "name": "Upload File",
                "args": [
                    "bucket_name: str",
                    "filename: str",
                    "target_name: str"
                ],
                "doc": "Upload a file into a bucket\n\n:param bucket_name: name as string\n:param filename: filepath to upload file\n:param target_name: target object name",
                "shortdoc": "Upload a file into a bucket",
                "tags": [],
                "matched": true
            },
            {
                "name": "Upload Files",
                "args": [
                    "bucket_name: str",
                    "files: dict"
                ],
                "doc": "Upload files into a bucket\n\nExample `files`:\nfiles = {\"mytestimg\": \"image1.png\", \"mydoc\": \"google.pdf\"}\n\n:param bucket_name: name as string\n:param files: dictionary of object names and filepaths",
                "shortdoc": "Upload files into a bucket",
                "tags": [],
                "matched": true
            }
        ],
        "all_tags": [],
        "contains_tags": false
    },
    "RPA.Database": {
        "name": "RPA.Database",
        "doc": "`Database` is a library for handling different database operations.\n\nAll database operations are supported. Keywords `Query` and `Get Rows`\nreturn values by default in `RPA.Table` format.\n\nLibrary is compatible with any Database API Specification 2.0 module.\n\nReferences:\n\n- Database API Specification 2.0 - http://www.python.org/dev/peps/pep-0249/\n- Lists of DB API 2.0 - http://wiki.python.org/moin/DatabaseInterfaces\n- Python Database Programming - http://wiki.python.org/moin/DatabaseProgramming/\n\n**Examples**\n\n**Robot Framework**\n\n.. code-block:: robotframework\n\n    *** Settings ***\n    Library         RPA.Database\n\n    *** Tasks ***\n    Get Orders From Database\n        Connect To Database  pymysql  tester  user  password  127.0.0.1\n        @{orders}            Query    Select * FROM incoming_orders\n        FOR   ${order}  IN  @{orders}\n            Handle Order  ${order}\n        END\n\n**Python**\n\n.. code-block:: python\n\n    from RPA.Database import Database\n    from RPA.Robocloud.Secrets import FileSecrets\n\n    filesecrets = FileSecrets(\"secrets.json\")\n    secrets = filesecrets.get_secret(\"databasesecrets\")\n\n    db = Database()\n    db.connect_to_database('pymysql',\n                        secrets[\"DATABASE\"],\n                        secrets[\"USERNAME\"],\n                        secrets[\"PASSWORD\"],\n                        '127.0.0.1'\n                        )\n    orders = db.query(\"SELECT * FROM incoming_orders\")\n    for order in orders:\n        print(order)",
        "version": "",
        "named_args": true,
        "scope": "GLOBAL",
        "generated": "2020-12-01 14:53:06",
        "inits": [],
        "keywords": [
            {
                "name": "Call Stored Procedure",
                "args": [
                    "name",
                    "params=None",
                    "sanstran=False"
                ],
                "doc": "Call stored procedure with name and params.\n\n:param name: procedure name\n:param params: parameters for the procedure as a list, defaults to None\n:param sanstran: run command without an explicit transaction commit or rollback,\n defaults to False\n\nExample:\n\n.. code-block:: robotframework\n\n    @{params}     Create List   FirstParam   SecondParam   ThirdParam\n    @{results}    Call Stored Procedure   mystpr  ${params}",
                "shortdoc": "Call stored procedure with name and params.",
                "tags": [],
                "matched": true
            },
            {
                "name": "Connect To Database",
                "args": [
                    "module_name=None",
                    "database=None",
                    "username=None",
                    "password=None",
                    "host=None",
                    "port=None",
                    "charset=None",
                    "config_file=db.cfg"
                ],
                "doc": "Connect to database using DB API 2.0 module.\n\n:param module_name: database module to use\n:param database: name of the database\n:param username: of the user accessing the database\n:param password: of the user accessing the database\n:param host: SQL server address\n:param port: SQL server port\n:param charset: for example, \"utf-8\", defaults to None\n:param config_file: location of configuration file, defaults to \"db.cfg\"\n\nExample:\n\n.. code-block:: robotframework\n\n    Connect To Database  pymysql  database  username  password  host  port\n    Connect To Database  ${CURDIR}${/}resources${/}dbconfig.cfg",
                "shortdoc": "Connect to database using DB API 2.0 module.",
                "tags": [],
                "matched": true
            },
            {
                "name": "Description",
                "args": [
                    "table"
                ],
                "doc": "Get description of the SQL table\n\n:param table: name of the SQL table\n\nExample:\n\n.. code-block:: robotframework\n\n    Connect To Database    pymysql  mydb  user  pass  127.0.0.1\n    ${db_description}      Description  mytable",
                "shortdoc": "Get description of the SQL table",
                "tags": [],
                "matched": true
            },
            {
                "name": "Disconnect From Database",
                "args": [],
                "doc": "Close connection to SQL database\n\nExample:\n\n.. code-block:: robotframework\n\n    Connect To Database    pymysql  mydb  user  pass  127.0.0.1\n    ${result}              Query   Select firstname, lastname FROM table\n    Disconnect From Database",
                "shortdoc": "Close connection to SQL database",
                "tags": [],
                "matched": true
            },
            {
                "name": "Execute Sql Script",
                "args": [
                    "filename",
                    "sanstran=False"
                ],
                "doc": "Execute content of SQL script as SQL commands.\n\n:param filename: filepath to SQL script to execute\n:param sanstran: run command without an explicit transaction commit or rollback,\n defaults to False\n\nExample:\n\n.. code-block:: robotframework\n\n    Execute SQL Script   script.sql",
                "shortdoc": "Execute content of SQL script as SQL commands.",
                "tags": [],
                "matched": true
            },
            {
                "name": "Get Number Of Rows",
                "args": [
                    "table",
                    "conditions=None"
                ],
                "doc": "Get number of rows in a table. Conditions can be given\nas arguments for WHERE clause.\n\n:param table: name of the SQL table\n:param conditions: restrictions for selections, defaults to None\n\nExample:\n\n.. code-block:: robotframework\n\n    ${count}   Get Number Of Rows  tablename\n    ${count}   Get Number Of Rows  tablename  column1=5 and column2='x'",
                "shortdoc": "Get number of rows in a table. Conditions can be given as arguments for WHERE clause.",
                "tags": [],
                "matched": true
            },
            {
                "name": "Get Rows",
                "args": [
                    "table",
                    "columns=None",
                    "conditions=None",
                    "as_table=True"
                ],
                "doc": "Get rows from table. Columns and conditions can be\nset to filter result.\n\n:param table: name of the SQL table\n:param columns: name of columns to return, defaults to `None`\n means that all columns are returned\n:param conditions: limiting result by WHERE clause, defaults to `None`\n:param as_table: if result should be instance of ``Table``, defaults to `True`\n `False` means that return type would be `list`\n\nExample:\n\n.. code-block:: robotframework\n\n    @{res}   Get Rows  tablename  arvo\n    @{res}   Get Rows  tablename  arvo  columns=id,name\n    @{res}   Get Rows  tablename  columns=id  conditions=column1='newvalue'\n    @{res}   Get Rows  tablename  conditions=column2='updatedvalue'",
                "shortdoc": "Get rows from table. Columns and conditions can be set to filter result.",
                "tags": [],
                "matched": true
            },
            {
                "name": "Query",
                "args": [
                    "statement",
                    "assertion=None",
                    "sanstran=False",
                    "as_table=True"
                ],
                "doc": "Make a SQL query.\n\n:param statement: SQL statement to execute\n:param assertion: assert on query result, row_count or columns.\n Works only for SELECT statements Defaults to None.\n:param sanstran: run command without an explicit transaction commit or rollback,\n defaults to False\n:param as_table: if result should be instance of ``Table``, defaults to `True`\n `False` means that return type would be `list`\n\nExample:\n\n.. code-block:: robotframework\n\n    @{res}   Query   Select firstname, lastname FROM table\n    FOR  ${row}  IN  @{RES}\n        Log   ${row}\n    END\n    @{res}   Query  Select * FROM table  row_count > ${EXPECTED}\n    @{res}   Query  Select * FROM table  'arvo' in columns\n    @{res}   Query  Select * FROM table  columns == ['id', 'arvo']",
                "shortdoc": "Make a SQL query.",
                "tags": [],
                "matched": true
            },
            {
                "name": "Set Auto Commit",
                "args": [
                    "autocommit=True"
                ],
                "doc": "Set database auto commit mode.\n\n:param autocommit: boolean value for auto commit, defaults to True\n\nExample:\n\n.. code-block:: robotframework\n\n    Set Auto Commit             # auto commit is set on\n    Set Auto Commit   False     # auto commit is turned off",
                "shortdoc": "Set database auto commit mode.",
                "tags": [],
                "matched": true
            }
        ],
        "all_tags": [],
        "contains_tags": false
    },
    "RPA.Desktop": {
        "name": "RPA.Desktop",
        "doc": "`Desktop` is a cross-platform library for navigating and interacting with\ndesktop environments. It can be used to automate applications through\nthe same interfaces that are available to human users.\n\nThe library includes the following features:\n\n- Mouse and keyboard input emulation\n- Starting and stopping applications\n- Finding elements through image template matching\n- Taking screenshots\n- Clipboard management\n\n**Note:** Windows element selectors are not currently supported,\n    and require the use of ``RPA.Desktop.Windows``\n\n**Locating elements**\n\nTo automate actions on the desktop, a robot needs to interact with various\ngraphical elements such as buttons or input fields. The positions of these\nelements can be found using a feature called `locators`.\n\nA locator describes the properties or features of an element. This information\ncan be later used to locate similar elements even when window positions or\nstates change.\n\nThe currently supported locator types are:\n\n=========== =================== ===========\nName        Arguments           Description\n=========== =================== ===========\nalias       name (str)          A named locator, the default.\nimage       path (str)          Image of an element that is matched to current screen content\ncoordinates x (int), y (int)    Pixel coordinates as absolute position\noffset      x (int), y (int)    Pixel coordinates relative to current mouse position\n=========== =================== ===========\n\nA locator is defined by its type and arguments, divided by a colon.\nSome example usages are shown below. Note that the prefix for alias can\nbe omitted as its the default type.\n\n.. code-block:: robotframework\n\n    Click    alias:SpareBin.Login\n    Click    SpareBin.Login\n\n    Move mouse    image:%{ROBOT_ROOT}/logo.png\n    Move mouse    offset:200,0\n    Click\n\n**Named locators**\n\nThe library supports storing locators in a database, which contains\nall of the required fields and various bits of metadata. This enables\nhaving one source of truth, which can be updated if a website's or applications's\nUI changes. Robot Framework scripts can then only contain a reference\nto a stored locator by name.\n\nThe main way to create named locators is with `Robocorp Lab`_.\n\n.. _Robocorp Lab: https://robocorp.com/docs/product-manuals/robocorp-lab/robocorp-lab-overview\n\n**Keyboard and mouse**\n\nKeyboard keywords can emulate typing text, but also pressing various function keys.\nThe name of a key is case-insensitive and spaces will be converted to underscores,\ni.e. the key ``Page Down`` and ``page_down`` are equivalent.\n\nThe following function keys are supported:\n\n=============== ===========\nKey             Description\n=============== ===========\nshift           A generic Shift key. This is a modifier.\nshift_l         The left Shift key. This is a modifier.\nshift_r         The right Shift key. This is a modifier.\nctrl            A generic Ctrl key. This is a modifier.\nctrl_l          he left Ctrl key. This is a modifier.\nctrl_r          The right Ctrl key. This is a modifier.\nalt             A generic Alt key. This is a modifier.\nalt_l           The left Alt key. This is a modifier.\nalt_r           The right Alt key. This is a modifier.\nalt_gr          The AltGr key. This is a modifier.\ncmd             A generic command button (Windows / Command / Super key). This may be a modifier.\ncmd_l           The left command button (Windows / Command / Super key). This may be a modifier.\ncmd_r           The right command button (Windows / Command / Super key). This may be a modifier.\nup              An up arrow key.\ndown            A down arrow key.\nleft            A left arrow key.\nright           A right arrow key.\nenter           The Enter or Return key.\nspace           The Space key.\ntab             The Tab key.\nbackspace       The Backspace key.\ndelete          The Delete key.\nesc             The Esc key.\nhome            The Home key.\nend             The End key.\npage_down       The Page Down key.\npage_up         The Page Up key.\ncaps_lock       The Caps Lock key.\nf1 to f20       The function keys.\ninsert          The Insert key. This may be undefined for some platforms.\nmenu            The Menu key. This may be undefined for some platforms.\nnum_lock        The Num Lock key. This may be undefined for some platforms.\npause           The Pause / Break key. This may be undefined for some platforms.\nprint_screen    The Print Screen key. This may be undefined for some platforms.\nscroll_lock     The Scroll Lock key. This may be undefined for some platforms.\n=============== ===========\n\nWhen controlling the mouse, there are different types of actions that can be\ndone. Same formatting rules as function keys apply. They are as follows:\n\n============ ===========\nAction       Description\n============ ===========\nclick        Click with left mouse button\nleft_click   Click with left mouse button\ndouble_click Double click with left mouse button\ntriple_click Triple click with left mouse button\nright_click  Click with right mouse button\n============ ===========\n\nThe supported mouse button types are ``left``, ``right``, and ``middle``.\n\n**Examples***\n\nThe library can open applications and interact with them through\nkeyboard and mouse events.\n\n.. code-block:: robotframework\n\n    *** Settings ***\n    Library    RPA.Desktop\n\n    *** Keywords ***\n    Write entry in accounting\n        [Arguments]    ${entry}\n        Open application    erp_client.exe\n        Click         image:%{ROBOT_ROOT}/images/create.png\n        Type text     ${entry}\n        Press keys    ctrl    s\n        Press keys    enter\n        [Teardown]    Close all applications\n\nTargeting can be currently done using coordinates (absolute or relative),\nbut using template matching is preferred.\n\n.. code-block:: robotframework\n\n    *** Settings ***\n    Library    RPA.Desktop\n\n    *** Keywords ***\n    Write to field\n        [Arguments]    ${text}\n        Move mouse   image:input_label.png\n        Move mouse   offset:200,0\n        Click\n        Type text    ${text}\n        Press keys   enter",
        "version": "",
        "named_args": true,
        "scope": "GLOBAL",
        "generated": "2020-12-01 14:53:06",
        "inits": [],
        "keywords": [
            {
                "name": "Clear Clipboard",
                "args": [],
                "doc": "Clear the system clipboard.",
                "shortdoc": "Clear the system clipboard.",
                "tags": [],
                "matched": true
            },
            {
                "name": "Click",
                "args": [
                    "locator: str = None",
                    "action: Action { click | left_click | double_click | ... } = Action.click"
                ],
                "doc": "Click at the element indicated by locator.\n\n:param locator: Locator for click position\n:param action:  Click action, e.g. right click\n\nExample:\n\n.. code-block:: robotframework\n\n    Click\n    Click    LoginForm.Button\n    Click    coordinates:500,200    triple click",
                "shortdoc": "Click at the element indicated by locator.",
                "tags": [],
                "matched": true
            },
            {
                "name": "Click With Offset",
                "args": [
                    "locator: str = None",
                    "x: int = 0",
                    "y: int = 0",
                    "action: Action { click | left_click | double_click | ... } = Action.click"
                ],
                "doc": "Click at a given pixel offset from the given locator.\n\n:param locator: Locator for click start position\n:param x:       Click horizontal offset in pixels\n:param y:       Click vertical offset in pixels\n:param action:  Click action, e.g. right click\n\nExample:\n\n.. code-block:: robotframework\n\n    Click with offset    Robocorp.Logo    y=400",
                "shortdoc": "Click at a given pixel offset from the given locator.",
                "tags": [],
                "matched": true
            },
            {
                "name": "Close All Applications",
                "args": [],
                "doc": "Close all opened applications.\n\nExample:\n\n.. code-block:: robotframework\n\n    Open file    order1.docx\n    Open file    order2.docx\n    Open file    order3.docx\n    # Do something with Word\n    Close all applications",
                "shortdoc": "Close all opened applications.",
                "tags": [],
                "matched": true
            },
            {
                "name": "Close Application",
                "args": [
                    "app: Application"
                ],
                "doc": "Close given application. Needs to be started\nwith this library.\n\n:param app: App instance\n\nExample:\n\n.. code-block:: robotframework\n\n    ${word}=    Open file    template.docx\n    # Do something with Word\n    Close application    ${word}",
                "shortdoc": "Close given application. Needs to be started with this library.",
                "tags": [],
                "matched": true
            },
            {
                "name": "Copy To Clipboard",
                "args": [
                    "locator"
                ],
                "doc": "Read value to system clipboard from given input element.\n\n:param locator: Locator for element\n:returns:       Current clipboard value\n\nExample:\n\n.. code-block:: robotframework\n\n    ${value}=    Copy to clipboard    ResultPage.Counter\n    Log    Copied text: ${value}",
                "shortdoc": "Read value to system clipboard from given input element.",
                "tags": [],
                "matched": true
            },
            {
                "name": "Define Region",
                "args": [
                    "left: int",
                    "top: int",
                    "right: int",
                    "bottom: int"
                ],
                "doc": "Return a new ``Region`` with the given dimensions.\n\n:param left: left edge coordinate.\n:param top: top edge coordinate.\n:param right: right edge coordinate.\n:param bottom: bottom edge coordinate.",
                "shortdoc": "Return a new ``Region`` with the given dimensions.",
                "tags": [],
                "matched": true
            },
            {
                "name": "Drag And Drop",
                "args": [
                    "source: str",
                    "destination: str",
                    "start_delay: float = 2.0",
                    "end_delay: float = 0.5"
                ],
                "doc": "Drag mouse from source to destination while holding the left mouse button.\n\n:param source:      Locator for start position\n:param destination: Locator for destination position\n:param start_delay: Delay in seconds after pressing down mouse button\n:param end_delay:   Delay in seconds before releasing mouse button",
                "shortdoc": "Drag mouse from source to destination while holding the left mouse button.",
                "tags": [],
                "matched": true
            },
            {
                "name": "Find Element",
                "args": [
                    "locator: str"
                ],
                "doc": "Find an element defined by locator, and return its position.\nRaises ``ElementNotFound`` if` no matches were found, or\n``MultipleElementsFound`` if there were multiple matches.\n\n:param locator: Locator string\n\nExample:\n\n.. code-block:: robotframework\n\n    ${match}=    Find element    image:logo.png\n    Log    Found logo at ${match.x}, ${match.y}",
                "shortdoc": "Find an element defined by locator, and return its position. Raises ``ElementNotFound`` if` no matches were found, or ``MultipleElementsFound`` if there were multiple matches.",
                "tags": [],
                "matched": true
            },
            {
                "name": "Find Elements",
                "args": [
                    "locator: str"
                ],
                "doc": "Find all elements defined by locator, and return their positions.\n\n:param locator: Locator string\n\nExample:\n\n.. code-block:: robotframework\n\n    ${matches}=    Find elements    image:icon.png\n    FOR    ${match}  IN  @{matches}\n        Log    Found icon at ${match.x}, ${match.y}\n    END",
                "shortdoc": "Find all elements defined by locator, and return their positions.",
                "tags": [],
                "matched": true
            },
            {
                "name": "Get Clipboard Value",
                "args": [],
                "doc": "Read current value from system clipboard.\n\nExample:\n\n.. code-block:: robotframework\n\n    Copy to clipboard       coordinates:401,198\n    ${text}=    Get clipboard value\n    Log    We just copied '${text}'",
                "shortdoc": "Read current value from system clipboard.",
                "tags": [],
                "matched": true
            },
            {
                "name": "Get Display Dimensions",
                "args": [],
                "doc": "Returns the dimensions of the current virtual display,\nwhich is the combined size of all physical monitors.",
                "shortdoc": "Returns the dimensions of the current virtual display, which is the combined size of all physical monitors.",
                "tags": [],
                "matched": true
            },
            {
                "name": "Get Mouse Position",
                "args": [],
                "doc": "Get current mouse position in pixel coordinates.\n\nExample:\n\n.. code-block:: robotframework\n\n    ${position}=    Get mouse position\n    Log    Current mouse position is ${position.x}, ${position.y}",
                "shortdoc": "Get current mouse position in pixel coordinates.",
                "tags": [],
                "matched": true
            },
            {
                "name": "Highlight Elements",
                "args": [
                    "locator: str"
                ],
                "doc": "Draw an outline around all matching elements.",
                "shortdoc": "Draw an outline around all matching elements.",
                "tags": [],
                "matched": true
            },
            {
                "name": "Move Mouse",
                "args": [
                    "locator: str"
                ],
                "doc": "Move mouse to given coordinates.\n\n:param locator: Locator for mouse position\n\nExample:\n\n.. code-block:: robotframework\n\n    Move mouse    Robocorp.Logo\n    Move mouse    offset:0,400",
                "shortdoc": "Move mouse to given coordinates.",
                "tags": [],
                "matched": true
            },
            {
                "name": "Move Region",
                "args": [
                    "region: Region",
                    "left: int",
                    "top: int"
                ],
                "doc": "Return a new ``Region`` with an offset from the given region.\n\n:param region: the region to move.\n:param left: amount of pixels to move left/right.\n:param top: amount of pixels to move up/down.",
                "shortdoc": "Return a new ``Region`` with an offset from the given region.",
                "tags": [],
                "matched": true
            },
            {
                "name": "Open Application",
                "args": [
                    "name_or_path: str",
                    "*args"
                ],
                "doc": "Start a given application by name (if in PATH),\nor by path to executable.\n\n:param name_or_path: Name or path of application\n:param args:         Command line arguments for application\n:returns:            Application instance\n\nExample:\n\n.. code-block:: robotframework\n\n    Open application    notepad.exe\n    Open application    c:\\path\\to\\program.exe    --example-argument",
                "shortdoc": "Start a given application by name (if in PATH), or by path to executable.",
                "tags": [],
                "matched": true
            },
            {
                "name": "Open File",
                "args": [
                    "path: str"
                ],
                "doc": "Open a file with the default application.\n\n:param path: Path to file\n\nExample:\n\n.. code-block:: robotframework\n\n    Open file    orders.xlsx",
                "shortdoc": "Open a file with the default application.",
                "tags": [],
                "matched": true
            },
            {
                "name": "Paste From Clipboard",
                "args": [
                    "locator"
                ],
                "doc": "Paste value from system clipboard into given element.\n\n:param locator: Locator for element\n\nExample:\n\n.. code-block:: robotframework\n\n    Copy to clipboard       coordinates:401,198\n    Paste from clipboard    coordinates:822,710",
                "shortdoc": "Paste value from system clipboard into given element.",
                "tags": [],
                "matched": true
            },
            {
                "name": "Press Keys",
                "args": [
                    "*keys: str"
                ],
                "doc": "Press multiple keys down simultaneously.\n\n:param keys: Keys to press\n\nExample:\n\n.. code-block:: robotframework\n\n    Press keys    ctrl  alt  delete\n\n    Press keys    ctrl  a\n    Press keys    ctrl  c\n    ${all_text}=  Get clipboard value\n    Log    Text box content was: ${all_text}",
                "shortdoc": "Press multiple keys down simultaneously.",
                "tags": [],
                "matched": true
            },
            {
                "name": "Press Mouse Button",
                "args": [
                    "button: typing.Any = left"
                ],
                "doc": "Press down mouse button and keep it pressed.",
                "shortdoc": "Press down mouse button and keep it pressed.",
                "tags": [],
                "matched": true
            },
            {
                "name": "Read Text",
                "args": [
                    "locator: str = None"
                ],
                "doc": "Read text using OCR from the screen, or an area of the\nscreen defined by the given locator.\n\n:param locator: Location of element to read text from",
                "shortdoc": "Read text using OCR from the screen, or an area of the screen defined by the given locator.",
                "tags": [],
                "matched": true
            },
            {
                "name": "Release Mouse Button",
                "args": [
                    "button: typing.Any = left"
                ],
                "doc": "Release mouse button that was previously pressed.",
                "shortdoc": "Release mouse button that was previously pressed.",
                "tags": [],
                "matched": true
            },
            {
                "name": "Resize Region",
                "args": [
                    "region: Region",
                    "left: typing.Union[int, NoneType] = 0",
                    "top: typing.Union[int, NoneType] = 0",
                    "right: typing.Union[int, NoneType] = 0",
                    "bottom: typing.Union[int, NoneType] = 0"
                ],
                "doc": "Return a resized new ``Region`` from a given region.\n\n:param region: the region to resize.\n:param left: amount of pixels to resize left edge.\n:param top: amount of pixels to resize top edge.\n:param right: amount of pixels to resize right edge.\n:param bottom: amount of pixels to resize bottom edge.",
                "shortdoc": "Return a resized new ``Region`` from a given region.",
                "tags": [],
                "matched": true
            },
            {
                "name": "Set Clipboard Value",
                "args": [
                    "text: str"
                ],
                "doc": "Write given value to system clipboard.\n\nExample:\n\n.. code-block:: robotframework\n\n    Set clipboard value     This is some text.\n    Paste from clipboard    coordinates:822,710",
                "shortdoc": "Write given value to system clipboard.",
                "tags": [],
                "matched": true
            },
            {
                "name": "Set Default Confidence",
                "args": [
                    "confidence: float = None"
                ],
                "doc": "Set the default template matching confidence.\n\n:param confidence: Value from 1 to 100",
                "shortdoc": "Set the default template matching confidence.",
                "tags": [],
                "matched": true
            },
            {
                "name": "Set Default Timeout",
                "args": [
                    "timeout: float = 3.0"
                ],
                "doc": "Set the default time to wait for elements.\n\n:param timeout: Time in seconds",
                "shortdoc": "Set the default time to wait for elements.",
                "tags": [],
                "matched": true
            },
            {
                "name": "Take Screenshot",
                "args": [
                    "path: str = None",
                    "locator: str = None",
                    "embed: bool = True"
                ],
                "doc": "Take a screenshot of the whole screen, or an element\nidentified by the given locator.\n\n:param path: Path to screenshot. The string ``{index}`` will be replaced with\n    an index number to avoid overwriting previous screenshots.\n:param locator: Element to crop screenshot to\n:param embed: Embed screenshot into Robot Framework log",
                "shortdoc": "Take a screenshot of the whole screen, or an element identified by the given locator.",
                "tags": [],
                "matched": true
            },
            {
                "name": "Type Text",
                "args": [
                    "text: str",
                    "*modifiers: str",
                    "enter: bool = False"
                ],
                "doc": "Type text one letter at a time.\n\n:param text:       Text to write\n:param modifiers:  Modifier or functions keys held during typing\n:param enter:      Press Enter / Return key after typing text\n\nExample:\n\n.. code-block:: robotframework\n\n    Type text    this text will be uppercase    shift",
                "shortdoc": "Type text one letter at a time.",
                "tags": [],
                "matched": true
            },
            {
                "name": "Type Text Into",
                "args": [
                    "locator: str",
                    "text: str",
                    "clear: bool = False",
                    "enter: bool = False"
                ],
                "doc": "Type text at the position indicated by given locator.\n\n:param locator: Locator of input element\n:param text:    Text to write\n:param clear:   Clear element before writing\n:param enter:      Press Enter / Return key after typing text\n\nExample:\n\n.. code-block:: robotframework\n\n    Type text into    LoginForm.Name      Marky Mark\n    Type text into    LoginForm.Password  ${PASSWORD}",
                "shortdoc": "Type text at the position indicated by given locator.",
                "tags": [],
                "matched": true
            },
            {
                "name": "Wait For Element",
                "args": [
                    "locator: str",
                    "timeout: float = None",
                    "interval: float = 0.5"
                ],
                "doc": "Wait for an element defined by locator to exist, or\nraise a TimeoutException if none were found within timeout.\n\n:param locator: Locator string\n\nExample:\n\n.. code-block:: robotframework\n\n    Wait for element    alias:CookieConsent    timeout=30\n    Click    image:%{ROBOT_ROOT}/accept.png",
                "shortdoc": "Wait for an element defined by locator to exist, or raise a TimeoutException if none were found within timeout.",
                "tags": [],
                "matched": true
            },
            {
                "name": "Wait For Element To Disappear",
                "args": [
                    "locator: str",
                    "timeout: float = 10.0",
                    "interval: float = 0.5"
                ],
                "doc": "Wait for an element defined by locator to disappear.\n\nExample:\n\n.. code-block:: robotframework\n\n    Wait for element to disappear    alias:LoadingScreen    timeout=30\n    Click    image:%{ROBOT_ROOT}/main_menu.png",
                "shortdoc": "Wait for an element defined by locator to disappear.",
                "tags": [],
                "matched": true
            }
        ],
        "all_tags": [],
        "contains_tags": false
    },
    "RPA.Desktop.Clipboard": {
        "name": "RPA.Desktop.Clipboard",
        "doc": "*DEPRECATED!!* Use library RPA.Desktop's clipboard functionality instead.\n\n`Clipboard` is a library for managing clipboard - **copy** text to,\n**paste** text from, and **clear** clipboard contents.\n\n**Examples**\n\n**Robot Framework**\n\n.. code-block:: robotframework\n\n    *** Settings ***\n    Library    RPA.Desktop.Clipboard\n\n    *** Tasks ***\n    Clipping\n        Copy To Clipboard   Text from Robot to clipboard\n        ${var}=             Paste From Clipboard\n        Clear Clipboard\n\n**Python**\n\n.. code-block:: python\n\n    from RPA.Desktop.Clipboard import Clipboard\n\n    clip = Clipboard()\n    clip.copy_to_clipboard('Text from Python to clipboard')\n    text = clip.paste_from_clipboard()\n    print(f\"clipboard had text: '{text}'\")\n    clip.clear_clipboard()",
        "version": "",
        "named_args": true,
        "scope": "GLOBAL",
        "generated": "2020-12-01 14:53:06",
        "inits": [],
        "keywords": [
            {
                "name": "Clear Clipboard",
                "args": [],
                "doc": "*DEPRECATED!!* Use `RPA.Desktop` library's `Clear Clipboard` instead.\nClear clipboard contents",
                "shortdoc": "*DEPRECATED!!* Use `RPA.Desktop` library's `Clear Clipboard` instead. Clear clipboard contents",
                "tags": [],
                "matched": true
            },
            {
                "name": "Copy To Clipboard",
                "args": [
                    "text"
                ],
                "doc": "*DEPRECATED!!* Use `RPA.Desktop` library's `Copy to Clipboard` instead.\n\nCopy text to clipboard\n\n:param text: to copy",
                "shortdoc": "*DEPRECATED!!* Use `RPA.Desktop` library's `Copy to Clipboard` instead.",
                "tags": [],
                "matched": true
            },
            {
                "name": "Paste From Clipboard",
                "args": [],
                "doc": "*DEPRECATED!!* Use `RPA.Desktop` library's `Paste from Clipboard` instead.\n\n:return: text",
                "shortdoc": "*DEPRECATED!!* Use `RPA.Desktop` library's `Paste from Clipboard` instead.",
                "tags": [],
                "matched": true
            }
        ],
        "all_tags": [],
        "contains_tags": false
    },
    "RPA.Desktop.OperatingSystem": {
        "name": "RPA.Desktop.OperatingSystem",
        "doc": "`OperatingSystem` is a cross-platform library for managing\ncomputer properties and actions.\n\n**Examples**\n\n**Robot Framework**\n\n.. code-block:: robotframework\n\n    *** Settings ***\n    Library    RPA.Desktop.OperatingSystem\n\n    *** Tasks ***\n    Get computer information\n        ${boot_time}=   Get Boot Time  as_datetime=${TRUE}\n        ${machine}=     Get Machine Name\n        ${username}=    Get Username\n        &{memory}=      Get Memory Stats\n        Log Many        ${memory}\n\n**Python**\n\n.. code-block:: python\n\n    from RPA.Desktop.OperatingSystem import OperatingSystem\n\n    def get_computer_information():\n        ops = OperatingSystem()\n        print(f\"Boot time    : { ops.get_boot_time(as_datetime=True) }\"\n              f\"Machine name : { ops.get_machine_name() }\"\n              f\"Username     : { ops.get_username() }\"\n              f\"Memory       : { ops.get_memory_stats() }\")\n\n    if __name__ == \"__main__\":\n        get_computer_information()",
        "version": "",
        "named_args": true,
        "scope": "GLOBAL",
        "generated": "2020-12-01 14:53:06",
        "inits": [],
        "keywords": [
            {
                "name": "Boot Time In Seconds From Epoch",
                "args": [],
                "doc": "Get machine boot time\n\n:return: boot time in seconds from Epoch\n\nExample:\n\n.. code-block:: robotframework\n\n    ${epoch}  Boot Time In Seconds From Epoch",
                "shortdoc": "Get machine boot time",
                "tags": [],
                "matched": true
            },
            {
                "name": "Get Boot Time",
                "args": [
                    "as_datetime: bool = False",
                    "datetime_format: str = %Y-%m-%d %H:%M:%S"
                ],
                "doc": "Get computer boot time in seconds from Epoch or in datetime string.\n\n:param as_datetime: if True returns datetime string, otherwise seconds,\n    defaults to False\n:param datetime_format: datetime string format, defaults to \"%Y-%m-%d %H:%M:%S\"\n:return: seconds from Epoch or datetime string\n\nExample:\n\n.. code-block:: robotframework\n\n    ${boottime}  Get Boot Time\n    ${boottime}  Get Boot Time   as_datetime=True\n    ${boottime}  Get Boot Time   as_datetime=True  datetime_format=%d.%m.%Y",
                "shortdoc": "Get computer boot time in seconds from Epoch or in datetime string.",
                "tags": [],
                "matched": true
            },
            {
                "name": "Get Machine Name",
                "args": [],
                "doc": "Get machine name\n\n:return: machine name as string\n\nExample:\n\n.. code-block:: robotframework\n\n    ${machine}  Get Machine Name",
                "shortdoc": "Get machine name",
                "tags": [],
                "matched": true
            },
            {
                "name": "Get Memory Stats",
                "args": [
                    "humanized: bool = True"
                ],
                "doc": "Get computer memory stats and return those in bytes\nor in humanized memory format.\n\n:param humanized: if False returns memory information in bytes, defaults to True\n:return: memory information in dictionary format\n\nExample:\n\n.. code-block:: robotframework\n\n    &{mem}     Get Memory Stats\n    &{mem}     Get Memory Stats   humanized=False",
                "shortdoc": "Get computer memory stats and return those in bytes or in humanized memory format.",
                "tags": [],
                "matched": true
            },
            {
                "name": "Get Username",
                "args": [],
                "doc": "Get username of logged in user\n\n:return: username as string\n\nExample:\n\n.. code-block:: robotframework\n\n    ${user}  Get Username",
                "shortdoc": "Get username of logged in user",
                "tags": [],
                "matched": true
            },
            {
                "name": "Kill Process",
                "args": [
                    "process_name: str"
                ],
                "doc": "Kill process by name\n\n:param process_name: name of the process\n:return: True if succeeds False if not\n\nExample:\n\n.. code-block:: robotframework\n\n    ${process}  Process Exists  calc  strict=False\n    ${status}   Kill Process    ${process.name()}",
                "shortdoc": "Kill process by name",
                "tags": [],
                "matched": true
            },
            {
                "name": "Kill Process By Pid",
                "args": [
                    "pid: int"
                ],
                "doc": "Kill process by pid\n\n:param pid: process identifier\n\nExample:\n\n.. code-block:: robotframework\n\n    ${process}  Process Exists  calc  strict=False\n    ${status}   Kill Process    ${process.pid}",
                "shortdoc": "Kill process by pid",
                "tags": [],
                "matched": true
            },
            {
                "name": "Process Exists",
                "args": [
                    "process_name: str",
                    "strict: bool = True"
                ],
                "doc": "Check if process exists by its name\n\n:param process_name: search for this process\n:param strict: defines how match is made, default `True`\n which means that process name needs to be exact match\n and `False` does inclusive matching\n:return: process instance or False\n\nExample:\n\n.. code-block:: robotframework\n\n    ${process}  Process Exists  calc\n    ${process}  Process Exists  calc  strict=False",
                "shortdoc": "Check if process exists by its name",
                "tags": [],
                "matched": true
            },
            {
                "name": "Put System To Sleep",
                "args": [],
                "doc": "Puts system to sleep mode\n\nExample:\n\n.. code-block:: robotframework\n\n    Put System To Sleep",
                "shortdoc": "Puts system to sleep mode",
                "tags": [],
                "matched": true
            }
        ],
        "all_tags": [],
        "contains_tags": false
    },
    "RPA.Desktop.Windows": {
        "name": "RPA.Desktop.Windows",
        "doc": "`Windows` is a library for managing the Windows operating system.\n\n**Running Windows applications**\n\nWindows applications can be started in several ways. The library supports\nthe following keywords:\n\n- Open Application (dispatch Office applications)\n- Open File (open the file as process which opens the associated application)\n- Open Executable (uses pywinauto start)\n- Open Using Run Dialog (uses Windows run dialog)\n- Open From Search (uses Windows search dialog)\n\n**Locators**\n\n`Locator` is used to identify the element for interaction - usually for a mouse click.\n\nLocators can investigated for application once it has been opened by calling\nthe keyword `get_windows_elements` which can store locator information into JSON file\nand `screenshot` of the element into an image file.\n\n**Identifying locator**\n\nThe element needs to be identified by a unique method, for example, \"Three\" for button 3\nin the Calculator application. It can be given either as `Three` or `name:Three`.\n\nPossible search criterias:\n\n- name\n- class (class_name)\n- type (control_type)\n- id (automation_id)\n- any if none was defined\n\nThe current method of inspecting elements on Windows is `inspect.exe` which is part\nof `Windows SDK <https://docs.microsoft.com/en-us/windows/win32/winauto/inspect-objects>`_.\n\n**Keyboard**\n\nThe keyword `send_keys` can be used to send keys to the active window. The keyword\n`type_keys` sends keys to the active window element.\n\nSpecial key codes are documented on `pywinauto <https://pywinauto.readthedocs.io/en/latest/code/pywinauto.keyboard.html#>`_\ndocumentation page.\n\n**FAQ**\n\nQ. I see error message `AttributeError: module 'win32com.gen_py.00020813-0000-0000-C000-000000000046x0x1x9' has no attribute 'CLSIDToClassMap'`\n\nA. From PowerShell run this command: `Remove-Item -path $env:LOCALAPPDATA\\Temp\\gen_py -recurse`\n\n**Examples**\n\n**Robot Framework**\n\n.. code-block:: robotframework\n\n    *** Settings ***\n    Library          RPA.Desktop.Windows\n    Suite Teardown   Close all applications\n\n    *** Tasks ***\n    Open Calculator using run dialog\n        ${result}=              Open using run dialog    calc.exe   Calculator\n        ${result}=              Get Window Elements\n        Send Keys               5*2=\n        ${result}=              Get element             partial name:Display is\n        Log Many                ${result}\n        ${result}=              Get element rich text   id:CalculatorResults\n        Should Be Equal As Strings  ${result}  Display is 10\n        ${result}=              Get element rectangle   partial name:Display is\n        ${result}=              Is Element Visible      CalculatorResults\n        ${result}=              Is Element Enabled      partial name:Display is\n\n**Python**\n\n.. code-block:: python\n\n    from RPA.Desktop.Windows import Windows\n\n    win = Windows()\n\n    def open_calculator():\n        win.open_from_search(\"calc.exe\", \"Calculator\")\n        elements = win.get_window_elements()\n\n    def make_calculations(expression):\n        win.send_keys(expression)\n        result = win.get_element_rich_text('id:CalculatorResults')\n        return int(result.strip('Display is '))\n\n    if __name__ == \"__main__\":\n        open_calculator()\n        exp = '5*2='\n        result = make_calculations(exp)\n        print(f\"Calculation result of '{exp}' is '{result}'\")\n        win.close_all_applications()",
        "version": "",
        "named_args": true,
        "scope": "GLOBAL",
        "generated": "2020-12-01 14:53:06",
        "inits": [
            {
                "name": "Init",
                "args": [
                    "backend: str = uia"
                ],
                "doc": "Initialize self.  See help(type(self)) for accurate signature.",
                "shortdoc": "Initialize self.  See help(type(self)) for accurate signature.",
                "tags": [],
                "matched": true
            }
        ],
        "keywords": [
            {
                "name": "Boot Time In Seconds From Epoch",
                "args": [],
                "doc": "Get machine boot time\n\n:return: boot time in seconds from Epoch\n\nExample:\n\n.. code-block:: robotframework\n\n    ${epoch}  Boot Time In Seconds From Epoch",
                "shortdoc": "Get machine boot time",
                "tags": [],
                "matched": true
            },
            {
                "name": "Calculate Rectangle Center",
                "args": [
                    "rectangle: typing.Any"
                ],
                "doc": "Calculate x and y center coordinates from rectangle.\n\n:param rectangle: element rectangle coordinates\n:return: x and y coordinates of rectangle center\n\nExample:\n\n.. code-block:: robotframework\n\n    Open Using Run Dialog   calc  Calculator\n    &{rect}=        Get Element Rectangle    CalculatorResults\n    ${x}  ${y}=     Calculate Rectangle Center   ${rect}",
                "shortdoc": "Calculate x and y center coordinates from rectangle.",
                "tags": [],
                "matched": true
            },
            {
                "name": "Click Type",
                "args": [
                    "x: int = None",
                    "y: int = None",
                    "click_type: str = click"
                ],
                "doc": "Mouse click on coordinates x and y.\n\nDefault click type is `click` meaning `left`\n\n:param x: horizontal coordinate for click, defaults to None\n:param y: vertical coordinate for click, defaults to None\n:param click_type: \"click\", \"right\" or \"double\", defaults to \"click\"\n:raises ValueError: if coordinates are not valid\n\nExample:\n\n.. code-block:: robotframework\n\n    Click Type  x=450  y=100\n    Click Type  x=450  y=100  click_type=right\n    Click Type  x=450  y=100  click_type=double",
                "shortdoc": "Mouse click on coordinates x and y.",
                "tags": [],
                "matched": true
            },
            {
                "name": "Close All Applications",
                "args": [],
                "doc": "Close all applications\n\nExample:\n\n.. code-block:: robotframework\n\n    Open Application   Excel\n    Open Application   Word\n    Open Executable    notepad.exe   Untitled - Notepad\n    Close All Applications",
                "shortdoc": "Close all applications",
                "tags": [],
                "matched": true
            },
            {
                "name": "Connect By Handle",
                "args": [
                    "handle: str",
                    "windowtitle: str = None",
                    "existing_app: bool = False"
                ],
                "doc": "Connect to application by its handle\n\n:param handle: handle of the application\n\nExample:\n\n.. code-block:: robotframework\n\n    ${appid}  Connect By Handle  88112",
                "shortdoc": "Connect to application by its handle",
                "tags": [],
                "matched": true
            },
            {
                "name": "Connect By Pid",
                "args": [
                    "app_pid: str",
                    "windowtitle: str = None"
                ],
                "doc": "Connect to application by its pid\n\n:param app_pid: process id of the application\n\nExample:\n\n.. code-block:: robotframework\n\n    ${appid}  Connect By PID  3231",
                "shortdoc": "Connect to application by its pid",
                "tags": [],
                "matched": true
            },
            {
                "name": "Drag And Drop",
                "args": [
                    "src: typing.Any",
                    "target: typing.Any",
                    "src_locator: str",
                    "target_locator: str = None",
                    "handle_ctrl_key: bool = False",
                    "drop_delay: float = 2.0"
                ],
                "doc": "Drag elements from source and drop them on target.\n\nPlease note that if CTRL is not pressed down during drag and drop then\noperation is MOVE operation, on CTRL down the operation is COPY operation.\n\nThere will be also overwrite notification if dropping over existing files.\n\n:param src: application object or instance id\n:param target: application object or instance id\n:param src_locator: elements to move\n:param handle_ctrl_key: True if keyword should press CTRL down dragging\n:param drop_delay: how many seconds to wait until releasing mouse drop,\n default 2.0\n:raises ValueError: on validation errors\n\nExample:\n\n.. code-block:: robotframework\n\n    ${app1}=        Open Using Run Dialog    explorer.exe{VK_SPACE}C:\\workfiles\\movethese   movethese\n    ${app2}=        Open Using Run Dialog    wordpad.exe   Document - WordPad\n    Drag And Drop   ${app1}   ${app2}   regexp:testfile_\\d.txt  name:Rich Text Window   handle_ctrl_key=${True}\n    Drag And Drop   ${app1}   ${app1}   regexp:testfile_\\d.txt  name:subdir  handle_ctrl_key=${True}",
                "shortdoc": "Drag elements from source and drop them on target.",
                "tags": [],
                "matched": true
            },
            {
                "name": "Find Element",
                "args": [
                    "locator: str",
                    "search_criteria: str = None"
                ],
                "doc": "Find element from window by locator and criteria.\n\n:param locator: name of the locator\n:param search_criteria: criteria by which element is matched\n:return: list of matching elements and locators that were found on the window\n\nExample:\n\n.. code-block:: robotframework\n\n    @{elements}   Find Element   CalculatorResults\n    Log Many  ${elements[0]}     # list of matching elements\n    Log Many  ${elements[1]}     # list of all available locators",
                "shortdoc": "Find element from window by locator and criteria.",
                "tags": [],
                "matched": true
            },
            {
                "name": "Get App",
                "args": [
                    "app_id: int = None"
                ],
                "doc": "Get application object by id\n\nBy default returns active_application application object.\n\n:param app_id: id of the application to get, defaults to None\n:return: application object\n\nExample:\n\n.. code-block:: robotframework\n\n    ${app1}        Open Application   Excel\n    &{appdetails}  Get App   ${app1}",
                "shortdoc": "Get application object by id",
                "tags": [],
                "matched": true
            },
            {
                "name": "Get Boot Time",
                "args": [
                    "as_datetime: bool = False",
                    "datetime_format: str = %Y-%m-%d %H:%M:%S"
                ],
                "doc": "Get computer boot time in seconds from Epoch or in datetime string.\n\n:param as_datetime: if True returns datetime string, otherwise seconds,\n    defaults to False\n:param datetime_format: datetime string format, defaults to \"%Y-%m-%d %H:%M:%S\"\n:return: seconds from Epoch or datetime string\n\nExample:\n\n.. code-block:: robotframework\n\n    ${boottime}  Get Boot Time\n    ${boottime}  Get Boot Time   as_datetime=True\n    ${boottime}  Get Boot Time   as_datetime=True  datetime_format=%d.%m.%Y",
                "shortdoc": "Get computer boot time in seconds from Epoch or in datetime string.",
                "tags": [],
                "matched": true
            },
            {
                "name": "Get Dialog Rectangle",
                "args": [
                    "ctrl: typing.Any = None",
                    "as_dict: bool = False"
                ],
                "doc": "Get dialog rectangle coordinates\n\nIf `ctrl` is None then get coordinates from `dialog`\n:param ctrl: name of the window control object, defaults to None\n:return: coordinates: left, top, right, bottom\n\nExample:\n\n.. code-block:: robotframework\n\n    ${left}  ${top}  ${right}  ${bottom}=  Get Dialog Rectangle\n    &{coords}  Get Dialog Rectangle  as_dict=True\n    Log  top=${coords.top} left=${coords.left}",
                "shortdoc": "Get dialog rectangle coordinates",
                "tags": [],
                "matched": true
            },
            {
                "name": "Get Element",
                "args": [
                    "locator: str",
                    "screenshot: bool = False",
                    "open_dialog: bool = True"
                ],
                "doc": "Get element by locator.\n\n:param locator: name of the locator\n:param screenshot: takes element screenshot if True, defaults to False\n:param open_dialog: True if dialog should be reopened, default to True\n:return: element if element was identified, else False\n\nExample:\n\n.. code-block:: robotframework\n\n    ${element}  Get Element  CalculatorResults\n    ${element}  Get Element  Result      screenshot=True",
                "shortdoc": "Get element by locator.",
                "tags": [],
                "matched": true
            },
            {
                "name": "Get Element Center",
                "args": [
                    "element: dict"
                ],
                "doc": "Get element center coordinates\n\n:param element: dictionary of element items\n:return: coordinates, x and y\n\nExample:\n\n.. code-block:: robotframework\n\n    @{element}   Find Element  CalculatorResults\n    ${x}  ${y}=  Get Element Center  ${elements[0][0]}",
                "shortdoc": "Get element center coordinates",
                "tags": [],
                "matched": true
            },
            {
                "name": "Get Element Rectangle",
                "args": [
                    "locator: str",
                    "as_dict: bool = False"
                ],
                "doc": "Get value of element `rectangle` attribute.\n\n:param locator: element locator\n:param as_dict: return values in a dictionary, default `False`\n:return: (left, top, right, bottom) values if found, else False\n\nExample:\n\n.. code-block:: robotframework\n\n    ${left}  ${top}  ${right}  ${bottom}=  Get Element Rectangle  CalculatorResults\n    &{coords}  Get Element Rectangle  CalculatorResults  as_dict=True\n    Log  top=${coords.top} left=${coords.left}",
                "shortdoc": "Get value of element `rectangle` attribute.",
                "tags": [],
                "matched": true
            },
            {
                "name": "Get Element Rich Text",
                "args": [
                    "locator: str"
                ],
                "doc": "Get value of element `rich text` attribute.\n\n:param locator: element locator\n:return: `rich_text` value if found, else False\n\nExample:\n\n.. code-block:: robotframework\n\n    ${text}  Get Element Rich Text  CalculatorResults",
                "shortdoc": "Get value of element `rich text` attribute.",
                "tags": [],
                "matched": true
            },
            {
                "name": "Get Machine Name",
                "args": [],
                "doc": "Get machine name\n\n:return: machine name as string\n\nExample:\n\n.. code-block:: robotframework\n\n    ${machine}  Get Machine Name",
                "shortdoc": "Get machine name",
                "tags": [],
                "matched": true
            },
            {
                "name": "Get Memory Stats",
                "args": [
                    "humanized: bool = True"
                ],
                "doc": "Get computer memory stats and return those in bytes\nor in humanized memory format.\n\n:param humanized: if False returns memory information in bytes, defaults to True\n:return: memory information in dictionary format\n\nExample:\n\n.. code-block:: robotframework\n\n    &{mem}     Get Memory Stats\n    &{mem}     Get Memory Stats   humanized=False",
                "shortdoc": "Get computer memory stats and return those in bytes or in humanized memory format.",
                "tags": [],
                "matched": true
            },
            {
                "name": "Get Open Applications",
                "args": [],
                "doc": "Get list of all open applications\n\nReturns a dictionary\n\nExample:\n\n.. code-block:: robotframework\n\n    ${app1}    Open Application   Excel\n    ${app2}    Open Executable    calc.exe  Calculator\n    ${app3}    Open File          /path/to/myfile.txt\n    &{apps}    Get Open Applications",
                "shortdoc": "Get list of all open applications",
                "tags": [],
                "matched": true
            },
            {
                "name": "Get Spaced String",
                "args": [
                    "text"
                ],
                "doc": "Replace spaces in a text with `pywinauto.keyboard`\nspace characters `{VK_SPACE}`\n\n:param text: replace spaces in this string\n\nExample:\n\n.. code-block:: robotframework\n\n    ${txt}    Get Spaced String   My name is Bond\n    # ${txt} = My{VK_SPACE}name{VK_SPACE}is{VK_SPACE}Bond",
                "shortdoc": "Replace spaces in a text with `pywinauto.keyboard` space characters `{VK_SPACE}`",
                "tags": [],
                "matched": true
            },
            {
                "name": "Get Text",
                "args": [
                    "locator: str"
                ],
                "doc": "Get text from element\n\n:param locator: element locator\n\nExample:\n\n.. code-block:: robotframework\n\n    Open Using Run Dialog  calc     Calculator\n    Type Into    CalculatorResults   11\n    Type Into    CalculatorResults   55\n    &{val}       Get Text   CalculatorResults",
                "shortdoc": "Get text from element",
                "tags": [],
                "matched": true
            },
            {
                "name": "Get Username",
                "args": [],
                "doc": "Get username of logged in user\n\n:return: username as string\n\nExample:\n\n.. code-block:: robotframework\n\n    ${user}  Get Username",
                "shortdoc": "Get username of logged in user",
                "tags": [],
                "matched": true
            },
            {
                "name": "Get Window Elements",
                "args": [
                    "screenshot: bool = False",
                    "element_json: bool = False",
                    "outline: bool = False"
                ],
                "doc": "Get element information about all window dialog controls\nand their descendants.\n\n:param screenshot: save element screenshot if True, defaults to False\n:param element_json: save element json if True, defaults to False\n:param outline: highlight elements if True, defaults to False\n:return: all controls and all elements\n\nExample:\n\n.. code-block:: robotframework\n\n    @{elements}   Get Window Elements\n    Log Many      ${elements[0]}     # list of all available locators\n    Log Many      ${elements[1]}     # list of matching elements\n    @{elements}   Get Window Elements  screenshot=True  element_json=True  outline=True",
                "shortdoc": "Get element information about all window dialog controls and their descendants.",
                "tags": [],
                "matched": true
            },
            {
                "name": "Get Window List",
                "args": [],
                "doc": "Get list of open windows\n\nWindow dictionaries contain:\n\n- title\n- pid\n- handle\n\n:return: list of window dictionaries\n\nExample:\n\n.. code-block:: robotframework\n\n    @{windows}    Get Window List\n    FOR  ${window}  IN  @{windows}\n        Log Many  ${window}\n    END",
                "shortdoc": "Get list of open windows",
                "tags": [],
                "matched": true
            },
            {
                "name": "Is Element Enabled",
                "args": [
                    "locator: str"
                ],
                "doc": "Is element enabled.\n\n:param locator: element locator\n:return: True if enabled, else False\n\nExample:\n\n.. code-block:: robotframework\n\n    ${res}=   Is Element Enabled  CalculatorResults",
                "shortdoc": "Is element enabled.",
                "tags": [],
                "matched": true
            },
            {
                "name": "Is Element Matching",
                "args": [
                    "itemdict: dict",
                    "locator: str",
                    "criteria: str",
                    "wildcard: bool = False"
                ],
                "doc": "Is element matching. Check if locator is found in `any` field\nor `criteria` field in the window items.\n\n:param itemDict: dictionary of element items\n:param locator: name of the locator\n:param criteria: criteria on which to match element\n:param wildcard: whether to do reg exp match or not, default False\n:return: True if element is matching locator and criteria, False if not",
                "shortdoc": "Is element matching. Check if locator is found in `any` field or `criteria` field in the window items.",
                "tags": [],
                "matched": true
            },
            {
                "name": "Is Element Visible",
                "args": [
                    "locator: str"
                ],
                "doc": "Is element visible.\n\n:param locator: element locator\n:return: True if visible, else False\n\nExample:\n\n.. code-block:: robotframework\n\n    ${res}=   Is Element Visible  CalculatorResults",
                "shortdoc": "Is element visible.",
                "tags": [],
                "matched": true
            },
            {
                "name": "Kill Process",
                "args": [
                    "process_name: str"
                ],
                "doc": "Kill process by name\n\n:param process_name: name of the process\n:return: True if succeeds False if not\n\nExample:\n\n.. code-block:: robotframework\n\n    ${process}  Process Exists  calc  strict=False\n    ${status}   Kill Process    ${process.name()}",
                "shortdoc": "Kill process by name",
                "tags": [],
                "matched": true
            },
            {
                "name": "Kill Process By Pid",
                "args": [
                    "pid: int"
                ],
                "doc": "Kill process by pid\n\n:param pid: process identifier\n\nExample:\n\n.. code-block:: robotframework\n\n    ${process}  Process Exists  calc  strict=False\n    ${status}   Kill Process    ${process.pid}",
                "shortdoc": "Kill process by pid",
                "tags": [],
                "matched": true
            },
            {
                "name": "Lock Screen",
                "args": [],
                "doc": "Put windows into lock mode\n\nExample:\n\n.. code-block:: robotframework\n\n    Lock Screen",
                "shortdoc": "Put windows into lock mode",
                "tags": [],
                "matched": true
            },
            {
                "name": "Log In",
                "args": [
                    "username: str",
                    "password: str",
                    "domain: str = ."
                ],
                "doc": "Log into Windows `domain` with `username` and `password`.\n\n:param username: name of the user\n:param password: password of the user\n:param domain: windows domain for the user, defaults to \".\"\n:return: handle\n\nExample:\n\n.. code-block:: robotframework\n\n    Log In  username=myname  password=mypassword  domain=company",
                "shortdoc": "Log into Windows `domain` with `username` and `password`.",
                "tags": [],
                "matched": true
            },
            {
                "name": "Menu Select",
                "args": [
                    "menuitem: str"
                ],
                "doc": "Select item from menu\n\n:param menuitem: name of the menu item\n\nExample:\n\n.. code-block:: robotframework\n\n    Open Using Run Dialog   notepad     Untitled - Notepad\n    Menu Select             File->Print",
                "shortdoc": "Select item from menu",
                "tags": [],
                "matched": true
            },
            {
                "name": "Minimize Dialog",
                "args": [
                    "windowtitle: str = None"
                ],
                "doc": "Minimize window by its title\n\n:param windowtitle: name of the window, default `None` means that\n active window is going to be minimized\n\nExample:\n\n.. code-block:: robotframework\n\n    Open Using Run Dialog  calc     Calculator\n    Open Using Run Dialog  notepad  Untitled - Notepad\n    Minimize Dialog    # Current window (Notepad)\n    Minimize Dialog    Calculator",
                "shortdoc": "Minimize window by its title",
                "tags": [],
                "matched": true
            },
            {
                "name": "Mouse Click",
                "args": [
                    "locator: str = None",
                    "x: int = 0",
                    "y: int = 0",
                    "off_x: int = 0",
                    "off_y: int = 0",
                    "image: str = None",
                    "method: str = locator",
                    "ctype: str = click",
                    "**kwargs"
                ],
                "doc": "Mouse click `locator`, `coordinates`, or `image`\n\nWhen using method `locator`,`image` or `ocr` mouse is clicked by default at\ncenter coordinates.\n\nClick types are:\n\n- `click` normal left button mouse click\n- `double`\n- `right`\n\n:param locator: element locator on active window\n:param x: coordinate x on desktop\n:param y: coordinate y on desktop\n:param off_x: offset x (used for locator and image clicks)\n:param off_y: offset y (used for locator and image clicks)\n:param image: image to click on desktop\n:param method: one of the available methods to mouse click, default \"locator\"\n:param ctype: type of mouse click\n:param kwargs: these keyword arguments can be used to pass arguments\n to underlying `Images` library to finetune image template matching,\n for example. `tolerance=0.5` would adjust image tolerance for the image\n matching\n\nExample:\n\n.. code-block:: robotframework\n\n    Mouse Click  method=coordinates  100   100\n    Mouse Click  CalculatorResults\n    Mouse Click  method=image  image=myimage.png  off_x=10  off_y=10  ctype=right\n    Mouse Click  method=image  image=myimage.png  tolerance=0.8\n    ${elements}  ${other}=     Find Element  class:Button\n    FOR  ${element}  IN  @{elements}\n        Run Keyword If   ${element}[visible]   Mouse Click  ${element}\n    END",
                "shortdoc": "Mouse click `locator`, `coordinates`, or `image`",
                "tags": [],
                "matched": true
            },
            {
                "name": "Mouse Click Coords",
                "args": [
                    "x: int",
                    "y: int",
                    "ctype: str = click",
                    "delay_time: float = None"
                ],
                "doc": "Click at coordinates on desktop\n\n:param x: horizontal coordinate on the windows to click\n:param y: vertical coordinate on the windows to click\n:param ctype: click type \"click\", \"right\" or \"double\", defaults to \"click\"\n:param delay: delay in seconds after, default is no delay\n\nExample:\n\n.. code-block:: robotframework\n\n    Mouse Click Coords  x=450  y=100\n    Mouse Click Coords  x=300  y=300  ctype=right\n    Mouse Click Coords  x=450  y=100  delay=5.0",
                "shortdoc": "Click at coordinates on desktop",
                "tags": [],
                "matched": true
            },
            {
                "name": "Mouse Click Image",
                "args": [
                    "template: str",
                    "off_x: int = 0",
                    "off_y: int = 0",
                    "ctype: str = click",
                    "**kwargs"
                ],
                "doc": "Click at template image on desktop\n\n:param image: image to click on desktop\n:param off_x: horizontal offset from top left corner to click on\n:param off_y: vertical offset from top left corner to click on\n:param ctype: type of mouse click\n:param kwargs: these keyword arguments can be used to pass arguments\n to underlying `Images` library to finetune image template matching,\n for example. `tolerance=0.5` would adjust image tolerance for the image\n matching\n\nExample:\n\n.. code-block:: robotframework\n\n    Mouse Click  image=myimage.png  off_x=10  off_y=10  ctype=right\n    Mouse Click  image=myimage.png  tolerance=0.8",
                "shortdoc": "Click at template image on desktop",
                "tags": [],
                "matched": true
            },
            {
                "name": "Open Application",
                "args": [
                    "application: str"
                ],
                "doc": "Open application by dispatch method\n\nThis keyword is used to launch Microsoft applications like\nExcel, Word, Outlook and Powerpoint.\n\n:param application: name of the application as `str`\n:return: application instance id\n\nExample:\n\n.. code-block:: robotframework\n\n    ${app1}    Open Application   Excel\n    ${app2}    Open Application   Word",
                "shortdoc": "Open application by dispatch method",
                "tags": [],
                "matched": true
            },
            {
                "name": "Open Dialog",
                "args": [
                    "windowtitle: str = None",
                    "highlight: bool = False",
                    "timeout: int = 10",
                    "existing_app: bool = False"
                ],
                "doc": "Open window by its title.\n\n:param windowtitle: name of the window, defaults to active window if None\n:param highlight: draw outline for window if True, defaults to False\n:param timeout: time to wait for dialog to appear\n\nExample:\n\n.. code-block:: robotframework\n\n    Open Dialog       Untitled - Notepad\n    Open Dialog       Untitled - Notepad   highlight=True   timeout=5",
                "shortdoc": "Open window by its title.",
                "tags": [],
                "matched": true
            },
            {
                "name": "Open Executable",
                "args": [
                    "executable: str",
                    "windowtitle: str",
                    "backend: str = None",
                    "work_dir: str = None"
                ],
                "doc": "Open Windows executable. Window title name is required\nto get handle on the application.\n\n:param executable: name of the executable\n:param windowtitle: name of the window\n:param backend: set Windows backend, default None means using\n library default value\n:param work_dir: path to working directory, default None\n:return: application instance id\n\nExample:\n\n.. code-block:: robotframework\n\n    ${app1}    Open Executable   calc.exe  Calculator",
                "shortdoc": "Open Windows executable. Window title name is required to get handle on the application.",
                "tags": [],
                "matched": true
            },
            {
                "name": "Open File",
                "args": [
                    "filename: str"
                ],
                "doc": "Open associated application when opening file\n\n:param filename: path to file\n:return: True if application is opened, False if not\n\nExample:\n\n.. code-block:: robotframework\n\n    ${app1}    Open File   /path/to/myfile.txt",
                "shortdoc": "Open associated application when opening file",
                "tags": [],
                "matched": true
            },
            {
                "name": "Open From Search",
                "args": [
                    "executable: str",
                    "windowtitle: str",
                    "timeout: int = 10"
                ],
                "doc": "Open application using Windows search dialog.\nWindow title name is required to get handle on the application.\n\n:param executable: name of the executable\n:param windowtitle: name of the window\n:param timeout: time to wait for dialog to appear\n:return: application instance id\n\nExample:\n\n.. code-block:: robotframework\n\n    ${app1}    Open From Search  calculator  Calculator",
                "shortdoc": "Open application using Windows search dialog. Window title name is required to get handle on the application.",
                "tags": [],
                "matched": true
            },
            {
                "name": "Open Using Run Dialog",
                "args": [
                    "executable: str",
                    "windowtitle: str",
                    "timeout: int = 10"
                ],
                "doc": "Open application using Windows run dialog.\nWindow title name is required to get handle on the application.\n\n:param executable: name of the executable\n:param windowtitle: name of the window\n:param timeout: time to wait for dialog to appear\n:return: application instance id\n\nExample:\n\n.. code-block:: robotframework\n\n    ${app1}    Open Using Run Dialog  notepad  Untitled - Notepad",
                "shortdoc": "Open application using Windows run dialog. Window title name is required to get handle on the application.",
                "tags": [],
                "matched": true
            },
            {
                "name": "Process Exists",
                "args": [
                    "process_name: str",
                    "strict: bool = True"
                ],
                "doc": "Check if process exists by its name\n\n:param process_name: search for this process\n:param strict: defines how match is made, default `True`\n which means that process name needs to be exact match\n and `False` does inclusive matching\n:return: process instance or False\n\nExample:\n\n.. code-block:: robotframework\n\n    ${process}  Process Exists  calc\n    ${process}  Process Exists  calc  strict=False",
                "shortdoc": "Check if process exists by its name",
                "tags": [],
                "matched": true
            },
            {
                "name": "Put System To Sleep",
                "args": [],
                "doc": "Put Windows into sleep mode\n\nExample:\n\n.. code-block:: robotframework\n\n    Put System To Sleep",
                "shortdoc": "Put Windows into sleep mode",
                "tags": [],
                "matched": true
            },
            {
                "name": "Quit Application",
                "args": [
                    "app_id: str = None",
                    "send_keys: bool = False"
                ],
                "doc": "Quit an application by application id or\nactive application if `app_id` is None.\n\n:param app_id: application_id, defaults to None\n\nExample:\n\n.. code-block:: robotframework\n\n    ${app1}   Open Application   Excel\n    ${app2}   Open Application   Word\n    Quit Application  ${app1}",
                "shortdoc": "Quit an application by application id or active application if `app_id` is None.",
                "tags": [],
                "matched": true
            },
            {
                "name": "Restore Dialog",
                "args": [
                    "windowtitle: str = None"
                ],
                "doc": "Restore window by its title\n\n:param windowtitle: name of the window, default `None` means that\n active window is going to be restored\n\nExample:\n\n.. code-block:: robotframework\n\n    Open Using Run Dialog  notepad  Untitled - Notepad\n    Minimize Dialog\n    Sleep             1s\n    Restore Dialog\n    Sleep             1s\n    Restore Dialog    Untitled - Notepad",
                "shortdoc": "Restore window by its title",
                "tags": [],
                "matched": true
            },
            {
                "name": "Screenshot",
                "args": [
                    "filename: str",
                    "element: dict = None",
                    "ctrl: typing.Any = None",
                    "desktop: bool = False",
                    "overwrite: bool = False"
                ],
                "doc": "Save screenshot into filename.\n\n:param filename: name of the file\n:param element: take element screenshot, defaults to None\n:param ctrl: take control screenshot, defaults to None\n:param desktop: take desktop screenshot if True, defaults to False\n:param overwrite: file is overwritten if True, defaults to False\n\nExample:\n\n.. code-block:: robotframework\n\n    @{element}   Find Element  CalculatorResults\n    Screenshot   element.png   ${elements[0][0]}\n    Screenshot   desktop.png   desktop=True\n    Screenshot   desktop.png   desktop=True  overwrite=True",
                "shortdoc": "Save screenshot into filename.",
                "tags": [],
                "matched": true
            },
            {
                "name": "Send Keys",
                "args": [
                    "keys: str"
                ],
                "doc": "Send keys into active windows.\n\n:param keys: list of keys to send\n\nExample:\n\n.. code-block:: robotframework\n\n    Open Executable  calc.exe  Calculator\n    Send Keys        2{+}3=",
                "shortdoc": "Send keys into active windows.",
                "tags": [],
                "matched": true
            },
            {
                "name": "Send Keys To Input",
                "args": [
                    "keys_to_type: str",
                    "with_enter: bool = True",
                    "send_delay: float = 0.5",
                    "enter_delay: float = 1.5"
                ],
                "doc": "Send keys to windows and add ENTER if `with_enter` is True\n\nAt the end of send_keys there is by default 0.5 second delay.\nAt the end of ENTER there is by default 1.5 second delay.\n\n:param keys_to_type: keys to type into Windows\n:param with_enter: send ENTER if `with_enter` is True\n:param send_delay: delay after send_keys\n:param enter_delay: delay after ENTER\n\nExample:\n\n.. code-block:: robotframework\n\n    ${txt}    Get Spaced String   My name is Bond, James Bond\n    Send Keys To Input  ${txt}    with_enter=False\n    Send Keys To Input  {ENTER}THE   send_delay=5.0  with_enter=False\n    Send Keys To Input  {VK_SPACE}-{VK_SPACE}END   enter_delay=5.0",
                "shortdoc": "Send keys to windows and add ENTER if `with_enter` is True",
                "tags": [],
                "matched": true
            },
            {
                "name": "Set Windows Backend",
                "args": [
                    "backend: str"
                ],
                "doc": "Set Windows backend which is used to interact with Windows\napplications\n\nAllowed values defined by `SUPPORTED_BACKENDS`\n\n:param backend: name of the backend to use\n\nExample:\n\n.. code-block:: robotframework\n\n    Set Windows Backend   uia\n    Open Executable   calc.exe  Calculator\n    Set Windows Backend   win32\n    Open Executable   calc.exe  Calculator",
                "shortdoc": "Set Windows backend which is used to interact with Windows applications",
                "tags": [],
                "matched": true
            },
            {
                "name": "Switch To Application",
                "args": [
                    "app_id: int"
                ],
                "doc": "Switch to application by id.\n\n:param app_id: application's id\n:raises ValueError: if application is not found by given id\n\nExample:\n\n.. code-block:: robotframework\n\n    ${app1}    Open Application   Excel\n    ${app2}    Open Application   Word\n    Switch To Application   ${app1}",
                "shortdoc": "Switch to application by id.",
                "tags": [],
                "matched": true
            },
            {
                "name": "Type Into",
                "args": [
                    "locator: str",
                    "keys: str",
                    "empty_field: bool = False"
                ],
                "doc": "Type keys into element matched by given locator.\n\n:param locator: element locator\n:param keys:    list of keys to type\n\nExample:\n\n.. code-block:: robotframework\n\n    Open Executable  calc.exe  Calculator\n    Type Into        CalculatorResults  11\n    Type Into        CalculatorResults  22  empty_field=True",
                "shortdoc": "Type keys into element matched by given locator.",
                "tags": [],
                "matched": true
            },
            {
                "name": "Type Keys",
                "args": [
                    "keys: str"
                ],
                "doc": "Type keys into active window element.\n\n:param keys: list of keys to type\n\nExample:\n\n.. code-block:: robotframework\n\n    Open Executable  notepad.exe  Untitled - Notepad\n    Type Keys   My text",
                "shortdoc": "Type keys into active window element.",
                "tags": [],
                "matched": true
            },
            {
                "name": "Wait For Element",
                "args": [
                    "locator: str",
                    "search_criteria: str = None",
                    "timeout: float = 30.0",
                    "interval: float = 2.0"
                ],
                "doc": "Wait for element to appear into the window.\n\nCan return 1 or more elements matching locator, or raises\n`ElementNotFoundError` if element is not found within timeout.\n\n:param locator: name of the locator\n:param search_criteria: criteria by which element is matched\n:param timeout: defines how long to wait for element to appear,\n defaults to 30.0 seconds\n:param interval: how often to poll for element,\n defaults to 2.0 seconds (minimum is 0.5 seconds)\n\nExample:\n\n.. code-block:: robotframework\n\n    @{elements}  Wait For Element  CalculatorResults\n    @{elements}  Wait For Element  Results   timeout=10  interval=1.5",
                "shortdoc": "Wait for element to appear into the window.",
                "tags": [],
                "matched": true
            }
        ],
        "all_tags": [],
        "contains_tags": false
    },
    "RPA.Desktop.keywords.application": {
        "name": "RPA.Desktop.keywords.application",
        "doc": "Documentation for library ``RPA.Desktop.keywords.application``.",
        "version": "",
        "named_args": true,
        "scope": "GLOBAL",
        "generated": "2020-12-01 14:53:06",
        "inits": [],
        "keywords": [
            {
                "name": "Output",
                "args": [
                    "*args"
                ],
                "doc": "Run command and return output.",
                "shortdoc": "Run command and return output.",
                "tags": [],
                "matched": true
            }
        ],
        "all_tags": [],
        "contains_tags": false
    },
    "RPA.Desktop.keywords.clipboard": {
        "name": "RPA.Desktop.keywords.clipboard",
        "doc": "Documentation for library ``RPA.Desktop.keywords.clipboard``.",
        "version": "",
        "named_args": true,
        "scope": "GLOBAL",
        "generated": "2020-12-01 14:53:06",
        "inits": [],
        "keywords": [],
        "all_tags": [],
        "contains_tags": false
    },
    "RPA.Desktop.keywords.context": {
        "name": "RPA.Desktop.keywords.context",
        "doc": "Documentation for library ``RPA.Desktop.keywords.context``.",
        "version": "",
        "named_args": true,
        "scope": "GLOBAL",
        "generated": "2020-12-01 14:53:06",
        "inits": [],
        "keywords": [],
        "all_tags": [],
        "contains_tags": false
    },
    "RPA.Desktop.keywords.finder": {
        "name": "RPA.Desktop.keywords.finder",
        "doc": "Documentation for library ``RPA.Desktop.keywords.finder``.",
        "version": "",
        "named_args": true,
        "scope": "GLOBAL",
        "generated": "2020-12-01 14:53:06",
        "inits": [],
        "keywords": [
            {
                "name": "Clamp",
                "args": [
                    "minimum: float",
                    "value: float",
                    "maximum: float"
                ],
                "doc": "Clamp value between given minimum and maximum.",
                "shortdoc": "Clamp value between given minimum and maximum.",
                "tags": [],
                "matched": true
            },
            {
                "name": "Ensure Recognition",
                "args": [],
                "doc": "",
                "shortdoc": "",
                "tags": [],
                "matched": true
            },
            {
                "name": "Parse Locator",
                "args": [
                    "locator: str"
                ],
                "doc": "Construct locator from string format, e.g. 'coordinates:120,340'.",
                "shortdoc": "Construct locator from string format, e.g. 'coordinates:120,340'.",
                "tags": [],
                "matched": true
            },
            {
                "name": "Transform",
                "args": [
                    "regions: typing.List[RPA.core.geometry.Region]",
                    "source: Region",
                    "destination: Region"
                ],
                "doc": "Transform given regions from a local coordinate system to a\nglobal coordinate system.\n\nTakes into account location and scaling of the regions.\nAssumes that the aspect ratio does not change.\n\n:param regions: List of regions to transform\n:param source: Dimensions of local coordinate system\n:param destination: Position/scale of local coordinates in the global scope",
                "shortdoc": "Transform given regions from a local coordinate system to a global coordinate system.",
                "tags": [],
                "matched": true
            }
        ],
        "all_tags": [],
        "contains_tags": false
    },
    "RPA.Desktop.keywords.keyboard": {
        "name": "RPA.Desktop.keywords.keyboard",
        "doc": "Documentation for library ``RPA.Desktop.keywords.keyboard``.",
        "version": "",
        "named_args": true,
        "scope": "GLOBAL",
        "generated": "2020-12-01 14:53:06",
        "inits": [],
        "keywords": [
            {
                "name": "To Key",
                "args": [
                    "key: str"
                ],
                "doc": "Convert key string to correct enum value.",
                "shortdoc": "Convert key string to correct enum value.",
                "tags": [],
                "matched": true
            }
        ],
        "all_tags": [],
        "contains_tags": false
    },
    "RPA.Desktop.keywords.mouse": {
        "name": "RPA.Desktop.keywords.mouse",
        "doc": "Documentation for library ``RPA.Desktop.keywords.mouse``.",
        "version": "",
        "named_args": true,
        "scope": "GLOBAL",
        "generated": "2020-12-01 14:53:06",
        "inits": [],
        "keywords": [
            {
                "name": "Delay",
                "args": [
                    "sleeptime: float = 0.0"
                ],
                "doc": "Delay execution for given amount of seconds.\n\n:param sleeptime: seconds as float, defaults to 0",
                "shortdoc": "Delay execution for given amount of seconds.",
                "tags": [],
                "matched": true
            },
            {
                "name": "To Action",
                "args": [
                    "value"
                ],
                "doc": "Convert value to Action enum.",
                "shortdoc": "Convert value to Action enum.",
                "tags": [],
                "matched": true
            },
            {
                "name": "To Button",
                "args": [
                    "value"
                ],
                "doc": "Convert value to Button enum.",
                "shortdoc": "Convert value to Button enum.",
                "tags": [],
                "matched": true
            },
            {
                "name": "To Point",
                "args": [
                    "location"
                ],
                "doc": "Converted resolved location to single point, for clicking.",
                "shortdoc": "Converted resolved location to single point, for clicking.",
                "tags": [],
                "matched": true
            }
        ],
        "all_tags": [],
        "contains_tags": false
    },
    "RPA.Desktop.keywords.screen": {
        "name": "RPA.Desktop.keywords.screen",
        "doc": "Documentation for library ``RPA.Desktop.keywords.screen``.",
        "version": "",
        "named_args": true,
        "scope": "GLOBAL",
        "generated": "2020-12-01 14:53:06",
        "inits": [],
        "keywords": [
            {
                "name": "Displays",
                "args": [],
                "doc": "Returns list of display regions, without combined virtual display.",
                "shortdoc": "Returns list of display regions, without combined virtual display.",
                "tags": [],
                "matched": true
            },
            {
                "name": "Grab",
                "args": [
                    "region: Region = None"
                ],
                "doc": "Take a screenshot of either the full virtual display,\nor a cropped area of the given region.",
                "shortdoc": "Take a screenshot of either the full virtual display, or a cropped area of the given region.",
                "tags": [],
                "matched": true
            },
            {
                "name": "Log Image",
                "args": [
                    "image: Image",
                    "size=1024"
                ],
                "doc": "Embed image into Robot Framework log.",
                "shortdoc": "Embed image into Robot Framework log.",
                "tags": [],
                "matched": true
            }
        ],
        "all_tags": [],
        "contains_tags": false
    },
    "RPA.Desktop.keywords.text": {
        "name": "RPA.Desktop.keywords.text",
        "doc": "Documentation for library ``RPA.Desktop.keywords.text``.",
        "version": "",
        "named_args": true,
        "scope": "GLOBAL",
        "generated": "2020-12-01 14:53:06",
        "inits": [],
        "keywords": [
            {
                "name": "Ensure Recognition",
                "args": [],
                "doc": "",
                "shortdoc": "",
                "tags": [],
                "matched": true
            }
        ],
        "all_tags": [],
        "contains_tags": false
    },
    "RPA.Desktop.utils": {
        "name": "RPA.Desktop.utils",
        "doc": "Documentation for library ``RPA.Desktop.utils``.",
        "version": "",
        "named_args": true,
        "scope": "GLOBAL",
        "generated": "2020-12-01 14:53:06",
        "inits": [],
        "keywords": [
            {
                "name": "Is Linux",
                "args": [],
                "doc": "",
                "shortdoc": "",
                "tags": [],
                "matched": true
            },
            {
                "name": "Is Macos",
                "args": [],
                "doc": "",
                "shortdoc": "",
                "tags": [],
                "matched": true
            },
            {
                "name": "Is Windows",
                "args": [],
                "doc": "",
                "shortdoc": "",
                "tags": [],
                "matched": true
            }
        ],
        "all_tags": [],
        "contains_tags": false
    },
    "RPA.Dialogs": {
        "name": "RPA.Dialogs",
        "doc": "The `Dialogs` library provides a way to ask for user input during executions\nthrough HTML forms. Form elements can be built with library keywords or they can\nbe defined in a static JSON file.\n\n**How the library works**\n\nThe main keyword of the library is ``Request Response`` which works as follows:\n\n1. It starts an HTTP server in the background\n2. The HTML form is generated either according to a JSON file or the\n   keywords called during the task\n3. It opens a browser and shows the created form (The browser is opened with\n   the ``Open Available Browser`` keyword from the ``RPA.Browser`` library)\n4. Once the form is filled and submitted by the user, the server will process\n   the response and extract the field values, which in turn are returned by the keyword\n5. In the end, the browser is closed and the HTTP server is stopped\n\n``Request Response`` can be invoked in two ways:\n\n1. Without any parameters. This means that form shown is the one created\n   by other library keywords. If no form elements have been added with\n   keywords then the form will contain just one submit button. Form building\n   must be started with the keyword ``Create Form``.\n2. Giving a path to a JSON file (using the parameter **formspec**) which\n   specifies the elements that form should include.\n\nThe keyword has optional parameters to specify form window **width** and **height**.\nThe default size is 600px wide and 1000px high.\n\n**Setting library arguments**\n\nLibrary has arguments ``server_port`` and ``stylesheet``. The ``server_port`` argument\ntakes integer value, which defines port where HTTP server will be run. By default port is 8105.\nThe ``stylesheet`` can be used to point CSS file, which will be used to modify style of form,\nwhich is shown to the user. Defaults to built-in Robocorp stylesheet.\n\n**Supported element types**\n\nAs a bare minimum, the form is displayed with a submit button when the\n``Request Response`` keyword is called.\n\nThe supported input elements and their corresponding HTML tags are:\n\n- form (``<form>``)\n- title (``<h3>``)\n- text (``<p>``)\n- radiobutton  (``<input type='radio'>``)\n- checkbox (``<input type='checkbox'>``)\n- dropdown (``<select>``)\n- textarea (``<textarea>``)\n- textinput (``<input type='text'>``)\n- fileinput (``<input type='file'>``)\n- hiddeninput (``<input type='hidden'>``)\n- submit (``<input type='submit'>``)\n\n**About file types**\n\nThe ``Add File Input`` keyword has parameter ``filetypes``. Parameter sets filter\nfor file types that can be uploaded via element. Parameter can be set to ``filetypes=${EMPTY}``\nto accept all files. Multiple types are separated with comma ``filetypes=image/jpeg,image/png``.\n\nSome common filetypes:\n\n- image/* (all image types)\n- audio/* (all audio types)\n- video/* (all video types)\n- application/pdf (PDFs)\n- application/vnd.ms-excel (.xls, .xlsx)\n\nThe list of all possible `MIME-types <http://www.iana.org/assignments/media-types/media-types.xhtml>`_.\n\n**Examples**\n\n**Robot Framework**\n\nExamples of creating forms through keywords and a JSON file:\n\n.. code-block:: robotframework\n\n    *** Settings ***\n    Library    RPA.Dialogs\n\n    *** Keywords ***\n    Ask Question From User By Form Built With Keywords\n        Create Form     questions\n        Add Text Input  label=What is your name?  name=username\n        &{response}=    Request Response\n        Log             Username is \"${response}[username]\"\n\n    Ask Question From User By Form Specified With JSON\n        &{response}=    Request Response  /path/to/myform.json\n        Log             Username is \"${response}[username]\"\n\n**Python**\n\nThe library can also be used inside Python:\n\n.. code-block:: python\n\n    from RPA.Dialogs import Dialogs\n\n    def ask_question_from_user(question, attribute):\n        d = Dialogs()\n        d.create_form('questions')\n        d.add_text_input(label=question, name=attribute)\n        response = request_response()\n        return response\n\n    response = ask_question_from_user('What is your name ?', 'username')\n    print(f\"Username is '{response['username']}'\")",
        "version": "",
        "named_args": true,
        "scope": "GLOBAL",
        "generated": "2020-12-01 14:53:06",
        "inits": [
            {
                "name": "Init",
                "args": [
                    "server_port: int = 8105",
                    "stylesheet: str = None"
                ],
                "doc": "The dialogs library can be initialized to a custom\nport and with a custom stylesheet for dialogs.\n\n:param server_port: HTTP server port, defaults to 8105\n:param stylesheet: defaults to built-in Robocorp stylesheet",
                "shortdoc": "The dialogs library can be initialized to a custom port and with a custom stylesheet for dialogs.",
                "tags": [],
                "matched": true
            }
        ],
        "keywords": [
            {
                "name": "Add Checkbox",
                "args": [
                    "label: str",
                    "element_id: str",
                    "options: str",
                    "default: str = None"
                ],
                "doc": "Add checkbox element\n\n:param label: check box element label\n:param element_id: check box element identifier\n:param options: values for the check box\n:param default: check box selected value, defaults to None\n\nExample:\n\n.. code-block:: robotframework\n\n    Create Form\n    Add Checkbox    label=Select your colors\n    ...             element_id=colors\n    ...             options=green,red,blue,yellow\n    ...             default=blue",
                "shortdoc": "Add checkbox element",
                "tags": [],
                "matched": true
            },
            {
                "name": "Add Dropdown",
                "args": [
                    "label: str",
                    "element_id: str",
                    "options: typing.Any",
                    "default: str = None"
                ],
                "doc": "Add dropdown element\n\n:param label: dropdown element label\n:param element_id: dropdown element id attribute\n:param options: values for the dropdown\n:param default: dropdown selected value, defaults to None\n\nExample:\n\n.. code-block:: robotframework\n\n    Create Form\n    Add Dropdown  label=Select task type\n    ...           element_id=tasktype\n    ...           options=buy,sell,rent\n    ...           default=buy",
                "shortdoc": "Add dropdown element",
                "tags": [],
                "matched": true
            },
            {
                "name": "Add File Input",
                "args": [
                    "label: str",
                    "element_id: str",
                    "name: str",
                    "filetypes: str",
                    "target_directory: str = None"
                ],
                "doc": "Add text input element\n\n:param label: input element label\n:param element_id: hidden element id attribute\n:param name: input element name attribute\n:param filetypes: accepted filetypes for the file upload\n:param target_directory: where to save uploaded files to\n\nRead more of the filetypes in the library documentation.\n\nExample:\n\n.. code-block:: robotframework\n\n    Create Form\n    Add File Input  label=Attachment\n    ...             element_id=attachment\n    ...             name=attachment\n    ...             filetypes=${EMPTY}         # Accept all files\n    ...             target_directory=${CURDIR}${/}output\n\n    Add File Input  label=Contract\n    ...             element_id=contract\n    ...             name=contract\n    ...             filetypes=application/pdf  # Accept only PDFs\n    ...             target_directory=${CURDIR}${/}output",
                "shortdoc": "Add text input element",
                "tags": [],
                "matched": true
            },
            {
                "name": "Add Hidden Input",
                "args": [
                    "name: str",
                    "value: str"
                ],
                "doc": "Add hidden input element\n\n:param name: input element name attribute\n:param value: input element value attribute\n\nExample:\n\n.. code-block:: robotframework\n\n    Create Form\n    ${uuid}   Evaluate  str(uuid.uuid4())\n    Add Hidden Input    form-id   ${uuid}",
                "shortdoc": "Add hidden input element",
                "tags": [],
                "matched": true
            },
            {
                "name": "Add Radio Buttons",
                "args": [
                    "element_id: str",
                    "options: str",
                    "default: str = None"
                ],
                "doc": "Add radio button element\n\n:param element_id: radio button element identifier\n:param options: values for the radio button\n:param default: radio button selected value, defaults to None\n\nExample:\n\n.. code-block:: robotframework\n\n    Create Form\n    Add Radio Button   element_id=drone  buttons=Jim,Robert  default=Robert",
                "shortdoc": "Add radio button element",
                "tags": [],
                "matched": true
            },
            {
                "name": "Add Submit",
                "args": [
                    "name: str",
                    "buttons: str"
                ],
                "doc": "Add submit element\n\n:param name: element name attribute\n:param buttons: list of buttons\n\nExample:\n\n.. code-block:: robotframework\n\n    Create Form\n    Add Submit    name=direction-to-go  buttons=left,right",
                "shortdoc": "Add submit element",
                "tags": [],
                "matched": true
            },
            {
                "name": "Add Text",
                "args": [
                    "value: str"
                ],
                "doc": "Add text paragraph element\n\n:param value: text for the element\n\nExample.\n\n.. code-block:: robotframework\n\n    Create Form\n    Add Text       ${form_guidance_text}",
                "shortdoc": "Add text paragraph element",
                "tags": [],
                "matched": true
            },
            {
                "name": "Add Text Input",
                "args": [
                    "label: str",
                    "name: str",
                    "value: str = None"
                ],
                "doc": "Add text input element\n\n:param label: input element label\n:param name: input element name attribute\n:param value: input element value attribute\n\nExample:\n\n.. code-block:: robotframework\n\n    Create Form\n    Add Text Input   what is your firstname ?  fname   value=Mika",
                "shortdoc": "Add text input element",
                "tags": [],
                "matched": true
            },
            {
                "name": "Add Textarea",
                "args": [
                    "name: str",
                    "rows: int = 5",
                    "cols: int = 40",
                    "default: str = None"
                ],
                "doc": "Add textarea element\n\n:param name: textarea element name\n:param rows: number of rows for the area, defaults to 5\n:param cols: numnber of columns for the area, defaults to 40\n:param default: prefilled text for the area, defaults to None\n\nExample:\n\n.. code-block:: robotframework\n\n    Create Form\n    Add Textarea       name=feedback  default=enter feedback here\n    Add Textarea       name=texts  rows=40   cols=80",
                "shortdoc": "Add textarea element",
                "tags": [],
                "matched": true
            },
            {
                "name": "Add Title",
                "args": [
                    "title: str"
                ],
                "doc": "Add h3 element into form\n\n:param title: text for the element\n\nExample:\n\n.. code-block:: robotframework\n\n    Create Form     # default form title will be \"Requesting response\"\n    Add Title       User Confirmation Form",
                "shortdoc": "Add h3 element into form",
                "tags": [],
                "matched": true
            },
            {
                "name": "Create Form",
                "args": [
                    "title: str = None"
                ],
                "doc": "Create new form\n\n:param title: form title, defaults to None\n\nExample:\n\n.. code-block:: robotframework\n\n    Create Form     # form title will be \"Requesting response\"\n    Create Form     title=User Confirmation Form",
                "shortdoc": "Create new form",
                "tags": [],
                "matched": true
            },
            {
                "name": "Request Response",
                "args": [
                    "formspec: str = None",
                    "window_width: int = 600",
                    "window_height: int = 1000"
                ],
                "doc": "Start server and show form. Waits for user response.\n\n:param formspec: form json specification file, defaults to None\n:param window_width: window width in pixels, defaults to 600\n:param window_height: window height in pixels, defaults to 1000\n:return: form response\n\nExample:\n\n.. code-block:: robotframework\n\n    Create Form    ${CURDIR}/${/}myform.json\n    &{response}    Request Response",
                "shortdoc": "Start server and show form. Waits for user response.",
                "tags": [],
                "matched": true
            }
        ],
        "all_tags": [],
        "contains_tags": false
    },
    "RPA.Email.Exchange": {
        "name": "RPA.Email.Exchange",
        "doc": "`Exchange` is a library for sending, reading, and deleting emails.\n`Exchange` is interfacing with Exchange Web Services (EWS).\n\nFor more information about server settings, see\n`this Microsoft support article <https://support.microsoft.com/en-us/office/server-settings-you-ll-need-from-your-email-provider-c82de912-adcc-4787-8283-45a1161f3cc3>`_.\n\n**Examples**\n\n**Robot Framework**\n\n.. code-block:: robotframework\n\n    *** Settings ***\n    Library     RPA.Email.Exchange\n    Task Setup  Authorize  username=${ACCOUNT}  password=${PASSWORD}\n\n    *** Variables ***\n    ${ACCOUNT}              ACCOUNT_NAME\n    ${PASSWORD}             ACCOUNT_PASSWORD\n    ${RECIPIENT_ADDRESS}    RECIPIENT\n    ${IMAGES}               myimage.png\n    ${ATTACHMENTS}          C:${/}files${/}mydocument.pdf\n\n    *** Tasks ***\n    Sending email\n        Send Message  recipients=${RECIPIENT_ADDRESS}\n        ...           subject=Exchange Message from RPA Robot\n        ...           body=<p>Exchange RPA Robot message body<br><img src='myimage.png'/></p>\n        ...           save=${TRUE}\n        ...           html=${TRUE}\n        ...           images=${IMAGES}\n        ...           cc=EMAIL_ADDRESS\n        ...           bcc=EMAIL_ADDRESS\n        ...           attachments=${ATTACHMENTS}\n\n**Python**\n\n.. code-block:: python\n\n    from RPA.Email.Exchange import Exchange\n\n    ex_account = \"ACCOUNT_NAME\"\n    ex_password = \"ACCOUNT_PASSWORD\"\n\n    mail = Exchange()\n    mail.authorize(username=ex_account, password=ex_password)\n    mail.send_message(\n        recipients=\"RECIPIENT\",\n        subject=\"Message from RPA Python\",\n        body=\"RPA Python message body\",\n    )",
        "version": "",
        "named_args": true,
        "scope": "GLOBAL",
        "generated": "2020-12-01 14:53:06",
        "inits": [],
        "keywords": [
            {
                "name": "Authorize",
                "args": [
                    "username: str",
                    "password: str",
                    "autodiscover: bool = True",
                    "access_type: str = DELEGATE",
                    "server: str = None",
                    "primary_smtp_address: str = None"
                ],
                "doc": "Connect to Exchange account\n\n:param username: account username\n:param password: account password\n:param autodiscover: use autodiscover or set it off\n:param accesstype: default \"DELEGATE\", other option \"IMPERSONATION\"\n:param server: required for configuration options\n:param primary_smtp_address: by default set to username, but can be\n    set to be different than username",
                "shortdoc": "Connect to Exchange account",
                "tags": [],
                "matched": true
            },
            {
                "name": "Create Folder",
                "args": [
                    "folder_name: str = None",
                    "parent_folder: str = None"
                ],
                "doc": "Create email folder\n\n:param folder_name: name for the new folder\n:param parent_folder: name for the parent folder, by default INBOX\n:return: True if operation was successful, False if not",
                "shortdoc": "Create email folder",
                "tags": [],
                "matched": true
            },
            {
                "name": "Delete Folder",
                "args": [
                    "folder_name: str = None",
                    "parent_folder: str = None"
                ],
                "doc": "Delete email folder\n\n:param folder_name: current folder name\n:param parent_folder: name for the parent folder, by default INBOX\n:return: True if operation was successful, False if not",
                "shortdoc": "Delete email folder",
                "tags": [],
                "matched": true
            },
            {
                "name": "Empty Folder",
                "args": [
                    "folder_name: str = None",
                    "parent_folder: str = None",
                    "delete_sub_folders: bool = False"
                ],
                "doc": "Empty email folder of all items\n\n:param folder_name: current folder name\n:param parent_folder: name for the parent folder, by default INBOX\n:param delete_sub_folders: delete sub folders or not, by default False\n:return: True if operation was successful, False if not",
                "shortdoc": "Empty email folder of all items",
                "tags": [],
                "matched": true
            },
            {
                "name": "List Messages",
                "args": [
                    "folder_name: str = None",
                    "count: int = 100"
                ],
                "doc": "List messages in the account inbox. Order by descending\nreceived time.\n\n:param count: number of messages to list",
                "shortdoc": "List messages in the account inbox. Order by descending received time.",
                "tags": [],
                "matched": true
            },
            {
                "name": "Move Messages",
                "args": [
                    "criterion: str = ",
                    "source: str = None",
                    "target: str = None",
                    "contains: bool = False"
                ],
                "doc": "Move message(s) from source folder to target folder\n\n:param criterion: move messages matching this criterion\n:param source: source folder\n:param target: target folder\n:param contains: if matching should be done using `contains` matching\n     and not `equals` matching, default `False` is means `equals` matching\n:return: boolean result of operation, True if 1+ items were moved else False\n\nCriterion examples:\n\n- subject:my message subject\n- body:something in body\n- sender:sender@domain.com",
                "shortdoc": "Move message(s) from source folder to target folder",
                "tags": [],
                "matched": true
            },
            {
                "name": "Rename Folder",
                "args": [
                    "oldname: str = None",
                    "newname: str = None",
                    "parent_folder: str = None"
                ],
                "doc": "Rename email folder\n\n:param oldname: current folder name\n:param newname: new name for the folder\n:param parent_folder: name for the parent folder, by default INBOX\n:return: True if operation was successful, False if not",
                "shortdoc": "Rename email folder",
                "tags": [],
                "matched": true
            },
            {
                "name": "Send Message",
                "args": [
                    "recipients: str",
                    "subject: str = ",
                    "body: str = ",
                    "attachments: str = None",
                    "html: bool = False",
                    "images: str = None",
                    "cc: str = None",
                    "bcc: str = None",
                    "save: bool = False"
                ],
                "doc": "Keyword for sending message through connected Exchange account.\n\n:param recipients: list of email addresses, defaults to []\n:param subject: message subject, defaults to \"\"\n:param body: message body, defaults to \"\"\n:param attachments: list of filepaths to attach, defaults to []\n:param html: if message content is in HTML, default `False`\n:param images: list of filepaths for inline use, defaults to []\n:param cc: list of email addresses, defaults to []\n:param bcc: list of email addresses, defaults to []\n:param save: is sent message saved to Sent messages folder or not,\n    defaults to False\n\nEmail addresses can be prefixed with ``ex:`` to indicate an Exchange\naccount address.\n\nRecipients is a `required` parameter.",
                "shortdoc": "Keyword for sending message through connected Exchange account.",
                "tags": [],
                "matched": true
            },
            {
                "name": "Wait For Message",
                "args": [
                    "criterion: str = ",
                    "timeout: float = 5.0",
                    "interval: float = 1.0",
                    "contains: bool = False"
                ],
                "doc": "Wait for email matching `criterion` to arrive into INBOX.\n\n:param criterion: wait for message matching criterion\n:param timeout: total time in seconds to wait for email, defaults to 5.0\n:param interval: time in seconds for new check, defaults to 1.0\n:param contains: if matching should be done using `contains` matching\n     and not `equals` matching, default `False` is means `equals` matching\n:return: list of messages",
                "shortdoc": "Wait for email matching `criterion` to arrive into INBOX.",
                "tags": [],
                "matched": true
            }
        ],
        "all_tags": [],
        "contains_tags": false
    },
    "RPA.Email.ImapSmtp": {
        "name": "RPA.Email.ImapSmtp",
        "doc": "`ImapSmtp` is a library for sending, reading, and deleting emails.\n`ImapSmtp` is interfacing with SMTP and IMAP protocols.\n\n**Troubleshooting**\n\n- Authentication error with Gmail - \"Application-specific password required\"\n    see. https://support.google.com/mail/answer/185833?hl=en\n\n**Examples**\n\n**Robot Framework**\n\nIt is highly recommended to secure your passwords and take care\nthat they are not stored in the version control by mistake.\nSee ``RPA.Robocloud.Secrets`` how to store RPA Secrets into Robocloud.\n\nWhen sending HTML content with IMG tags, the ``src`` filenames must match\nthe base image name given with the ``images`` parameter.\n\n.. code-block:: robotframework\n\n    *** Settings ***\n    Library     RPA.Email.ImapSmtp   smtp_server=smtp.gmail.com  port=587\n    Task Setup  Authorize  account=${GMAIL_ACCOUNT}  password=${GMAIL_PASSWORD}\n\n    *** Variables ***\n    ${GMAIL_ACCOUNT}        ACCOUNT_NAME\n    ${GMAIL_PASSWORD}       ACCOUNT_PASSWORD\n    ${RECIPIENT_ADDRESS}    RECIPIENT\n    ${BODY_IMG1}            ${IMAGEDIR}${/}approved.png\n    ${BODY_IMG2}            ${IMAGEDIR}${/}invoice.png\n    ${EMAIL_BODY}     <h1>Heading</h1><p>Status: <img src='approved.png' alt='approved image'/></p>\n    ...               <p>INVOICE: <img src='invoice.png' alt='invoice image'/></p>\n\n    *** Tasks ***\n    Sending email\n        Send Message  sender=${GMAIL_ACCOUNT}\n        ...           recipients=${RECIPIENT_ADDRESS}\n        ...           subject=Message from RPA Robot\n        ...           body=RPA Robot message body\n\n    Sending HTML Email With Image\n        [Documentation]     Sending email with HTML content and attachment\n        Send Message\n        ...                 sender=${GMAIL_ACCOUNT}\n        ...                 recipients=${RECIPIENT_ADDRESS}\n        ...                 subject=HTML email with body images (2) plus one attachment\n        ...                 body=${EMAIL_BODY}\n        ...                 html=${TRUE}\n        ...                 images=${BODY_IMG1}, ${BODY_IMG2}\n        ...                 attachments=example.png\n\n**Python**\n\n.. code-block:: python\n\n    from RPA.Email.ImapSmtp import ImapSmtp\n\n    gmail_account = \"ACCOUNT_NAME\"\n    gmail_password = \"ACCOUNT_PASSWORD\"\n    sender = gmail_account\n\n    mail = ImapSmtp(smtp_server=\"smtp.gmail.com\", port=587)\n    mail.authorize(account=gmail_account, password=gmail_password)\n    mail.send_message(\n        sender=gmail_account,\n        recipients=\"RECIPIENT\",\n        subject=\"Message from RPA Python\",\n        body=\"RPA Python message body\",\n    )",
        "version": "",
        "named_args": true,
        "scope": "GLOBAL",
        "generated": "2020-12-01 14:53:06",
        "inits": [
            {
                "name": "Init",
                "args": [
                    "smtp_server: str = None",
                    "smtp_port: int = 587",
                    "imap_server: str = None",
                    "imap_port: int = 993",
                    "account: str = None",
                    "password: str = None"
                ],
                "doc": "Initialize self.  See help(type(self)) for accurate signature.",
                "shortdoc": "Initialize self.  See help(type(self)) for accurate signature.",
                "tags": [],
                "matched": true
            }
        ],
        "keywords": [
            {
                "name": "Authorize",
                "args": [
                    "account: str = None",
                    "password: str = None",
                    "smtp_server: str = None",
                    "imap_server: str = None",
                    "smtp_port: int = None",
                    "imap_port: int = None"
                ],
                "doc": "Authorize user to SMTP and IMAP servers.\n\n:param account: user account as string, defaults to None\n:param password: user password as string, defaults to None\n:param smtp_server: SMTP server address, defaults to None\n:param imap_server: IMAP server address, defaults to None\n:param smtp_port: SMTP server port, defaults to None (587 for SMTP)\n:param imap_port: IMAP server port, defaults to None\n\nWill use separately set credentials or those given in keyword call.\n\nExample:\n\n.. code-block:: robotframework\n\n    Authorize    ${username}   ${password}  smtp_server=smtp.gmail.com  smtp_port=587",
                "shortdoc": "Authorize user to SMTP and IMAP servers.",
                "tags": [],
                "matched": true
            },
            {
                "name": "Authorize Imap",
                "args": [
                    "account: str = None",
                    "password: str = None",
                    "imap_server: str = None",
                    "imap_port: int = None"
                ],
                "doc": "Authorize to IMAP server.\n\n:param account: IMAP account name, defaults to None\n:param password: IMAP account password, defaults to None\n:param imap_server: IMAP server address, defaults to None\n:param imap_port: IMAP server port, defaults to None\n\nCan be called without giving any parameters if library\nhas been initialized with necessary information and/or\nkeyword ``Set Credentials`` has been called.\n\nExample:\n\n.. code-block:: robotframework\n\n    Authorize IMAP    ${username}   ${password}  imap.gmail.com  993",
                "shortdoc": "Authorize to IMAP server.",
                "tags": [],
                "matched": true
            },
            {
                "name": "Authorize Smtp",
                "args": [
                    "account: str = None",
                    "password: str = None",
                    "smtp_server: str = None",
                    "smtp_port: int = None"
                ],
                "doc": "Authorize to SMTP server.\n\n:param account: SMTP account name, defaults to None\n:param password: SMTP account password, defaults to None\n:param smtp_server: SMTP server address, defaults to None\n:param smtp_port: SMTP server port, defaults to None (587 for SMTP)\n\nCan be called without giving any parameters if library\nhas been initialized with necessary information and/or\nkeyword ``Set Credentials`` has been called.\n\nExample:\n\n.. code-block:: robotframework\n\n    Authorize SMTP    ${username}   ${password}  smtp.gmail.com  587",
                "shortdoc": "Authorize to SMTP server.",
                "tags": [],
                "matched": true
            },
            {
                "name": "Create Folder",
                "args": [
                    "folder_name: str = None"
                ],
                "doc": "Create email folder\n\n:param folder_name: name for the new folder\n:return: True if operation was successful, False if not\n\nExample:\n\n.. code-block:: robotframework\n\n    Create Folder   filtered",
                "shortdoc": "Create email folder",
                "tags": [],
                "matched": true
            },
            {
                "name": "Delete Folder",
                "args": [
                    "folder_name: str = None"
                ],
                "doc": "Delete email folder\n\n:param folder_name: current folder name\n:return: True if operation was successful, False if not\n\nExample:\n\n.. code-block:: robotframework\n\n    Delete Folder   filtered",
                "shortdoc": "Delete email folder",
                "tags": [],
                "matched": true
            },
            {
                "name": "Delete Message",
                "args": [
                    "criterion: str = "
                ],
                "doc": "Delete single message from server based on criterion.\n\n:param criterion: filter messages based on this, defaults to \"\"\n:return: True if success, False if not\n\nIf criterion does not return exactly 1 message then delete is not done.\n\nExample:\n\n.. code-block:: robotframework\n\n    Delete Message  SUBJECT \"Greetings RPA developer\"",
                "shortdoc": "Delete single message from server based on criterion.",
                "tags": [],
                "matched": true
            },
            {
                "name": "Delete Messages",
                "args": [
                    "criterion: str = "
                ],
                "doc": "Delete messages from server based on criterion.\n\n:param criterion: filter messages based on this, defaults to \"\"\n:return: True if success, False if not\n\nExample:\n\n.. code-block:: robotframework\n\n    Delete Messages  SUBJECT Greetings",
                "shortdoc": "Delete messages from server based on criterion.",
                "tags": [],
                "matched": true
            },
            {
                "name": "Flag Messages",
                "args": [
                    "criterion: str = None",
                    "unflag: bool = False"
                ],
                "doc": "Mark messages as `flagged`\n\n:param criterion: mark messages matching criterion\n:param unflag: to mark messages as not `flagged`\n:return: successful operations (int), matching messages (int)\n\nExample:\n\n.. code-block:: robotframework\n\n    ${flagged}  ${oftotal}    Flag Messages   SUBJECT rpa\n    ${unflagged}  ${oftotal}  Flag Messages   SUBJECT rpa  unflag=True",
                "shortdoc": "Mark messages as `flagged`",
                "tags": [],
                "matched": true
            },
            {
                "name": "Get Folder List",
                "args": [
                    "subdirectory: str = None",
                    "pattern: str = None"
                ],
                "doc": "Get list of folders on the server\n\n:param subdirectory: list subdirectories for this folder\n:param pattern: list folders matching this pattern\n:return: list of folders\n\nExample:\n\n.. code-block:: robotframework\n\n    @{folders}  Get Folder List\n    @{folders}  Get Folder List  pattern=important\n    @{folders}  Get Folder List  subdirectory=sub",
                "shortdoc": "Get list of folders on the server",
                "tags": [],
                "matched": true
            },
            {
                "name": "List Messages",
                "args": [
                    "criterion: str = "
                ],
                "doc": "Return list of messages matching criterion.\n\n:param criterion: list emails matching this, defaults to \"\"\n:return: list of messages or False\n\nExample:\n\n.. code-block:: robotframework\n\n    @{emails}  List Messages  SUBJECT \"rpa task\"\n    FOR  ${email}  IN  @{EMAILS}\n        Log  ${email}[Subject]\n        Log  ${email}[From]\n        Log  ${email}[Date]\n        Log  ${email}[Delivered-To]\n        Log  ${email}[Received]\n        Log  ${email}[Has-Attachments]\n    END",
                "shortdoc": "Return list of messages matching criterion.",
                "tags": [],
                "matched": true
            },
            {
                "name": "Mark As Read",
                "args": [
                    "criterion: str = None",
                    "unread: bool = False"
                ],
                "doc": "Mark messages as `read`\n\n:param criterion: mark messages matching criterion\n:param unread: to mark messages as not `read`\n:return: successful operations (int), matching messages (int)\n\nExample:\n\n.. code-block:: robotframework\n\n    ${read}  ${oftotal}  Mark As Read   SUBJECT rpa",
                "shortdoc": "Mark messages as `read`",
                "tags": [],
                "matched": true
            },
            {
                "name": "Mark As Unread",
                "args": [
                    "criterion: str = None"
                ],
                "doc": "Mark messages as not `read`\n\n:param criterion: mark messages matching criterion\n:return: successful operations (int), matching messages (int)\n\nExample:\n\n.. code-block:: robotframework\n\n    ${unread}  ${oftotal}  Mark As Unread   SUBJECT rpa",
                "shortdoc": "Mark messages as not `read`",
                "tags": [],
                "matched": true
            },
            {
                "name": "Rename Folder",
                "args": [
                    "oldname: str = None",
                    "newname: str = None",
                    "suppress_error: bool = False"
                ],
                "doc": "Rename email folder\n\n:param oldname: current folder name\n:param newname: new name for the folder\n:param suppress_error: to silence warning message, defaults to False\n:return: True if operation was successful, False if not\n\nExample:\n\n.. code-block:: robotframework\n\n    Rename Folder   subfolder   filtered",
                "shortdoc": "Rename email folder",
                "tags": [],
                "matched": true
            },
            {
                "name": "Save Attachment",
                "args": [
                    "message",
                    "target_folder",
                    "overwrite"
                ],
                "doc": "Save mail attachment into local folder\n\n:param message: message item\n:param target_folder: local folder for saving attachments to (needs to exist),\n    defaults to user's home directory if None\n:param overwrite: overwrite existing file is True, defaults to False\n\nExample:\n\n.. code-block:: robotframework\n\n    @{emails}  List Messages  SUBJECT \"rpa task\"\n    FOR  ${email}  IN  @{EMAILS}\n        Run Keyword If   ${email}[Has-Attachments] == True\n        ...              Save Attachment  ${email}  target_folder=${CURDIR}  overwrite=True\n    END",
                "shortdoc": "Save mail attachment into local folder",
                "tags": [],
                "matched": true
            },
            {
                "name": "Save Attachments",
                "args": [
                    "criterion: str = ",
                    "target_folder: str = None",
                    "overwrite: bool = False"
                ],
                "doc": "Save mail attachments into local folder.\n\n:param criterion: attachments are saved for mails matching this, defaults to \"\"\n:param target_folder: local folder for saving attachments to (needs to exist),\n    defaults to user's home directory if None\n:param overwrite: overwrite existing file is True, defaults to False\n:return: list of saved attachments or False\n\nExample:\n\n.. code-block:: robotframework\n\n    ${numsaved}  Save Attachments   SUBJECT \"rpa task\"\n    ...          target_folder=${CURDIR}${/}messages  overwrite=True",
                "shortdoc": "Save mail attachments into local folder.",
                "tags": [],
                "matched": true
            },
            {
                "name": "Save Messages",
                "args": [
                    "criterion: str = ",
                    "target_folder: str = None"
                ],
                "doc": "Save messages based on criteria and store them to target folder\nwith attachment files.\n\nDoes not save message if `target_folder` is not given.\n\n:param criterion: filter messages based on this, defaults to \"\"\n:param target_folder: path to folder where message are saved, defaults to None\n:return: True if success, False if not\n\nExample:\n\n.. code-block:: robotframework\n\n    Save Messages  SUBJECT Important message  target_folder=${USERDIR}${/}messages",
                "shortdoc": "Save messages based on criteria and store them to target folder with attachment files.",
                "tags": [],
                "matched": true
            },
            {
                "name": "Select Folder",
                "args": [
                    "folder_name: str = INBOX"
                ],
                "doc": "Select folder by name\n\n:param folder_name: name of the folder to select\n:return: message count in the selected folder\n\nReturns number of messages in the folder or\nexception if folder does not exist on the server.\n\nExample:\n\n.. code-block:: robotframework\n\n    Select Folder   subfolder",
                "shortdoc": "Select folder by name",
                "tags": [],
                "matched": true
            },
            {
                "name": "Send Message",
                "args": [
                    "sender: str",
                    "recipients: str",
                    "subject: str = ",
                    "body: str = ",
                    "attachments: str = None",
                    "html: bool = False",
                    "images: str = None"
                ],
                "doc": "Send SMTP email\n\n:param sender: who is sending, ie. 'from'\n:param recipients: who is receiving, ie. 'to'\n:param subject: mail subject field\n:param body: mail body content\n:param attachments: list of filepaths to attach, defaults to []\n:param html: if message content is in HTML, default `False`\n:param images: list of filepaths for inline use, defaults to []\n\nValid sender values:\n\n- First Lastname <address@domain>\n- address@domain\n\nExample:\n\n.. code-block:: robotframework\n\n    Send Message  sender@domain.com  recipient@domain.com\n    ...           subject=Greetings Software Robot Developer\n    ...           body=${email_body}\n    ...           attachments:${CURDIR}${/}report.pdf",
                "shortdoc": "Send SMTP email",
                "tags": [],
                "matched": true
            },
            {
                "name": "Send Smtp Hello",
                "args": [],
                "doc": "Send hello message to SMTP server.\n\nRequired step when creating SMTP connection.",
                "shortdoc": "Send hello message to SMTP server.",
                "tags": [],
                "matched": true
            },
            {
                "name": "Set Credentials",
                "args": [
                    "account: str = None",
                    "password: str = None"
                ],
                "doc": "Set credentials\n\n:param account: user account as string, defaults to None\n:param password: user password as string, defaults to None\n\nExample:\n\n.. code-block:: robotframework\n\n    Set Credentials   ${username}   ${password}\n    Authorize",
                "shortdoc": "Set credentials",
                "tags": [],
                "matched": true
            },
            {
                "name": "Unflag Messages",
                "args": [
                    "criterion: str = None"
                ],
                "doc": "Mark messages as not `flagged`\n\n:param criterion: mark messages matching criterion\n:return: successful operations (int), matching messages (int)\n\nExample:\n\n.. code-block:: robotframework\n\n    ${unflagged}  ${oftotal}  Unflag Messages   SUBJECT rpa",
                "shortdoc": "Mark messages as not `flagged`",
                "tags": [],
                "matched": true
            },
            {
                "name": "Wait For Message",
                "args": [
                    "criterion: str = ",
                    "timeout: float = 5.0",
                    "interval: float = 1.0"
                ],
                "doc": "Wait for email matching `criterion` to arrive into mailbox.\n\n:param criterion: message filter to wait for, defaults to \"\"\n:param timeout: total time in seconds to wait for email, defaults to 5.0\n:param interval: time in seconds for new check, defaults to 1.0\n:return: list of messages or False\n\nExample:\n\n.. code-block:: robotframework\n\n    @{emails}  Wait For Message  SUBJECT \"rpa task\"  timeout=300  interval=10",
                "shortdoc": "Wait for email matching `criterion` to arrive into mailbox.",
                "tags": [],
                "matched": true
            }
        ],
        "all_tags": [],
        "contains_tags": false
    },
    "RPA.Excel.Application": {
        "name": "RPA.Excel.Application",
        "doc": "`Excel.Application` is a library for controlling an Excel application.\n\n**Examples**\n\n**Robot Framework**\n\n.. code-block:: robotframework\n\n    *** Settings ***\n    Library             RPA.Excel.Application\n    Task Setup          Open Application\n    Task Teardown       Quit Application\n\n    *** Tasks ***\n    Manipulate Excel application\n        Open Workbook           workbook.xlsx\n        Set Active Worksheet    sheetname=new stuff\n        Write To Cells          row=1\n        ...                     column=1\n        ...                     value=my data\n        Save Excel\n\n    Run Excel Macro\n        Open Workbook   orders_with_macro.xlsm\n        Run Macro       Sheet1.CommandButton1_Click\n\n**Python**\n\n.. code-block:: python\n\n    from RPA.Excel.Application import Application\n\n    app = Application()\n\n    app.open_application()\n    app.open_workbook('workbook.xlsx')\n    app.set_active_worksheet(sheetname='new stuff')\n    app.write_to_cells(row=1, column=1, value='new data')\n    app.save_excel()\n    app.quit_application()",
        "version": "",
        "named_args": true,
        "scope": "GLOBAL",
        "generated": "2020-12-01 14:53:06",
        "inits": [],
        "keywords": [
            {
                "name": "Add New Sheet",
                "args": [
                    "sheetname: str",
                    "tabname: str = None",
                    "create_workbook: bool = True"
                ],
                "doc": "Add new worksheet to workbook. Workbook is created by default if\nit does not exist.\n\n:param sheetname: name for sheet\n:param tabname: name for tab, defaults to None\n:param create_workbook: create workbook if True, defaults to True\n:raises ValueError: error is raised if workbook does not exist and\n    `create_workbook` is False",
                "shortdoc": "Add new worksheet to workbook. Workbook is created by default if it does not exist.",
                "tags": [],
                "matched": true
            },
            {
                "name": "Add New Workbook",
                "args": [],
                "doc": "Adds new workbook for Excel application",
                "shortdoc": "Adds new workbook for Excel application",
                "tags": [],
                "matched": true
            },
            {
                "name": "Close Document",
                "args": [
                    "save_changes: bool = False"
                ],
                "doc": "Close the active document (if open).",
                "shortdoc": "Close the active document (if open).",
                "tags": [],
                "matched": true
            },
            {
                "name": "Find First Available Cell",
                "args": [
                    "worksheet: typing.Any = None",
                    "row: int = 1",
                    "column: int = 1"
                ],
                "doc": "Find first available free cell\n\n:param worksheet: worksheet to handle, defaults to active worksheet if None\n:param row: starting row for search, defaults to 1\n:param column: starting column for search, defaults to 1\n:return: tuple (row, column) or (None, None) if not found",
                "shortdoc": "Find first available free cell",
                "tags": [],
                "matched": true
            },
            {
                "name": "Find First Available Row",
                "args": [
                    "worksheet: typing.Any = None",
                    "row: int = 1",
                    "column: int = 1"
                ],
                "doc": "Find first available free row\n\n:param worksheet: worksheet to handle, defaults to active worksheet if None\n:param row: starting row for search, defaults to 1\n:param column: starting column for search, defaults to 1\n:return: row or None",
                "shortdoc": "Find first available free row",
                "tags": [],
                "matched": true
            },
            {
                "name": "Open Application",
                "args": [
                    "visible: bool = False",
                    "display_alerts: bool = False"
                ],
                "doc": "Open the Excel application.\n\n:param visible: show window after opening\n:param display_alerts: show alert popups",
                "shortdoc": "Open the Excel application.",
                "tags": [],
                "matched": true
            },
            {
                "name": "Open Workbook",
                "args": [
                    "filename: str"
                ],
                "doc": "Open Excel by filename\n\nBy default sets active worksheet to sheet number 1\n\n:param filename: path to filename",
                "shortdoc": "Open Excel by filename",
                "tags": [],
                "matched": true
            },
            {
                "name": "Quit Application",
                "args": [
                    "save_changes: bool = False"
                ],
                "doc": "Quit the application.",
                "shortdoc": "Quit the application.",
                "tags": [],
                "matched": true
            },
            {
                "name": "Read From Cells",
                "args": [
                    "worksheet: typing.Any = None",
                    "row: int = None",
                    "column: int = None"
                ],
                "doc": "Read value from cell.\n\n:param worksheet: worksheet to handle, defaults to active worksheet if None\n:param row: target row, defaults to None\n:param column: target row, defaults to None\n:raises ValueError: if cell is not given",
                "shortdoc": "Read value from cell.",
                "tags": [],
                "matched": true
            },
            {
                "name": "Run Macro",
                "args": [
                    "macro_name: str = None"
                ],
                "doc": "Run Excel macro with given name\n\n:param macro_name: macro to run",
                "shortdoc": "Run Excel macro with given name",
                "tags": [],
                "matched": true
            },
            {
                "name": "Save Excel",
                "args": [],
                "doc": "Saves Excel file",
                "shortdoc": "Saves Excel file",
                "tags": [],
                "matched": true
            },
            {
                "name": "Save Excel As",
                "args": [
                    "filename: str",
                    "autofit: bool = False"
                ],
                "doc": "Save Excel with name if workbook is open\n\n:param filename: where to save file\n:param autofit: autofit cell widths if True, defaults to False",
                "shortdoc": "Save Excel with name if workbook is open",
                "tags": [],
                "matched": true
            },
            {
                "name": "Set Active Worksheet",
                "args": [
                    "sheetname: str = None",
                    "sheetnumber: int = None"
                ],
                "doc": "Set active worksheet by either its sheet number or name\n\n:param sheetname: name of Excel sheet, defaults to None\n:param sheetnumber: index of Excel sheet, defaults to None",
                "shortdoc": "Set active worksheet by either its sheet number or name",
                "tags": [],
                "matched": true
            },
            {
                "name": "Write To Cells",
                "args": [
                    "worksheet: typing.Any = None",
                    "row: int = None",
                    "column: int = None",
                    "value: str = None",
                    "number_format: str = None",
                    "formula: str = None"
                ],
                "doc": "Write value, number_format and/or formula into cell.\n\n:param worksheet: worksheet to handle, defaults to active worksheet if None\n:param row: target row, defaults to None\n:param column: target row, defaults to None\n:param value: possible value to set, defaults to None\n:param number_format: possible number format to set, defaults to None\n:param formula: possible format to set, defaults to None\n:raises ValueError: if cell is not given",
                "shortdoc": "Write value, number_format and/or formula into cell.",
                "tags": [],
                "matched": true
            }
        ],
        "all_tags": [],
        "contains_tags": false
    },
    "RPA.Excel.Files": {
        "name": "RPA.Excel.Files",
        "doc": "The `Excel.Files` library can be used to read and write Excel\nfiles without the need to start the actual Excel application.\n\nIt supports both legacy .xls files and modern .xlsx files.\n\nNote: To run macros or load password protected worksheets,\nplease use the Excel application library.\n\n**Examples**\n\n**Robot Framework**\n\nA common use-case is to load an existing Excel file as a table,\nwhich can be iterated over later in a Robot Framework keyword or task:\n\n.. code-block:: robotframework\n\n    *** Settings ***\n    Library    RPA.Tables\n    Library    RPA.Excel.Files\n\n    *** Keywords ***\n    Read orders as table\n        Open workbook    ${ORDERS_FILE}\n        ${worksheet}=    Read worksheet   header=${TRUE}\n        ${orders}=       Create table     ${worksheet}\n        [Return]         ${orders}\n        [Teardown]       Close workbook\n\nProcessing all worksheets in the Excel file and checking row count:\n\n.. code-block:: robotframework\n\n    *** Settings ***\n    Library    RPA.Excel.Files\n\n    *** Variables ***\n    ${EXCEL_FILE}   /path/to/excel.xlsx\n\n    *** Tasks ***\n    Rows in the sheet\n        [Setup]      Open Workbook    ${EXCEL_FILE}\n        @{sheets}=   List Worksheets\n        FOR  ${sheet}  IN   @{sheets}\n            ${count}=  Get row count in the sheet   ${sheet}\n            Log   Worksheet '${sheet}' has ${count} rows\n        END\n\n    *** Keywords ***\n    Get row count in the sheet\n        [Arguments]      ${SHEET_NAME}\n        ${sheet}=        Read Worksheet   ${SHEET_NAME}\n        ${rows}=         Get Length  ${sheet}\n        [Return]         ${rows}\n\nCreating a new Excel file with a dictionary:\n\n.. code-block:: robotframework\n\n    *** Tasks ***\n    Creating new Excel\n        Create Workbook  my_new_excel.xlsx\n        FOR    ${index}    IN RANGE    20\n            &{row}=       Create Dictionary\n            ...           Row No   ${index}\n            ...           Amount   ${index * 25}\n            Append Rows to Worksheet  ${row}  header=${TRUE}\n        END\n        Save Workbook\n\nCreating a new Excel file with a list:\n\n.. code-block:: robotframework\n\n    *** Variables ***\n    @{heading}   Row No   Amount\n    @{rows}      ${heading}\n\n    *** Tasks ***\n    Creating new Excel\n        Create Workbook  my_new_excel.xlsx\n        FOR    ${index}    IN RANGE   1  20\n            @{row}=         Create List   ${index}   ${index * 25}\n            Append To List  ${rows}  ${row}\n        END\n        Append Rows to Worksheet  ${rows}\n        Save Workbook\n\n**Python**\n\nThe library can also be imported directly into Python.\n\n.. code-block:: python\n\n    from RPA.Excel.Files import Files\n\n    def read_excel_worksheet(path, worksheet):\n        lib = Files()\n        lib.open_workbook(path)\n        try:\n            return lib.read_worksheet(worksheet)\n        finally:\n            lib.close_workbook()",
        "version": "",
        "named_args": true,
        "scope": "GLOBAL",
        "generated": "2020-12-01 14:53:06",
        "inits": [],
        "keywords": [
            {
                "name": "Append Rows To Worksheet",
                "args": [
                    "content",
                    "name=None",
                    "header=False",
                    "start=None"
                ],
                "doc": "Append values to the end of the worksheet.\n\n:param content: Rows of values to append\n:param name:    Name of worksheet to append to\n:param header:  Set rows according to existing header row\n:param start:   Start of data, NOTE: Only required when headers is True",
                "shortdoc": "Append values to the end of the worksheet.",
                "tags": [],
                "matched": true
            },
            {
                "name": "Close Workbook",
                "args": [],
                "doc": "Close the active workbook.",
                "shortdoc": "Close the active workbook.",
                "tags": [],
                "matched": true
            },
            {
                "name": "Create Workbook",
                "args": [
                    "path=None",
                    "fmt=xlsx"
                ],
                "doc": "Create and open a new Excel workbook.\n\n:param path: Default save path for workbook\n:param fmt:  Format of workbook, i.e. xlsx or xls",
                "shortdoc": "Create and open a new Excel workbook.",
                "tags": [],
                "matched": true
            },
            {
                "name": "Create Worksheet",
                "args": [
                    "name",
                    "content=None",
                    "exist_ok=False"
                ],
                "doc": "Create a new worksheet in the current workbook.\n\n:param name:     Name of new worksheet\n:param content:  Optional content for worksheet\n:param exist_ok: If `False`, raise an error if name is already in use",
                "shortdoc": "Create a new worksheet in the current workbook.",
                "tags": [],
                "matched": true
            },
            {
                "name": "Find Empty Row",
                "args": [
                    "name=None"
                ],
                "doc": "Find the first empty row after existing content.\n\n:param name:    Name of worksheet",
                "shortdoc": "Find the first empty row after existing content.",
                "tags": [],
                "matched": true
            },
            {
                "name": "Get Active Worksheet",
                "args": [],
                "doc": "Get the name of the worksheet which is currently active.",
                "shortdoc": "Get the name of the worksheet which is currently active.",
                "tags": [],
                "matched": true
            },
            {
                "name": "Insert Image To Worksheet",
                "args": [
                    "row",
                    "column",
                    "path",
                    "scale=1.0",
                    "name=None"
                ],
                "doc": "Insert an image into the given cell.\n\n:param row:     Index of row to write\n:param column:  Name or index of column\n:param image:   Path to image file\n:param scale:   Scale of image\n:param name:    Name of worksheet",
                "shortdoc": "Insert an image into the given cell.",
                "tags": [],
                "matched": true
            },
            {
                "name": "List Worksheets",
                "args": [],
                "doc": "List all names of worksheets in the given workbook.",
                "shortdoc": "List all names of worksheets in the given workbook.",
                "tags": [],
                "matched": true
            },
            {
                "name": "Open Workbook",
                "args": [
                    "path"
                ],
                "doc": "Open an existing Excel workbook.\n\n:param path: path to Excel file",
                "shortdoc": "Open an existing Excel workbook.",
                "tags": [],
                "matched": true
            },
            {
                "name": "Read Worksheet",
                "args": [
                    "name=None",
                    "header=False",
                    "start=None"
                ],
                "doc": "Read the content of a worksheet into a list of dictionaries.\n\nEach key in the dictionary will be either values from the header row,\nor Excel-style column letters.\n\n:param name:   Name of worksheet to read\n:param header: If `True`, use the first row of the worksheet\n               as headers for the rest of the rows.",
                "shortdoc": "Read the content of a worksheet into a list of dictionaries.",
                "tags": [],
                "matched": true
            },
            {
                "name": "Read Worksheet As Table",
                "args": [
                    "name=None",
                    "header=False",
                    "trim=True",
                    "start=None"
                ],
                "doc": "Read the content of a worksheet into a Table container. Allows\nsorting/filtering/manipulating using the `RPA.Tables` library.\n\n:param name:   Name of worksheet to read\n:param header: If `True`, use the first row of the worksheet\n               as headers for the rest of the rows.\n:param trim:   Remove all empty rows from the end of the worksheet\n:param start:  Row index to start reading data from (1-indexed)",
                "shortdoc": "Read the content of a worksheet into a Table container. Allows sorting/filtering/manipulating using the `RPA.Tables` library.",
                "tags": [],
                "matched": true
            },
            {
                "name": "Remove Worksheet",
                "args": [
                    "name=None"
                ],
                "doc": "Remove a worksheet from the active workbook.\n\n:param name: Name of worksheet to remove",
                "shortdoc": "Remove a worksheet from the active workbook.",
                "tags": [],
                "matched": true
            },
            {
                "name": "Rename Worksheet",
                "args": [
                    "src_name",
                    "dst_name"
                ],
                "doc": "Rename an existing worksheet in the active workbook.\n\n:param src_name: Current name of worksheet\n:param dst_name: Future name of worksheet",
                "shortdoc": "Rename an existing worksheet in the active workbook.",
                "tags": [],
                "matched": true
            },
            {
                "name": "Save Workbook",
                "args": [
                    "path=None"
                ],
                "doc": "Save the active workbook.\n\n:param path: Path to save to. If not given, uses path given\n             when opened or created.",
                "shortdoc": "Save the active workbook.",
                "tags": [],
                "matched": true
            },
            {
                "name": "Set Active Worksheet",
                "args": [
                    "value"
                ],
                "doc": "Set the active worksheet.\n\n:param value: Index or name of worksheet",
                "shortdoc": "Set the active worksheet.",
                "tags": [],
                "matched": true
            },
            {
                "name": "Set Worksheet Value",
                "args": [
                    "row",
                    "column",
                    "value",
                    "name=None"
                ],
                "doc": "Set a cell value in the given worksheet.\n\n:param row:     Index of row to write, e.g. 3\n:param column:  Name or index of column, e.g. C or 7\n:param value:   New value of cell\n:param name:    Name of worksheet",
                "shortdoc": "Set a cell value in the given worksheet.",
                "tags": [],
                "matched": true
            },
            {
                "name": "Worksheet Exists",
                "args": [
                    "name"
                ],
                "doc": "Return True if worksheet with given name is in workbook.",
                "shortdoc": "Return True if worksheet with given name is in workbook.",
                "tags": [],
                "matched": true
            }
        ],
        "all_tags": [],
        "contains_tags": false
    },
    "RPA.FTP": {
        "name": "RPA.FTP",
        "doc": "`FTP` library can be used to access an FTP server,\nand interact with files.\n\nThe library is based on Python's built-in `ftplib`_.\n\n.. _ftplib: https://docs.python.org/3/library/ftplib.html\n\n**Examples**\n\n**Robot Framework**\n\n.. code-block:: robotframework\n\n    *** Settings ***\n    Library    RPA.FTP\n\n    *** Variables ***\n    ${HOST}       127.0.0.1\n    ${PORT}       27345\n    ${USER}       user\n    ${PASS}       12345\n\n    *** Tasks ***\n    List files on the server directory\n        Connect   ${HOST}  ${PORT}  ${USER}  ${PASS}\n        @{files}  List Files\n        FOR  ${file}  IN  @{files}\n            Log  ${file}\n        END\n\n**Python**\n\n.. code-block:: python\n\n    from RPA.FTP import FTP\n\n    library = FTP()\n    library.connect('127.0.0.1', 27345, 'user', '12345')\n    files = library.list_files()\n    for f in files:\n        print(f)",
        "version": "",
        "named_args": true,
        "scope": "GLOBAL",
        "generated": "2020-12-01 14:53:06",
        "inits": [],
        "keywords": [
            {
                "name": "Abort",
                "args": [],
                "doc": "Abort a file transfer in progress",
                "shortdoc": "Abort a file transfer in progress",
                "tags": [],
                "matched": true
            },
            {
                "name": "Close",
                "args": [],
                "doc": "Close connection to the server unilaterally",
                "shortdoc": "Close connection to the server unilaterally",
                "tags": [],
                "matched": true
            },
            {
                "name": "Connect",
                "args": [
                    "host: str",
                    "port: int = 21",
                    "user: str = None",
                    "password: str = None",
                    "tls: bool = False",
                    "transfer: str = passive"
                ],
                "doc": "Connect to FTP server\n\n:param host: address of the server\n:param port: port of the server, defaults to 21\n:param user: login name, defaults to None\n:param password: login password, defaults to None\n:param tls: connect using TLS support, defaults to False\n:param transfer: mode of the transfer, defaults to \"passive\"\n:raises AuthenticationException: on authentication error with the server",
                "shortdoc": "Connect to FTP server",
                "tags": [],
                "matched": true
            },
            {
                "name": "Cwd",
                "args": [
                    "dirname: str"
                ],
                "doc": "Change working directory on the server\n\n:param dirname: name of the directory",
                "shortdoc": "Change working directory on the server",
                "tags": [],
                "matched": true
            },
            {
                "name": "Delete",
                "args": [
                    "filepath: str"
                ],
                "doc": "Delete file on the server\n\n:param filepath: path to server file",
                "shortdoc": "Delete file on the server",
                "tags": [],
                "matched": true
            },
            {
                "name": "Download",
                "args": [
                    "remotefile: str",
                    "localfile: str = None"
                ],
                "doc": "Download file from FTP server\n\n:param remotefile: path to remote file on the server\n:param localfile: name of the downloaded file on the local filesystem,\n    if `None` will have same name as remote file",
                "shortdoc": "Download file from FTP server",
                "tags": [],
                "matched": true
            },
            {
                "name": "File Size",
                "args": [
                    "filepath: str"
                ],
                "doc": "Return byte size of the file on the server\n\n:param filepath: path to server file",
                "shortdoc": "Return byte size of the file on the server",
                "tags": [],
                "matched": true
            },
            {
                "name": "Get Welcome Message",
                "args": [],
                "doc": "Get server welcome message\n\n:return: welcome message",
                "shortdoc": "Get server welcome message",
                "tags": [],
                "matched": true
            },
            {
                "name": "List Files",
                "args": [
                    "dirname: str = None"
                ],
                "doc": "List files on the server directory\n\n:param dirname: name of the directory",
                "shortdoc": "List files on the server directory",
                "tags": [],
                "matched": true
            },
            {
                "name": "Mkd",
                "args": [
                    "dirname: str"
                ],
                "doc": "Create a new directory on the server\n\n:param dirname: name of the directory",
                "shortdoc": "Create a new directory on the server",
                "tags": [],
                "matched": true
            },
            {
                "name": "Pwd",
                "args": [],
                "doc": "Get current working directory on the server",
                "shortdoc": "Get current working directory on the server",
                "tags": [],
                "matched": true
            },
            {
                "name": "Quit",
                "args": [],
                "doc": "Send QUIT command to the server and close connection",
                "shortdoc": "Send QUIT command to the server and close connection",
                "tags": [],
                "matched": true
            },
            {
                "name": "Rename",
                "args": [
                    "fromname: str",
                    "toname: str"
                ],
                "doc": "Rename file on the server\n\n:param fromname: current name of the file\n:param toname: new name for the file",
                "shortdoc": "Rename file on the server",
                "tags": [],
                "matched": true
            },
            {
                "name": "Rmd",
                "args": [
                    "dirname: str"
                ],
                "doc": "Remove directory on the server\n\n:param dirname: name of the directory",
                "shortdoc": "Remove directory on the server",
                "tags": [],
                "matched": true
            },
            {
                "name": "Send Command",
                "args": [
                    "command: str"
                ],
                "doc": "Execute command on the server\n\nList of FTP commands:\nhttps://en.wikipedia.org/wiki/List_of_FTP_commands\n\n:param command: name of the command to send",
                "shortdoc": "Execute command on the server",
                "tags": [],
                "matched": true
            },
            {
                "name": "Set Ascii Mode",
                "args": [],
                "doc": "Set transfer mode to ASCII",
                "shortdoc": "Set transfer mode to ASCII",
                "tags": [],
                "matched": true
            },
            {
                "name": "Set Binary Mode",
                "args": [],
                "doc": "Set transfer mode to BINARY",
                "shortdoc": "Set transfer mode to BINARY",
                "tags": [],
                "matched": true
            },
            {
                "name": "Set Debug Level",
                "args": [
                    "level: int = 0"
                ],
                "doc": "Set debug level for the library\n\n:param level: integer value of debug level, defaults to 0\n\n0 - no debugging output\n1 - moderate amount of debugging\n2+ - higher amount of debugging",
                "shortdoc": "Set debug level for the library",
                "tags": [],
                "matched": true
            },
            {
                "name": "Upload",
                "args": [
                    "localfile: str",
                    "remotefile: str"
                ],
                "doc": "Upload file to FTP server\n\n:param localfile: path to file to upload\n:param remotefile: name of uploaded file in the server",
                "shortdoc": "Upload file to FTP server",
                "tags": [],
                "matched": true
            }
        ],
        "all_tags": [],
        "contains_tags": false
    },
    "RPA.FileSystem": {
        "name": "RPA.FileSystem",
        "doc": "The `FileSystem` library can be used to interact with files and directories\non the local computer. It can inspect and list files, remove and create them,\nread contents from files, and write data out.\n\nIt shadows the built-in `OperatingSystem` library but contains keywords\nwhich are more RPA-oriented.\n\n**Examples**\n\n**Robot Framework**\n\nThe library allows, for instance, iterating over files and inspecting them.\n\n.. code-block:: robotframework\n\n    *** Settings ***\n    Library    RPA.FileSystem\n\n    *** Keywords ***\n    Delete large files\n        ${files}=    List files in directory    archive/orders/\n        FOR    ${file}  IN  @{FILES}\n            Run keyword if    ${file.size} > 10**8    Remove file    ${file}\n        END\n\n    Read process output\n        Start external program\n        Wait until modified    process.log\n        ${output}=  Read file  process.log\n        [Return]    ${output}\n\n**Python**\n\nThe library can also be used inside Python.\n\n.. code-block:: python\n\n    from RPA.FileSystem import FileSystem\n\n    def move_to_archive():\n        lib = FileSystem()\n\n        matches = lib.find_files(\"**/*.xlsx\")\n        if matches:\n            lib.create_directory(\"archive\")\n            lib.move_files(matches, \"archive\")",
        "version": "",
        "named_args": true,
        "scope": "GLOBAL",
        "generated": "2020-12-01 14:53:06",
        "inits": [],
        "keywords": [
            {
                "name": "Absolute Path",
                "args": [
                    "path"
                ],
                "doc": "Returns the absolute path to a file, and resolves symlinks.\n\n:param path:    path that will be resolved\n:return:        absolute path to file",
                "shortdoc": "Returns the absolute path to a file, and resolves symlinks.",
                "tags": [],
                "matched": true
            },
            {
                "name": "Append To Binary File",
                "args": [
                    "path",
                    "content"
                ],
                "doc": "Appends binary content to the given file.\n\n:param path:        path to file to append to\n:param content:     content to append",
                "shortdoc": "Appends binary content to the given file.",
                "tags": [],
                "matched": true
            },
            {
                "name": "Append To File",
                "args": [
                    "path",
                    "content",
                    "encoding=utf-8"
                ],
                "doc": "Appends text to the given file.\n\n:param path:        path to file to append to\n:param content:     content to append\n:param encoding:    character encoding of appended content",
                "shortdoc": "Appends text to the given file.",
                "tags": [],
                "matched": true
            },
            {
                "name": "Change File Extension",
                "args": [
                    "path",
                    "extension"
                ],
                "doc": "Replaces file extension for file at given path.\n\n:param path:        path to file to rename\n:param extension:   new extension, e.g. .xlsx",
                "shortdoc": "Replaces file extension for file at given path.",
                "tags": [],
                "matched": true
            },
            {
                "name": "Copy Directory",
                "args": [
                    "source",
                    "destination"
                ],
                "doc": "Copy directory from source path to destination path.\n\n:param source:      path to source directory\n:param destination: path to copy destination",
                "shortdoc": "Copy directory from source path to destination path.",
                "tags": [],
                "matched": true
            },
            {
                "name": "Copy File",
                "args": [
                    "source",
                    "destination"
                ],
                "doc": "Copy a file from source path to destination path.\n\n:param source:      path to source file\n:param destination: path to copy destination",
                "shortdoc": "Copy a file from source path to destination path.",
                "tags": [],
                "matched": true
            },
            {
                "name": "Copy Files",
                "args": [
                    "sources",
                    "destination"
                ],
                "doc": "Copy multiple files to destination folder.\n\n:param sources:     list of source files\n:param destination: path to destination folder",
                "shortdoc": "Copy multiple files to destination folder.",
                "tags": [],
                "matched": true
            },
            {
                "name": "Create Binary File",
                "args": [
                    "path",
                    "content=None",
                    "overwrite=False"
                ],
                "doc": "Creates a new binary file, and writes content if any is given.\n\n:param path:        path to file to write\n:param content:     content to write to file (optional)\n:param overwrite:   replace destination file if it already exists",
                "shortdoc": "Creates a new binary file, and writes content if any is given.",
                "tags": [],
                "matched": true
            },
            {
                "name": "Create Directory",
                "args": [
                    "path",
                    "parents=False",
                    "exist_ok=True"
                ],
                "doc": "Creates a directory and (optionally) non-existing parent directories.\n\n:param path:        path to new directory\n:param parents:     create missing parent directories\n:param exist_ok:    continue without errors if directory already exists",
                "shortdoc": "Creates a directory and (optionally) non-existing parent directories.",
                "tags": [],
                "matched": true
            },
            {
                "name": "Create File",
                "args": [
                    "path",
                    "content=None",
                    "encoding=utf-8",
                    "overwrite=False"
                ],
                "doc": "Creates a new text file, and writes content if any is given.\n\n:param path:        path to file to write\n:param content:     content to write to file (optional)\n:param encoding:    character encoding of written content\n:param overwrite:   replace destination file if it already exists",
                "shortdoc": "Creates a new text file, and writes content if any is given.",
                "tags": [],
                "matched": true
            },
            {
                "name": "Does Directory Exist",
                "args": [
                    "path"
                ],
                "doc": "Returns True if the given directory exists, False if not.\n\n:param path:    path to inspected directory",
                "shortdoc": "Returns True if the given directory exists, False if not.",
                "tags": [],
                "matched": true
            },
            {
                "name": "Does Directory Not Exist",
                "args": [
                    "path"
                ],
                "doc": "Returns True if the directory does not exist, False if it does.\n\n:param path:    path to inspected directory",
                "shortdoc": "Returns True if the directory does not exist, False if it does.",
                "tags": [],
                "matched": true
            },
            {
                "name": "Does File Exist",
                "args": [
                    "path"
                ],
                "doc": "Returns True if the given file exists, False if not.\n\n:param path:    path to inspected file",
                "shortdoc": "Returns True if the given file exists, False if not.",
                "tags": [],
                "matched": true
            },
            {
                "name": "Does File Not Exist",
                "args": [
                    "path"
                ],
                "doc": "Returns True if the file does not exist, False if it does.\n\n:param path:    path to inspected file",
                "shortdoc": "Returns True if the file does not exist, False if it does.",
                "tags": [],
                "matched": true
            },
            {
                "name": "Empty Directory",
                "args": [
                    "path"
                ],
                "doc": "Removes all the files in the given directory.\n\n:param path:    directory to remove files from",
                "shortdoc": "Removes all the files in the given directory.",
                "tags": [],
                "matched": true
            },
            {
                "name": "Find Files",
                "args": [
                    "pattern",
                    "include_dirs=True",
                    "include_files=True"
                ],
                "doc": "Find files recursively according to a pattern.\n\n:param pattern:         search path in glob format pattern,\n                        e.g. *.xls or **/orders.txt\n:param include_dirs:    include directories in results\n:param include_files:   include files in results\n:return:                list of paths that match the pattern",
                "shortdoc": "Find files recursively according to a pattern.",
                "tags": [],
                "matched": true
            },
            {
                "name": "Get File Creation Date",
                "args": [
                    "path"
                ],
                "doc": "Returns the creation time in seconds.\nNote: Linux sets this whenever file metadata changes\n\n:param path:    path to file to inspect",
                "shortdoc": "Returns the creation time in seconds. Note: Linux sets this whenever file metadata changes",
                "tags": [],
                "matched": true
            },
            {
                "name": "Get File Extension",
                "args": [
                    "path"
                ],
                "doc": "Returns the suffix for the file.\n\n:param path:    path to file",
                "shortdoc": "Returns the suffix for the file.",
                "tags": [],
                "matched": true
            },
            {
                "name": "Get File Modified Date",
                "args": [
                    "path"
                ],
                "doc": "Returns the modified time in seconds.\n\n:param path:    path to file to inspect",
                "shortdoc": "Returns the modified time in seconds.",
                "tags": [],
                "matched": true
            },
            {
                "name": "Get File Name",
                "args": [
                    "path"
                ],
                "doc": "Returns only the filename portion of a path.\n\n:param path:    path to file",
                "shortdoc": "Returns only the filename portion of a path.",
                "tags": [],
                "matched": true
            },
            {
                "name": "Get File Size",
                "args": [
                    "path"
                ],
                "doc": "Returns the file size in bytes.\n\n:param path:    path to file to inspect",
                "shortdoc": "Returns the file size in bytes.",
                "tags": [],
                "matched": true
            },
            {
                "name": "Is Directory Empty",
                "args": [
                    "path=None"
                ],
                "doc": "Returns True if the given directory has no files or subdirectories.\n\n:param path:    path to inspected directory",
                "shortdoc": "Returns True if the given directory has no files or subdirectories.",
                "tags": [],
                "matched": true
            },
            {
                "name": "Is Directory Not Empty",
                "args": [
                    "path=None"
                ],
                "doc": "Returns True if the given directory has any files or subdirectories.\n\n:param path:    path to inspected directory",
                "shortdoc": "Returns True if the given directory has any files or subdirectories.",
                "tags": [],
                "matched": true
            },
            {
                "name": "Is File Empty",
                "args": [
                    "path"
                ],
                "doc": "Returns True if the given file has no content, i.e. has zero size.\n\n:param path:    path to inspected file",
                "shortdoc": "Returns True if the given file has no content, i.e. has zero size.",
                "tags": [],
                "matched": true
            },
            {
                "name": "Is File Not Empty",
                "args": [
                    "path"
                ],
                "doc": "Returns True if the given file has content, i.e. larger than zero size.\n\n:param path:    path to inspected file",
                "shortdoc": "Returns True if the given file has content, i.e. larger than zero size.",
                "tags": [],
                "matched": true
            },
            {
                "name": "Join Path",
                "args": [
                    "*parts"
                ],
                "doc": "Joins multiple parts of a path together.\n\n:param parts:  Components of the path, e.g. dir, subdir, filename.ext",
                "shortdoc": "Joins multiple parts of a path together.",
                "tags": [],
                "matched": true
            },
            {
                "name": "List Directories In Directory",
                "args": [
                    "path=None"
                ],
                "doc": "Lists all the directories in the given directory, relative to it.\n\n:param path:    base directory for search, defaults to current working dir",
                "shortdoc": "Lists all the directories in the given directory, relative to it.",
                "tags": [],
                "matched": true
            },
            {
                "name": "List Files In Directory",
                "args": [
                    "path=None"
                ],
                "doc": "Lists all the files in the given directory, relative to it.\n\n:param path:    base directory for search, defaults to current working dir",
                "shortdoc": "Lists all the files in the given directory, relative to it.",
                "tags": [],
                "matched": true
            },
            {
                "name": "Log Directory Tree",
                "args": [
                    "path=None"
                ],
                "doc": "Logs all the files in the directory recursively.\n\n:param path:    base directory to start from, defaults to current working dir",
                "shortdoc": "Logs all the files in the directory recursively.",
                "tags": [],
                "matched": true
            },
            {
                "name": "Move Directory",
                "args": [
                    "source",
                    "destination",
                    "overwrite=False"
                ],
                "doc": "Move a directory from source path to destination path.\n\n:param source:      source directory path for moving\n:param destination: path to move to\n:param overwrite:   replace destination directory if it already exists",
                "shortdoc": "Move a directory from source path to destination path.",
                "tags": [],
                "matched": true
            },
            {
                "name": "Move File",
                "args": [
                    "source",
                    "destination",
                    "overwrite=False"
                ],
                "doc": "Move a file from source path to destination path,\noptionally overwriting the destination.\n\n:param source:      source file path for moving\n:param destination: path to move to\n:param overwrite:   replace destination file if it already exists",
                "shortdoc": "Move a file from source path to destination path, optionally overwriting the destination.",
                "tags": [],
                "matched": true
            },
            {
                "name": "Move Files",
                "args": [
                    "sources",
                    "destination",
                    "overwrite=False"
                ],
                "doc": "Move multiple files to the destination folder.\n\n:param sources:     list of files to move\n:param destination: path to move destination\n:param overwrite:   replace destination files if they already exist",
                "shortdoc": "Move multiple files to the destination folder.",
                "tags": [],
                "matched": true
            },
            {
                "name": "Normalize Path",
                "args": [
                    "path"
                ],
                "doc": "Removes redundant separators or up-level references from path.\n\n:param path:    path that will be normalized\n:return:        path to file",
                "shortdoc": "Removes redundant separators or up-level references from path.",
                "tags": [],
                "matched": true
            },
            {
                "name": "Read Binary File",
                "args": [
                    "path"
                ],
                "doc": "Reads a file in binary mode and returns the content.\nDoes not attempt to decode the content in any way.\n\n:param path:        path to file to read",
                "shortdoc": "Reads a file in binary mode and returns the content. Does not attempt to decode the content in any way.",
                "tags": [],
                "matched": true
            },
            {
                "name": "Read File",
                "args": [
                    "path",
                    "encoding=utf-8"
                ],
                "doc": "Reads a file as text, with given `encoding`, and returns the content.\"\n\n:param path:        path to file to read\n:param encoding:    character encoding of file",
                "shortdoc": "Reads a file as text, with given `encoding`, and returns the content.\"",
                "tags": [],
                "matched": true
            },
            {
                "name": "Remove Directory",
                "args": [
                    "path",
                    "recursive=False"
                ],
                "doc": "Removes the given directory, and optionally everything it contains.\n\n:param path:        path to directory\n:param recursive:   remove all subdirectories and files",
                "shortdoc": "Removes the given directory, and optionally everything it contains.",
                "tags": [],
                "matched": true
            },
            {
                "name": "Remove File",
                "args": [
                    "path",
                    "missing_ok=True"
                ],
                "doc": "Removes the given file.\n\n:param path:        path to the file to remove\n:param missing_ok:  ignore non-existent file",
                "shortdoc": "Removes the given file.",
                "tags": [],
                "matched": true
            },
            {
                "name": "Remove Files",
                "args": [
                    "*paths",
                    "missing_ok=True"
                ],
                "doc": "Removes multiple files.\n\n:param paths:       paths to files to be removed\n:param missing_ok:  ignore non-existent files",
                "shortdoc": "Removes multiple files.",
                "tags": [],
                "matched": true
            },
            {
                "name": "Run Keyword If File Exists",
                "args": [
                    "path",
                    "keyword",
                    "*args"
                ],
                "doc": "If file exists at `path`, execute given keyword with arguments.\n\n:param path:    path to file to inspect\n:param keyword: Robot Framework keyword to execute\n:param args:    arguments to keyword\n\nExample:\n\n.. code:: robotframework\n\n    Run keyword if file exists    orders.xlsx    Process orders",
                "shortdoc": "If file exists at `path`, execute given keyword with arguments.",
                "tags": [],
                "matched": true
            },
            {
                "name": "Touch File",
                "args": [
                    "path"
                ],
                "doc": "Creates a file with no content, or if file already exists,\nupdates the modification and access times.\n\n:param path:        path to file which is touched",
                "shortdoc": "Creates a file with no content, or if file already exists, updates the modification and access times.",
                "tags": [],
                "matched": true
            },
            {
                "name": "Wait Until Created",
                "args": [
                    "path",
                    "timeout=5.0"
                ],
                "doc": "Poll path until it exists, or raise exception if timeout\nis reached.\n\n:param path:    path to poll\n:param timeout: time in seconds until keyword fails",
                "shortdoc": "Poll path until it exists, or raise exception if timeout is reached.",
                "tags": [],
                "matched": true
            },
            {
                "name": "Wait Until Modified",
                "args": [
                    "path",
                    "timeout=5.0"
                ],
                "doc": "Poll path until it has been modified after the keyword was called,\nor raise exception if timeout is reached.\n\n:param path:    path to poll\n:param timeout: time in seconds until keyword fails",
                "shortdoc": "Poll path until it has been modified after the keyword was called, or raise exception if timeout is reached.",
                "tags": [],
                "matched": true
            },
            {
                "name": "Wait Until Removed",
                "args": [
                    "path",
                    "timeout=5.0"
                ],
                "doc": "Poll path until it doesn't exist, or raise exception if timeout\nis reached.\n\n:param path:    path to poll\n:param timeout: time in seconds until keyword fails",
                "shortdoc": "Poll path until it doesn't exist, or raise exception if timeout is reached.",
                "tags": [],
                "matched": true
            }
        ],
        "all_tags": [],
        "contains_tags": false
    },
    "RPA.HTTP": {
        "name": "RPA.HTTP",
        "doc": "RPA Framework HTTP library that extends functionality of RequestsLibrary,\nfor more information see: https://github.com/MarketSquare/robotframework-requests",
        "version": "0.7.2",
        "named_args": true,
        "scope": "GLOBAL",
        "generated": "2020-12-01 14:53:06",
        "inits": [
            {
                "name": "Init",
                "args": [
                    "*args",
                    "**kwargs"
                ],
                "doc": "Initialize self.  See help(type(self)) for accurate signature.",
                "shortdoc": "Initialize self.  See help(type(self)) for accurate signature.",
                "tags": [],
                "matched": true
            }
        ],
        "keywords": [
            {
                "name": "Create Client Cert Session",
                "args": [
                    "alias",
                    "url",
                    "headers={}",
                    "cookies={}",
                    "client_certs=None",
                    "timeout=None",
                    "proxies=None",
                    "verify=False",
                    "debug=0",
                    "max_retries=3",
                    "backoff_factor=0.1",
                    "disable_warnings=0",
                    "retry_status_list=[]",
                    "retry_method_list=['HEAD', 'TRACE', 'DELETE', 'OPTIONS', 'GET', 'PUT']"
                ],
                "doc": "Create Session: create a HTTP session to a server\n\n``url`` Base url of the server\n\n``alias`` Robot Framework alias to identify the session\n\n``headers`` Dictionary of default headers\n\n``cookies`` Dictionary of cookies\n\n``client_certs`` ['client certificate', 'client key'] PEM files containing the client key and certificate\n\n``timeout`` Connection timeout\n\n``proxies`` Dictionary that contains proxy urls for HTTP and HTTPS communication\n\n``verify`` Whether the SSL cert will be verified. A CA_BUNDLE path can also be provided.\n         Defaults to False.\n\n``debug`` Enable http verbosity option more information\n        https://docs.python.org/2/library/httplib.html#httplib.HTTPConnection.set_debuglevel\n\n``max_retries`` Number of maximum retries each connection should attempt.\n                By default it will retry 3 times in case of connection errors only.\n                A 0 value will disable any kind of retries regardless of other retry settings.\n                In case the number of retries is reached a retry exception is raised.\n\n``disable_warnings`` Disable requests warning useful when you have large number of testcases\n\n``backoff_factor`` Introduces a delay time between retries that is longer after each retry.\n                   eg. if backoff_factor is set to 0.1\n                   the sleep between attemps will be: 0.0, 0.2, 0.4\n                   More info here: https://urllib3.readthedocs.io/en/latest/reference/urllib3.util.html\n\n``retry_method_list`` List of uppercased HTTP method verbs where retries are allowed.\n                      By default retries are allowed only on HTTP requests methods that are considered to be\n                      idempotent (multiple requests with the same parameters end with the same state).\n                      eg. set to ['POST', 'GET'] to retry only those kind of requests.\n\n``retry_status_list`` List of integer HTTP status codes that, if returned, a retry is attempted.\n                      eg. set to [502, 503] to retry requests if those status are returned.\n                      Note that max_retries must be greater than 0.",
                "shortdoc": "Create Session: create a HTTP session to a server",
                "tags": [],
                "matched": true
            },
            {
                "name": "Create Custom Session",
                "args": [
                    "alias",
                    "url",
                    "auth",
                    "headers={}",
                    "cookies={}",
                    "timeout=None",
                    "proxies=None",
                    "verify=False",
                    "debug=0",
                    "max_retries=3",
                    "backoff_factor=0.1",
                    "disable_warnings=0",
                    "retry_status_list=[]",
                    "retry_method_list=['HEAD', 'TRACE', 'DELETE', 'OPTIONS', 'GET', 'PUT']"
                ],
                "doc": "Create Session: create a HTTP session to a server\n\n``url`` Base url of the server\n\n``alias`` Robot Framework alias to identify the session\n\n``headers`` Dictionary of default headers\n\n``cookies`` Dictionary of cookies\n\n``auth`` A Custom Authentication object to be passed on to the requests library.\n        http://docs.python-requests.org/en/master/user/advanced/#custom-authentication\n\n``timeout`` Connection timeout\n\n``proxies`` Dictionary that contains proxy urls for HTTP and HTTPS communication\n\n``verify`` Whether the SSL cert will be verified. A CA_BUNDLE path can also be provided.\n         Defaults to False.\n\n``debug`` Enable http verbosity option more information\n        https://docs.python.org/2/library/httplib.html#httplib.HTTPConnection.set_debuglevel\n\n``max_retries`` Number of maximum retries each connection should attempt.\n                By default it will retry 3 times in case of connection errors only.\n                A 0 value will disable any kind of retries regardless of other retry settings.\n                In case the number of retries is reached a retry exception is raised.\n\n``disable_warnings`` Disable requests warning useful when you have large number of testcases\n\n``backoff_factor`` Introduces a delay time between retries that is longer after each retry.\n                   eg. if backoff_factor is set to 0.1\n                   the sleep between attemps will be: 0.0, 0.2, 0.4\n                   More info here: https://urllib3.readthedocs.io/en/latest/reference/urllib3.util.html\n\n``retry_method_list`` List of uppercased HTTP method verbs where retries are allowed.\n                      By default retries are allowed only on HTTP requests methods that are considered to be\n                      idempotent (multiple requests with the same parameters end with the same state).\n                      eg. set to ['POST', 'GET'] to retry only those kind of requests.\n\n``retry_status_list`` List of integer HTTP status codes that, if returned, a retry is attempted.\n                      eg. set to [502, 503] to retry requests if those status are returned.\n                      Note that max_retries must be greater than 0.",
                "shortdoc": "Create Session: create a HTTP session to a server",
                "tags": [],
                "matched": true
            },
            {
                "name": "Create Digest Session",
                "args": [
                    "alias",
                    "url",
                    "auth",
                    "headers={}",
                    "cookies={}",
                    "timeout=None",
                    "proxies=None",
                    "verify=False",
                    "debug=0",
                    "max_retries=3",
                    "backoff_factor=0.1",
                    "disable_warnings=0",
                    "retry_status_list=[]",
                    "retry_method_list=['HEAD', 'TRACE', 'DELETE', 'OPTIONS', 'GET', 'PUT']"
                ],
                "doc": "Create Session: create a HTTP session to a server\n\n``url`` Base url of the server\n\n``alias`` Robot Framework alias to identify the session\n\n``headers`` Dictionary of default headers\n\n``cookies`` Dictionary of cookies\n\n``auth`` ['DOMAIN', 'username', 'password'] for NTLM Authentication\n\n``timeout`` Connection timeout\n\n``proxies`` Dictionary that contains proxy urls for HTTP and HTTPS communication\n\n``verify`` Whether the SSL cert will be verified. A CA_BUNDLE path can also be provided.\n         Defaults to False.\n\n``debug`` Enable http verbosity option more information\n        https://docs.python.org/2/library/httplib.html#httplib.HTTPConnection.set_debuglevel\n\n``max_retries`` Number of maximum retries each connection should attempt.\n                By default it will retry 3 times in case of connection errors only.\n                A 0 value will disable any kind of retries regardless of other retry settings.\n                In case the number of retries is reached a retry exception is raised.\n\n``disable_warnings`` Disable requests warning useful when you have large number of testcases\n\n``backoff_factor`` Introduces a delay time between retries that is longer after each retry.\n                   eg. if backoff_factor is set to 0.1\n                   the sleep between attemps will be: 0.0, 0.2, 0.4\n                   More info here: https://urllib3.readthedocs.io/en/latest/reference/urllib3.util.html\n\n``retry_method_list`` List of uppercased HTTP method verbs where retries are allowed.\n                      By default retries are allowed only on HTTP requests methods that are considered to be\n                      idempotent (multiple requests with the same parameters end with the same state).\n                      eg. set to ['POST', 'GET'] to retry only those kind of requests.\n\n``retry_status_list`` List of integer HTTP status codes that, if returned, a retry is attempted.\n                      eg. set to [502, 503] to retry requests if those status are returned.\n                      Note that max_retries must be greater than 0.",
                "shortdoc": "Create Session: create a HTTP session to a server",
                "tags": [],
                "matched": true
            },
            {
                "name": "Create Ntlm Session",
                "args": [
                    "alias",
                    "url",
                    "auth",
                    "headers={}",
                    "cookies={}",
                    "timeout=None",
                    "proxies=None",
                    "verify=False",
                    "debug=0",
                    "max_retries=3",
                    "backoff_factor=0.1",
                    "disable_warnings=0",
                    "retry_status_list=[]",
                    "retry_method_list=['HEAD', 'TRACE', 'DELETE', 'OPTIONS', 'GET', 'PUT']"
                ],
                "doc": "Create Session: create a HTTP session to a server\n\n``url`` Base url of the server\n\n``alias`` Robot Framework alias to identify the session\n\n``headers`` Dictionary of default headers\n\n``cookies`` Dictionary of cookies\n\n``auth`` ['DOMAIN', 'username', 'password'] for NTLM Authentication\n\n``timeout`` Connection timeout\n\n``proxies`` Dictionary that contains proxy urls for HTTP and HTTPS communication\n\n``verify`` Whether the SSL cert will be verified. A CA_BUNDLE path can also be provided.\n         Defaults to False.\n\n``debug`` Enable http verbosity option more information\n        https://docs.python.org/2/library/httplib.html#httplib.HTTPConnection.set_debuglevel\n\n``max_retries`` Number of maximum retries each connection should attempt.\n                By default it will retry 3 times in case of connection errors only.\n                A 0 value will disable any kind of retries regardless of other retry settings.\n                In case the number of retries is reached a retry exception is raised.\n\n``disable_warnings`` Disable requests warning useful when you have large number of testcases\n\n``backoff_factor`` Introduces a delay time between retries that is longer after each retry.\n                   eg. if backoff_factor is set to 0.1\n                   the sleep between attemps will be: 0.0, 0.2, 0.4\n                   More info here: https://urllib3.readthedocs.io/en/latest/reference/urllib3.util.html\n\n``retry_method_list`` List of uppercased HTTP method verbs where retries are allowed.\n                      By default retries are allowed only on HTTP requests methods that are considered to be\n                      idempotent (multiple requests with the same parameters end with the same state).\n                      eg. set to ['POST', 'GET'] to retry only those kind of requests.\n\n``retry_status_list`` List of integer HTTP status codes that, if returned, a retry is attempted.\n                      eg. set to [502, 503] to retry requests if those status are returned.\n                      Note that max_retries must be greater than 0.",
                "shortdoc": "Create Session: create a HTTP session to a server",
                "tags": [],
                "matched": true
            },
            {
                "name": "Create Session",
                "args": [
                    "alias",
                    "url",
                    "headers={}",
                    "cookies={}",
                    "auth=None",
                    "timeout=None",
                    "proxies=None",
                    "verify=False",
                    "debug=0",
                    "max_retries=3",
                    "backoff_factor=0.1",
                    "disable_warnings=0",
                    "retry_status_list=[]",
                    "retry_method_list=['HEAD', 'TRACE', 'DELETE', 'OPTIONS', 'GET', 'PUT']"
                ],
                "doc": "Create Session: create a HTTP session to a server\n\n``alias`` Robot Framework alias to identify the session\n\n``url`` Base url of the server\n\n``headers`` Dictionary of default headers\n\n``cookies`` Dictionary of cookies\n\n``auth`` List of username & password for HTTP Basic Auth\n\n``timeout`` Connection timeout\n\n``proxies`` Dictionary that contains proxy urls for HTTP and HTTPS communication\n\n``verify`` Whether the SSL cert will be verified. A CA_BUNDLE path can also be provided.\n\n``debug`` Enable http verbosity option more information\n        https://docs.python.org/2/library/httplib.html#httplib.HTTPConnection.set_debuglevel\n\n``max_retries`` Number of maximum retries each connection should attempt.\n                By default it will retry 3 times in case of connection errors only.\n                A 0 value will disable any kind of retries regardless of other retry settings.\n                In case the number of retries is reached a retry exception is raised.\n\n``disable_warnings`` Disable requests warning useful when you have large number of testcases\n\n``backoff_factor`` Introduces a delay time between retries that is longer after each retry.\n                   eg. if backoff_factor is set to 0.1\n                   the sleep between attemps will be: 0.0, 0.2, 0.4\n                   More info here: https://urllib3.readthedocs.io/en/latest/reference/urllib3.util.html\n\n``retry_method_list`` List of uppercased HTTP method verbs where retries are allowed.\n                      By default retries are allowed only on HTTP requests methods that are considered to be\n                      idempotent (multiple requests with the same parameters end with the same state).\n                      eg. set to ['POST', 'GET'] to retry only those kind of requests.\n\n``retry_status_list`` List of integer HTTP status codes that, if returned, a retry is attempted.\n                      eg. set to [502, 503] to retry requests if those status are returned.\n                      Note that max_retries must be greater than 0.",
                "shortdoc": "Create Session: create a HTTP session to a server",
                "tags": [],
                "matched": true
            },
            {
                "name": "Delete All Sessions",
                "args": [],
                "doc": "Removes all the session objects",
                "shortdoc": "Removes all the session objects",
                "tags": [],
                "matched": true
            },
            {
                "name": "Delete Request",
                "args": [
                    "alias",
                    "uri",
                    "data=None",
                    "json=None",
                    "params=None",
                    "headers=None",
                    "allow_redirects=None",
                    "timeout=None"
                ],
                "doc": "Send a DELETE request on the session object found using the\ngiven `alias`\n\n``alias`` that will be used to identify the Session object in the cache\n\n``uri`` to send the DELETE request to\n\n``json`` a value that will be json encoded\n       and sent as request data if data is not specified\n\n``headers`` a dictionary of headers to use with the request\n\n``allow_redirects`` Boolean. Set to True if POST/PUT/DELETE redirect following is allowed.\n\n``timeout`` connection timeout",
                "shortdoc": "Send a DELETE request on the session object found using the given `alias`",
                "tags": [],
                "matched": true
            },
            {
                "name": "Download",
                "args": [
                    "url: str",
                    "target_file: str = None",
                    "binary: bool = True",
                    "verify: bool = True",
                    "force_new_session: bool = False",
                    "overwrite: bool = False"
                ],
                "doc": "An alias for the ``HTTP Get`` keyword.\n\nThe difference in use is that the URL is always downloaded based on\nthe URL path (even without ``target_file``). If there is a filename\nin the path, then that is used as ``target_file`` to save to. By default,\nthe filename will be \"downloaded.html\".\n\n``url`` target URL for GET request\n\n``target_file`` filepath to save request content, default ``None``\n\n``binary`` if file is saved as binary, default ``True``\n\n``verify`` if SSL verification should be done, default ``True``\n\n``force_new_session`` if new HTTP session should be created, default ``False``\n\n``overwrite`` used together with ``target_file``, if ``True`` will overwrite\nthe target file, default ``False``",
                "shortdoc": "An alias for the ``HTTP Get`` keyword.",
                "tags": [],
                "matched": true
            },
            {
                "name": "Get Current Session Alias",
                "args": [],
                "doc": "Get request session alias that was used with the ``HTTP Get`` keyword.\n\nReturn name of session alias.",
                "shortdoc": "Get request session alias that was used with the ``HTTP Get`` keyword.",
                "tags": [],
                "matched": true
            },
            {
                "name": "Get File For Streaming Upload",
                "args": [
                    "path"
                ],
                "doc": "Opens and returns a file descriptor of a specified file to be passed as ``data`` parameter\nto other requests keywords.\n\nThis allows streaming upload of large files without reading them into memory.\n\nFile descriptor is binary mode and read only. Requests keywords will automatically close the file,\nif used outside this library it's up to the caller to close it.",
                "shortdoc": "Opens and returns a file descriptor of a specified file to be passed as ``data`` parameter to other requests keywords.",
                "tags": [],
                "matched": true
            },
            {
                "name": "Get Request",
                "args": [
                    "alias",
                    "uri",
                    "headers=None",
                    "data=None",
                    "json=None",
                    "params=None",
                    "allow_redirects=None",
                    "timeout=None"
                ],
                "doc": "Send a GET request on the session object found using the\ngiven `alias`\n\n``alias`` that will be used to identify the Session object in the cache\n\n``uri`` to send the GET request to\n\n``params`` url parameters to append to the uri\n\n``headers`` a dictionary of headers to use with the request\n\n``data`` a dictionary of key-value pairs that will be urlencoded\n       and sent as GET data\n       or binary data that is sent as the raw body content\n\n``json`` a value that will be json encoded\n       and sent as GET data if data is not specified\n\n``allow_redirects`` Boolean. Set to True if POST/PUT/DELETE redirect following is allowed.\n\n``timeout`` connection timeout",
                "shortdoc": "Send a GET request on the session object found using the given `alias`",
                "tags": [],
                "matched": true
            },
            {
                "name": "Head Request",
                "args": [
                    "alias",
                    "uri",
                    "headers=None",
                    "allow_redirects=None",
                    "timeout=None"
                ],
                "doc": "Send a HEAD request on the session object found using the\ngiven `alias`\n\n``alias`` that will be used to identify the Session object in the cache\n\n``uri`` to send the HEAD request to\n\n``allow_redirects`` Boolean. Set to True if POST/PUT/DELETE redirect following is allowed.\n\n``headers`` a dictionary of headers to use with the request\n\n``timeout`` connection timeout",
                "shortdoc": "Send a HEAD request on the session object found using the given `alias`",
                "tags": [],
                "matched": true
            },
            {
                "name": "Http Get",
                "args": [
                    "url: str",
                    "target_file: str = None",
                    "binary: bool = True",
                    "verify: bool = True",
                    "force_new_session: bool = False",
                    "overwrite: bool = False"
                ],
                "doc": "A helper method for ``Get Request`` that will create a session, perform GET\nrequest, and store the target file, if set by the ``target_file`` parameter.\n\nThe old session will be used if the URL scheme and the host are the same as\npreviously, e.g., 'https://www.google.fi' part of the URL.\n\n``url`` target URL for GET request\n\n``target_file`` filepath to save request content, default ``None``\n\n``binary`` if file is saved as binary, default ``True``\n\n``verify`` if SSL verification should be done, default ``True``\n\n``force_new_session`` if new HTTP session should be created, default ``False``\n\n``overwrite`` used together with ``target_file``, if ``True`` will overwrite\nthe target file, default ``False``\n\nReturns request response.",
                "shortdoc": "A helper method for ``Get Request`` that will create a session, perform GET request, and store the target file, if set by the ``target_file`` parameter.",
                "tags": [],
                "matched": true
            },
            {
                "name": "Options Request",
                "args": [
                    "alias",
                    "uri",
                    "headers=None",
                    "allow_redirects=None",
                    "timeout=None"
                ],
                "doc": "Send an OPTIONS request on the session object found using the\ngiven `alias`\n\n``alias`` that will be used to identify the Session object in the cache\n\n``uri`` to send the OPTIONS request to\n\n``allow_redirects`` Boolean. Set to True if POST/PUT/DELETE redirect following is allowed.\n\n``headers`` a dictionary of headers to use with the request\n\n``timeout`` connection timeout",
                "shortdoc": "Send an OPTIONS request on the session object found using the given `alias`",
                "tags": [],
                "matched": true
            },
            {
                "name": "Patch Request",
                "args": [
                    "alias",
                    "uri",
                    "data=None",
                    "json=None",
                    "params=None",
                    "headers=None",
                    "files=None",
                    "allow_redirects=None",
                    "timeout=None"
                ],
                "doc": "Send a PATCH request on the session object found using the\ngiven `alias`\n\n``alias`` that will be used to identify the Session object in the cache\n\n``uri`` to send the PATCH request to\n\n``data`` a dictionary of key-value pairs that will be urlencoded\n       and sent as PATCH data\n       or binary data that is sent as the raw body content\n       or file descriptor retrieved by Get File For Streaming Upload\n\n``json`` a value that will be json encoded\n       and sent as PATCH data if data is not specified\n\n``headers`` a dictionary of headers to use with the request\n\n``files`` a dictionary of file names containing file data to PATCH to the server\n\n``allow_redirects`` Boolean. Set to True if POST/PUT/DELETE redirect following is allowed.\n\n``params`` url parameters to append to the uri\n\n``timeout`` connection timeout",
                "shortdoc": "Send a PATCH request on the session object found using the given `alias`",
                "tags": [],
                "matched": true
            },
            {
                "name": "Post Request",
                "args": [
                    "alias",
                    "uri",
                    "data=None",
                    "json=None",
                    "params=None",
                    "headers=None",
                    "files=None",
                    "allow_redirects=None",
                    "timeout=None"
                ],
                "doc": "Send a POST request on the session object found using the\ngiven `alias`\n\n``alias`` that will be used to identify the Session object in the cache\n\n``uri`` to send the POST request to\n\n``data`` a dictionary of key-value pairs that will be urlencoded\n       and sent as POST data\n       or binary data that is sent as the raw body content\n       or passed as such for multipart form data if ``files`` is also defined\n       or file descriptor retrieved by Get File For Streaming Upload\n\n``json`` a value that will be json encoded\n       and sent as POST data if files or data is not specified\n\n``params`` url parameters to append to the uri\n\n``headers`` a dictionary of headers to use with the request\n\n``files`` a dictionary of file names containing file data to POST to the server\n\n``allow_redirects`` Boolean. Set to True if POST/PUT/DELETE redirect following is allowed.\n\n``timeout`` connection timeout",
                "shortdoc": "Send a POST request on the session object found using the given `alias`",
                "tags": [],
                "matched": true
            },
            {
                "name": "Put Request",
                "args": [
                    "alias",
                    "uri",
                    "data=None",
                    "json=None",
                    "params=None",
                    "files=None",
                    "headers=None",
                    "allow_redirects=None",
                    "timeout=None"
                ],
                "doc": "Send a PUT request on the session object found using the\ngiven `alias`\n\n``alias`` that will be used to identify the Session object in the cache\n\n``uri`` to send the PUT request to\n\n``data`` a dictionary of key-value pairs that will be urlencoded\n       and sent as PUT data\n       or binary data that is sent as the raw body content\n       or file descriptor retrieved by Get File For Streaming Upload\n\n``json`` a value that will be json encoded\n       and sent as PUT data if data is not specified\n\n``headers`` a dictionary of headers to use with the request\n\n``allow_redirects`` Boolean. Set to True if POST/PUT/DELETE redirect following is allowed.\n\n``params`` url parameters to append to the uri\n\n``timeout`` connection timeout",
                "shortdoc": "Send a PUT request on the session object found using the given `alias`",
                "tags": [],
                "matched": true
            },
            {
                "name": "Request Should Be Successful",
                "args": [
                    "response"
                ],
                "doc": "Fails if response status code is a client or server error (4xx, 5xx).\n\nThe ``response`` is the output of other requests keywords like ``Get Request``.\n\nIn case of failure an HTTPError will be automatically raised.",
                "shortdoc": "Fails if response status code is a client or server error (4xx, 5xx).",
                "tags": [],
                "matched": true
            },
            {
                "name": "Session Exists",
                "args": [
                    "alias"
                ],
                "doc": "Return True if the session has been already created\n\n``alias`` that has been used to identify the Session object in the cache",
                "shortdoc": "Return True if the session has been already created",
                "tags": [],
                "matched": true
            },
            {
                "name": "Status Should Be",
                "args": [
                    "expected_status",
                    "response",
                    "msg=None"
                ],
                "doc": "Fails if response status code is different than the expected.\n\n``expected_status`` could be the code number as an integer or as string.\nBut it could also be a named status code like 'ok', 'created', 'accepted' or\n'bad request', 'not found' etc.\n\nThe ``response`` is the output of other requests keywords like ``Get Request``.\n\nA custom message ``msg`` can be added to work like built in keywords.",
                "shortdoc": "Fails if response status code is different than the expected.",
                "tags": [],
                "matched": true
            },
            {
                "name": "To Json",
                "args": [
                    "content",
                    "pretty_print=False"
                ],
                "doc": "Convert a string to a JSON object\n\n``content`` String content to convert into JSON\n\n``pretty_print`` If defined, will output JSON is pretty print format",
                "shortdoc": "Convert a string to a JSON object",
                "tags": [],
                "matched": true
            },
            {
                "name": "Update Session",
                "args": [
                    "alias",
                    "headers=None",
                    "cookies=None"
                ],
                "doc": "Update Session Headers: update a HTTP Session Headers\n\n``alias`` Robot Framework alias to identify the session\n\n``headers`` Dictionary of headers merge into session",
                "shortdoc": "Update Session Headers: update a HTTP Session Headers",
                "tags": [],
                "matched": true
            }
        ],
        "all_tags": [],
        "contains_tags": false
    },
    "RPA.Images": {
        "name": "RPA.Images",
        "doc": "`Images` is a library for general image manipulation.\nFor image-based desktop automation, use the ``RPA.Desktop`` library.\n\n**Coordinates**\n\nThe coordinates used in the library are pairs of x and y values that\nrepresent pixels. The upper left corner of the image or screen\nis (0, 0). The x-coordinate increases towards the right, and the y-coordinate\nincreases towards the bottom.\n\nRegions are represented as tuples of (left, top, right, bottom). For example,\na 400 by 200-pixel region in the upper left corner would be (0, 0, 400, 200).\n\n**Template matching**\n\nTemplate matching refers to an operation where the (potential) location of\na smaller image is searched from a larger image. It can be used for verifying\ncertain conditions or locating UI elements for desktop or web automation.\n\n**Requirements**\n\nThe default installation depends on `Pillow <https://python-pillow.org/>`_\nlibrary, which is used for general image manipulation operations.\n\nFor more robust and faster template matching, the library can use a combination\nof `NumPy <https://numpy.org/>`_ and `OpenCV <https://opencv.org/>`_.\nThey can be installed by opting in to the `cv` dependency:\n\n``pip install rpaframework[cv]``\n\n**Examples**\n\n**Robot Framework**\n\nThe `Images` library can be imported and used directly in Robot Framework,\nfor instance, for capturing screenshots or verifying something on the screen.\n\nDesktop automation based on images should be done using the corresponding\ndesktop library, i.e. ``RPA.Desktop``.\n\n.. code-block:: robotframework\n\n    *** Settings ***\n    Library    RPA.Images\n\n    *** Keywords ***\n    Should show success\n        [Documentation]    Raises ImageNotFoundError if success image is not on screen\n        Find template on screen    ${CURDIR}${/}success.png\n\n    Save screenshot to results\n        [Documentation]    Saves screenshot of desktop with unique name\n        ${timestamp}=      Get current date    result_format=%H%M%S\n        Take screenshot    filename=${OUTPUT_DIR}${/}desktop_${timestamp}.png\n\n**Python**\n\n.. code-block:: python\n\n    from RPA.Images import Images\n\n    def draw_matches_on_desktop(template):\n        lib = Images()\n        screenshot = lib.take_screenshot()\n\n        matches = lib.find_template_in_image(screenshot, template)\n        for match in matches:\n            lib.show_region_in_image(screenshot, match)\n\n        screenshot.save(\"matches.png\")",
        "version": "",
        "named_args": true,
        "scope": "GLOBAL",
        "generated": "2020-12-01 14:53:06",
        "inits": [],
        "keywords": [
            {
                "name": "Crop Image",
                "args": [
                    "image",
                    "region",
                    "filename=None"
                ],
                "doc": "Crop an existing image.\n\n:param image:       Image to crop\n:param region:      Region to crop image to\n:param filename:    Save cropped image to filename",
                "shortdoc": "Crop an existing image.",
                "tags": [],
                "matched": true
            },
            {
                "name": "Find Template In Image",
                "args": [
                    "image",
                    "template",
                    "region=None",
                    "limit=None",
                    "tolerance=None"
                ],
                "doc": "*DEPRECATED* Use keyword `Find` from library `RPA.Recognition` instead\nAttempt to find the template from the given image.\n\n:param image:       Path to image or Image instance, used to search from\n:param template:    Path to image or Image instance, used to search with\n:param limit:       Limit returned results to maximum of `limit`.\n:param region:      Area to search from. Can speed up search significantly.\n:param tolerance:   Tolerance for matching, value between 0.1 and 1.0\n:return:            List of matching regions\n:raises ImageNotFoundError: No match was found",
                "shortdoc": "*DEPRECATED* Use keyword `Find` from library `RPA.Recognition` instead Attempt to find the template from the given image.",
                "tags": [],
                "matched": true
            },
            {
                "name": "Find Template On Screen",
                "args": [
                    "template",
                    "**kwargs"
                ],
                "doc": "*DEPRECATED!!* use `RPA.Desktop.Find Element` instead\nAttempt to find the template image from the current desktop.\nFor argument descriptions, see ``find_template_in_image()``",
                "shortdoc": "*DEPRECATED!!* use `RPA.Desktop.Find Element` instead Attempt to find the template image from the current desktop. For argument descriptions, see ``find_template_in_image()``",
                "tags": [],
                "matched": true
            },
            {
                "name": "Get Pixel Color In Image",
                "args": [
                    "image",
                    "point"
                ],
                "doc": "Get the RGB value of a pixel in the image.\n\n:param image:   image to get pixel from\n:param point:   coordinates for pixel or Point object",
                "shortdoc": "Get the RGB value of a pixel in the image.",
                "tags": [],
                "matched": true
            },
            {
                "name": "Get Pixel Color On Screen",
                "args": [
                    "point"
                ],
                "doc": "Get the RGB value of a pixel currently on screen.\n\n:param point:   coordinates for pixel or Point object",
                "shortdoc": "Get the RGB value of a pixel currently on screen.",
                "tags": [],
                "matched": true
            },
            {
                "name": "Show Region In Image",
                "args": [
                    "image",
                    "region",
                    "color=red",
                    "width=5"
                ],
                "doc": "Draw a rectangle onto the image around the given region.\n\n:param image:   image to draw onto\n:param region:  coordinates for region or Region object\n:param color:   color of rectangle\n:param width:   line width of rectangle",
                "shortdoc": "Draw a rectangle onto the image around the given region.",
                "tags": [],
                "matched": true
            },
            {
                "name": "Show Region On Screen",
                "args": [
                    "region",
                    "color=red",
                    "width=5"
                ],
                "doc": "Draw a rectangle around the given region on the current desktop.\n\n:param region:  coordinates for region or Region object\n:param color:   color of rectangle\n:param width:   line width of rectangle",
                "shortdoc": "Draw a rectangle around the given region on the current desktop.",
                "tags": [],
                "matched": true
            },
            {
                "name": "Take Screenshot",
                "args": [
                    "filename=None",
                    "region=None"
                ],
                "doc": "*DEPRECATED* Use keyword `RPA.Desktop.Take Screenshot` instead\nTake a screenshot of the current desktop.\n\n:param filename:    Save screenshot to filename\n:param region:      Region to crop screenshot to",
                "shortdoc": "*DEPRECATED* Use keyword `RPA.Desktop.Take Screenshot` instead Take a screenshot of the current desktop.",
                "tags": [],
                "matched": true
            },
            {
                "name": "Wait Template On Screen",
                "args": [
                    "template",
                    "timeout=5",
                    "**kwargs"
                ],
                "doc": "*DEPRECATED!!* use `RPA.Desktop.Wait For Element` instead\nWait for template image to appear on current desktop.\nFor further argument descriptions, see ``find_template_in_image()``\n\n:param timeout: Time to wait for template (in seconds)",
                "shortdoc": "*DEPRECATED!!* use `RPA.Desktop.Wait For Element` instead Wait for template image to appear on current desktop. For further argument descriptions, see ``find_template_in_image()``",
                "tags": [],
                "matched": true
            }
        ],
        "all_tags": [],
        "contains_tags": false
    },
    "RPA.JSON": {
        "name": "RPA.JSON",
        "doc": "`JSON` is a library for manipulating `JSON`_ objects.\nLocating specific elements in the structure is done using `JSONPath`_.\n\n.. _JSON: http://json.org/\n.. _JSONPath: http://goessner.net/articles/JsonPath/",
        "version": "",
        "named_args": true,
        "scope": "GLOBAL",
        "generated": "2020-12-01 14:53:06",
        "inits": [],
        "keywords": [
            {
                "name": "Add to JSON",
                "args": [
                    "doc: typing.Any",
                    "expr: str",
                    "value: str"
                ],
                "doc": "Add items into a JSON object.\n\n:param doc: json as a dictionary object\n:param expr: jsonpath expression\n:param value: list to append into json or dictionary to update into json\n:return: json as a dictionary object",
                "shortdoc": "Add items into a JSON object.",
                "tags": [],
                "matched": true
            },
            {
                "name": "Convert JSON to String",
                "args": [
                    "doc: typing.Any"
                ],
                "doc": "Convert JSON object to a string.\n\n:param doc: json as a dictionary object\n:return: json as a string",
                "shortdoc": "Convert JSON object to a string.",
                "tags": [],
                "matched": true
            },
            {
                "name": "Convert String to JSON",
                "args": [
                    "doc: str"
                ],
                "doc": "Convert a string to a JSON object.\n\n:param doc: json string\n:return: json as a dictionary object",
                "shortdoc": "Convert a string to a JSON object.",
                "tags": [],
                "matched": true
            },
            {
                "name": "Delete from JSON",
                "args": [
                    "doc: typing.Any",
                    "expr: str"
                ],
                "doc": "Delete item from a JSON object.\n\n:param doc: json as a dictionary object or a string\n:param expr: jsonpath expression\n:return: json as a dictionary object",
                "shortdoc": "Delete item from a JSON object.",
                "tags": [],
                "matched": true
            },
            {
                "name": "Get value from JSON",
                "args": [
                    "doc: typing.Any",
                    "expr: str"
                ],
                "doc": "Get a value from a JSON object.\n\n:param doc: json as a dictionary object or a string\n:param expr: jsonpath expression\n:raises ValueError: if expression matches more than one item\n:return: matching item",
                "shortdoc": "Get a value from a JSON object.",
                "tags": [],
                "matched": true
            },
            {
                "name": "Get values from JSON",
                "args": [
                    "doc: typing.Any",
                    "expr: str"
                ],
                "doc": "Get values from a JSON object.\n\n:param doc: json as a dictionary object or a string\n:param expr: jsonpath expression\n:return: list of matching values",
                "shortdoc": "Get values from a JSON object.",
                "tags": [],
                "matched": true
            },
            {
                "name": "Load JSON from file",
                "args": [
                    "filename: str"
                ],
                "doc": "Load JSON data from a file.\n\n:param filename: path to file\n:return: json as a dictionary object",
                "shortdoc": "Load JSON data from a file.",
                "tags": [],
                "matched": true
            },
            {
                "name": "Save JSON to file",
                "args": [
                    "doc: typing.Any",
                    "filename: str"
                ],
                "doc": "Save JSON object into a file.\n\n:param doc: json as a dictionary object or a string\n:param filename: path to file",
                "shortdoc": "Save JSON object into a file.",
                "tags": [],
                "matched": true
            },
            {
                "name": "Update value to JSON",
                "args": [
                    "doc: typing.Any",
                    "expr: str",
                    "value: str"
                ],
                "doc": "Update value in a JSON object.\n\n:param doc: json as a dictionary object or a string\n:param expr: jsonpath expression\n:param value: new value for the matching item\n:return: json as a dictionary object",
                "shortdoc": "Update value in a JSON object.",
                "tags": [],
                "matched": true
            }
        ],
        "all_tags": [],
        "contains_tags": false
    },
    "RPA.Netsuite": {
        "name": "RPA.Netsuite",
        "doc": "`Netsuite` is a library for accessing Netsuite using NetSuite SOAP web service SuiteTalk.\nThe library extends the `netsuitesdk library`_.\n\nMore information available at `NetSuite SOAP webservice SuiteTalk`_.\n\n.. _netsuitesdk library:\n    https://github.com/fylein/netsuite-sdk-py\n\n.. _NetSuite SOAP webservice SuiteTalk:\n    http://www.netsuite.com/portal/platform/developer/suitetalk.shtml\n\n**Examples**\n\n**Robot Framework**\n\n.. code-block:: robotframework\n\n    *** Settings ***\n    Library     RPA.Netsuite\n    Library     RPA.Excel.Files\n    Library     RPA.Tables\n    Task Setup  Authorize Netsuite\n\n    *** Tasks ***\n    Get data from Netsuite and Store into Excel files\n        ${accounts}=        Get Accounts   account_type=_expense\n        ${accounts}=        Create table    ${accounts}\n        Create Workbook\n        Append Rows To Worksheet  ${accounts}\n        Save Workbook       netsuite_accounts.xlsx\n        Close Workbook\n        ${bills}=           Get Vendor Bills\n        ${bills}=           Create table    ${bills}\n        Create Workbook\n        Append Rows To Worksheet  ${bills}\n        Save Workbook       netsuite_bills.xlsx\n        Close Workbook\n\n\n    *** Keywords ***\n    Authorize Netsuite\n        ${secrets}=     Get Secret   netsuite\n        Connect\n        ...        account=${secrets}[ACCOUNT]\n        ...        consumer_key=${secrets}[CONSUMER_KEY]\n        ...        consumer_secret=${secrets}[CONSUMER_KEY]\n        ...        token_key=${secrets}[CONSUMER_SECRET]\n        ...        token_secret=${secrets}[TOKEN_KEY]\n\n**Python**\n\n.. code-block:: python\n\n    from RPA.Netsuite import Netsuite\n\n    ns = Netsuite()\n    ns.connect()\n    accounts = ns.get_accounts()\n    currencies = ns.get_currencies()",
        "version": "",
        "named_args": true,
        "scope": "GLOBAL",
        "generated": "2020-12-01 14:53:06",
        "inits": [],
        "keywords": [
            {
                "name": "Connect",
                "args": [
                    "account: str = None",
                    "consumer_key: str = None",
                    "consumer_secret: str = None",
                    "token_key: str = None",
                    "token_secret: str = None"
                ],
                "doc": "Connect to Netsuite with credentials from environment\nvariables.\n\nParameters are not logged into Robot Framework log.\n\n:param account: parameter or environment variable `NS_ACCOUNT`\n:param consumer_key:  parameter or environment variable `NS_CONSUMER_KEY`\n:param consumer_secret: parameter or environment variable `NS_CONSUMER_SECRET`\n:param token_key: parameter or environment variable `NS_TOKEN_KEY`\n:param token_secret: parameter or environment variable `NS_TOKEN_SECRET`",
                "shortdoc": "Connect to Netsuite with credentials from environment variables.",
                "tags": [],
                "matched": true
            },
            {
                "name": "Get Accounts",
                "args": [
                    "count: int = 100",
                    "account_type: str = None"
                ],
                "doc": "Get Accounts of any type or specified type.\n\n:param count: number of Accounts to return, defaults to 100\n:param account_type: if None returns all account types, example. \"_expense\",\n    defaults to None\n:return: accounts",
                "shortdoc": "Get Accounts of any type or specified type.",
                "tags": [],
                "matched": true
            },
            {
                "name": "Get Classifications",
                "args": [],
                "doc": "Get all Netsuite Classifications\n\n:return: classifications",
                "shortdoc": "Get all Netsuite Classifications",
                "tags": [],
                "matched": true
            },
            {
                "name": "Get Currencies",
                "args": [],
                "doc": "Get all Netsuite Currencies\n\n:return: currencies",
                "shortdoc": "Get all Netsuite Currencies",
                "tags": [],
                "matched": true
            },
            {
                "name": "Get Currency",
                "args": [
                    "currency_id: str"
                ],
                "doc": "Get all a Netsuite Currency by its ID\n\n:param currency_id: ID of the currency to get\n:return: currency",
                "shortdoc": "Get all a Netsuite Currency by its ID",
                "tags": [],
                "matched": true
            },
            {
                "name": "Get Departments",
                "args": [],
                "doc": "Get all Netsuite Departments\n\n:return: departments",
                "shortdoc": "Get all Netsuite Departments",
                "tags": [],
                "matched": true
            },
            {
                "name": "Get Locations",
                "args": [],
                "doc": "Get all Netsuite Locations\n\n:return: locations",
                "shortdoc": "Get all Netsuite Locations",
                "tags": [],
                "matched": true
            },
            {
                "name": "Get Vendor Bills",
                "args": [
                    "count: int = 10"
                ],
                "doc": "Get list of vendor bills\n\n:param count: number of vendor bills to return, defaults to 10\n:return: list of vendor bills",
                "shortdoc": "Get list of vendor bills",
                "tags": [],
                "matched": true
            },
            {
                "name": "Get Vendors",
                "args": [
                    "count: int = 10"
                ],
                "doc": "Get list of vendors\n\n:param count: number of vendors to return, defaults to 10\n:return: list of vendors",
                "shortdoc": "Get list of vendors",
                "tags": [],
                "matched": true
            },
            {
                "name": "Login",
                "args": [
                    "account: str = None",
                    "email: str = None",
                    "password: str = None",
                    "role: str = None",
                    "appid: str = None"
                ],
                "doc": "Login to Netsuite with credentials from environment variables\n\nParameters are not logged into Robot Framework log.\n\n:param account: parameter or environment variable `NS_ACCOUNT`\n:param email: parameter or environment variable `NS_EMAIL`\n:param password: parameter or environment variable `NS_PASSWORD`\n:param role: parameter or environment variable `NS_ROLE`\n:param appid: parameter or environment variable `NS_APPID`",
                "shortdoc": "Login to Netsuite with credentials from environment variables",
                "tags": [],
                "matched": true
            },
            {
                "name": "Netsuite Get",
                "args": [
                    "record_type: str = None",
                    "internal_id: str = None",
                    "external_id: str = None"
                ],
                "doc": "Get all records of given type and internalId and/or externalId.\n\n:param record_type: type of Netsuite record to get\n:param internal_id: internalId of the type, default None\n:param external_id: external_id of the type, default None\n:raises ValueError: if record_type is not given\n:return: records as a list or None",
                "shortdoc": "Get all records of given type and internalId and/or externalId.",
                "tags": [],
                "matched": true
            },
            {
                "name": "Netsuite Get All",
                "args": [
                    "record_type: str"
                ],
                "doc": "Get all records of given type.\n\n:param record_type: type of Netsuite record to get\n:raises ValueError: if record_type is not given\n:return: records as a list or None",
                "shortdoc": "Get all records of given type.",
                "tags": [],
                "matched": true
            },
            {
                "name": "Netsuite Search",
                "args": [
                    "type_name: str",
                    "search_value: str",
                    "operator: str = contains",
                    "page_size: int = 5"
                ],
                "doc": "Search Netsuite for value from a type. Default operator is\n`contains`.\n\n:param type_name: search target type name\n:param search_value: what to search for within type\n:param operator: name of the operation, defaults to \"contains\"\n:param page_size: result items within one page, defaults to 5\n:return: paginated search object",
                "shortdoc": "Search Netsuite for value from a type. Default operator is `contains`.",
                "tags": [],
                "matched": true
            },
            {
                "name": "Netsuite Search All",
                "args": [
                    "type_name: str",
                    "page_size: int = 20"
                ],
                "doc": "Search Netsuite for a type results.\n\n:param type_name: search target type name\n:param page_size: result items within one page, defaults to 5\n:return: paginated search object",
                "shortdoc": "Search Netsuite for a type results.",
                "tags": [],
                "matched": true
            }
        ],
        "all_tags": [],
        "contains_tags": false
    },
    "RPA.Notifier": {
        "name": "RPA.Notifier",
        "doc": "`Notifier` is a library interfacting with different notification services.\n\nSupported services:\n\n- email\n- gmail\n- pushover\n- slack\n- telegram\n- twilio\n\nServices not supported yet:\n\n- gitter\n- join\n- mailgun\n- pagerduty\n- popcornnotify\n- pushbullet\n- simplepush\n- statuspage\n- zulip\n\nRead more at https://notifiers.readthedocs.io/en/latest/\n\n**Examples**\n\n**Robot Framework**\n\n.. code-block:: robotframework\n\n   *** Settings ***\n   Library  RPA.Notifier\n\n   *** Variables ***\n   ${SLACK_WEBHOOK}   https://hooks.slack.com/services/WEBHOOKDETAILS\n   ${CHANNEL}         notification-channel\n\n   *** Tasks ***\n   Lets notify\n      Notify Slack   message from robot  channel=${CHANNEL}  webhook_url=${SLACK_WEBHOOK}\n\n**Python**\n\n.. code-block:: python\n\n   from RPA.Notifier import Notifier\n\n   library = Notifier()\n\n   slack_attachments = [\n      {\n         \"title\": \"attachment 1\",\n         \"fallback\": \"liverpool logo\",\n         \"image_url\": \"https://upload.wikimedia.org/wikipedia/fi/thumb/c/cd/Liverpool_FC-n_logo.svg/1200px-Liverpool_FC-n_logo.svg.png\",\n      }\n   ]\n\n   library.notify_slack(\n      message='message for the Slack',\n      channel=\"notification-channel\",\n      webhook_url=slack_webhook_url,\n      attachments=slack_attachments,\n   )",
        "version": "",
        "named_args": true,
        "scope": "GLOBAL",
        "generated": "2020-12-01 14:53:06",
        "inits": [],
        "keywords": [
            {
                "name": "Notify Email",
                "args": [
                    "message: str = None",
                    "to: str = None",
                    "username: str = None",
                    "password: str = None",
                    "**kwargs: dict"
                ],
                "doc": "Notify using email service\n\n:param message: notification message\n:param to: target of email message\n:param username: email service username\n:param password: email service password\n:return: True is notification was success, False if not",
                "shortdoc": "Notify using email service",
                "tags": [],
                "matched": true
            },
            {
                "name": "Notify Gmail",
                "args": [
                    "message: str = None",
                    "to: str = None",
                    "username: str = None",
                    "password: str = None",
                    "**kwargs: dict"
                ],
                "doc": "Notify using Gmail service\n\n:param message: notification message\n:param to: target of email message\n:param username: GMail service username\n:param password: GMail service password\n:return: True is notification was success, False if not",
                "shortdoc": "Notify using Gmail service",
                "tags": [],
                "matched": true
            },
            {
                "name": "Notify Pushover",
                "args": [
                    "message: str = None",
                    "user: str = None",
                    "token: str = None",
                    "**kwargs: dict"
                ],
                "doc": "Notify using Pushover service\n\n:param message: notification message\n:param user: target user for the notification\n:param token: service token\n:return: True is notification was success, False if not",
                "shortdoc": "Notify using Pushover service",
                "tags": [],
                "matched": true
            },
            {
                "name": "Notify Slack",
                "args": [
                    "message: str = None",
                    "channel: str = None",
                    "webhook_url: str = None",
                    "**kwargs: dict"
                ],
                "doc": "Notify using Slack service\n\n:param message: notification message\n:param channel: target channel for the notification\n:param webhook_url: Slack webhook url\n:return: True is notification was success, False if not",
                "shortdoc": "Notify using Slack service",
                "tags": [],
                "matched": true
            },
            {
                "name": "Notify Telegram",
                "args": [
                    "message: str = None",
                    "chat_id: str = None",
                    "token: str = None",
                    "**kwargs: dict"
                ],
                "doc": "Notify using Telegram service\n\n:param message: notification message\n:param chat_id: target chat id for the notification\n:param token: service token\n:return: True is notification was success, False if not",
                "shortdoc": "Notify using Telegram service",
                "tags": [],
                "matched": true
            },
            {
                "name": "Notify Twilio",
                "args": [
                    "message: str = None",
                    "number_from: str = None",
                    "number_to: str = None",
                    "account_sid: str = None",
                    "token: str = None",
                    "**kwargs: dict"
                ],
                "doc": "Notify using Twilio service\n\n:param message: notification message\n:param number_from: number where the message comes from\n:param number_to: number where the messages goes to\n:param account_sid: Twilio account SID\n:param token: Twilio account token\n:return: True is notification was success, False if not",
                "shortdoc": "Notify using Twilio service",
                "tags": [],
                "matched": true
            }
        ],
        "all_tags": [],
        "contains_tags": false
    },
    "RPA.Outlook.Application": {
        "name": "RPA.Outlook.Application",
        "doc": "`Outlook.Application` is a library for controlling the Outlook application.\n\n**Examples**\n\n**Robot Framework**\n\n.. code-block:: robotframework\n\n    *** Settings ***\n    Library                 RPA.Outlook.Application\n    Task Setup              Open Application\n    Suite Teardown          Quit Application\n\n    *** Variables ***\n    ${RECIPIENT}            address@domain.com\n\n    *** Tasks ***\n    Send message\n        Send Message       recipients=${RECIPIENT}\n        ...                subject=This is the subject\n        ...                body=This is the message body\n        ..                 attachments=approved.png\n\n**Python**\n\n.. code-block:: python\n\n    from RPA.Outlook.Application import Application\n\n    def send_message():\n        app = Application()\n        app.open_application()\n        app.send_message(\n            recipients='EMAILADDRESS_1, EMAILADDRESS_2',\n            subject='email subject',\n            body='email body message',\n            attachments='../orders.csv'\n\nFor more information, see: https://docs.microsoft.com/en-us/previous-versions/office/developer/office-2007/bb219950(v=office.12)",
        "version": "",
        "named_args": true,
        "scope": "GLOBAL",
        "generated": "2020-12-01 14:53:06",
        "inits": [],
        "keywords": [
            {
                "name": "Close Document",
                "args": [
                    "save_changes: bool = False"
                ],
                "doc": "Close the active document (if open).",
                "shortdoc": "Close the active document (if open).",
                "tags": [],
                "matched": true
            },
            {
                "name": "Open Application",
                "args": [
                    "visible: bool = False",
                    "display_alerts: bool = False"
                ],
                "doc": "Open the Outlook application.\n\n:param visible: show window after opening\n:param display_alerts: show alert popups",
                "shortdoc": "Open the Outlook application.",
                "tags": [],
                "matched": true
            },
            {
                "name": "Quit Application",
                "args": [
                    "save_changes: bool = False"
                ],
                "doc": "Quit the application.",
                "shortdoc": "Quit the application.",
                "tags": [],
                "matched": true
            },
            {
                "name": "Send Message",
                "args": [
                    "recipients: typing.Any",
                    "subject: str",
                    "body: str",
                    "html_body: bool = False",
                    "attachments: typing.Any = None"
                ],
                "doc": "Send message with Outlook\n\n:param recipients: list of addresses\n:param subject: email subject\n:param body: email body\n:param html_body: True if body contains HTML, defaults to False\n:param attachments: list of filepaths to include in the email, defaults to []\n:return: `True` if there were no errors",
                "shortdoc": "Send message with Outlook",
                "tags": [],
                "matched": true
            },
            {
                "name": "Wait For Message",
                "args": [
                    "criterion: str = None",
                    "timeout: float = 5.0",
                    "interval: float = 1.0"
                ],
                "doc": "Wait for email matching `criterion` to arrive into mailbox.\n\n:param criterion: message filter to wait for, defaults to \"\"\n:param timeout: total time in seconds to wait for email, defaults to 5.0\n:param interval: time in seconds for new check, defaults to 1.0\n:return: list of messages or False\n\nPossible wait criterias are: SUBJECT, SENDER and BODY\n\nExample:\n\n.. code-block:: robotframework\n\n    Wait for message     SUBJECT:rpa task calling    timeout=300    interval=10",
                "shortdoc": "Wait for email matching `criterion` to arrive into mailbox.",
                "tags": [],
                "matched": true
            }
        ],
        "all_tags": [],
        "contains_tags": false
    },
    "RPA.PDF": {
        "name": "RPA.PDF",
        "doc": "`PDF` is a library for managing PDF documents.\n\nIt provides an easy method of generating a PDF document from an HTML formatted\ntemplate file.\n\n**Examples**\n\n**Robot Framework**\n\n.. code-block:: robotframework\n\n    *** Settings ***\n    Library    RPA.PDF\n\n    *** Variables ***\n    ${TEMPLATE}    order.template\n    ${PDF}         result.pdf\n    &{VARS}        name=Robot Generated\n    ...            email=robot@domain.com\n    ...            zip=00100\n    ...            items=Item 1, Item 2\n\n    *** Tasks ***\n    Create PDF from HTML template\n        Template HTML to PDF   ${TEMPLATE}  ${PDF}  ${VARS}\n\n**Python**\n\n.. code-block:: python\n\n    from RPA.PDF import PDF\n\n    p = PDF()\n    orders = [\"item 1\", \"item 2\", \"item 3\"]\n    vars = {\n        \"name\": \"Robot Process\",\n        \"email\": \"robot@domain.com\",\n        \"zip\": \"00100\",\n        \"items\": \"<br/>\".join(orders),\n    }\n    p.template_html_to_pdf(\"order.template\", \"order.pdf\", vars)",
        "version": "",
        "named_args": true,
        "scope": "GLOBAL",
        "generated": "2020-12-01 14:53:06",
        "inits": [
            {
                "name": "Init",
                "args": [
                    "outdir: str = ."
                ],
                "doc": "Initialize self.  See help(type(self)) for accurate signature.",
                "shortdoc": "Initialize self.  See help(type(self)) for accurate signature.",
                "tags": [],
                "matched": true
            }
        ],
        "keywords": [
            {
                "name": "Accept Page Break",
                "args": [],
                "doc": "Accept automatic page break or not",
                "shortdoc": "Accept automatic page break or not",
                "tags": [],
                "matched": true
            },
            {
                "name": "Add Font",
                "args": [
                    "family",
                    "style=",
                    "fname=",
                    "uni=False"
                ],
                "doc": "Add a TrueType or Type1 font",
                "shortdoc": "Add a TrueType or Type1 font",
                "tags": [],
                "matched": true
            },
            {
                "name": "Add Image To Pdf",
                "args": [
                    "imagefile",
                    "source=None",
                    "target=None",
                    "coverage=0.2"
                ],
                "doc": "Add image to PDF which can be new or existing PDF.\n\n:param imagefile: filepath to image file to add into PDF\n:param source: filepath to source, if not given add image to currently\n    active PDF\n:param target: filepath of target PDF\n:param coverage: [description], defaults to 0.2\n:raises ValueError: [description]\n\nResult will be always written to `target_pdf` so that needs\nto be given for the keyword.",
                "shortdoc": "Add image to PDF which can be new or existing PDF.",
                "tags": [],
                "matched": true
            },
            {
                "name": "Add Link",
                "args": [],
                "doc": "Create a new internal link",
                "shortdoc": "Create a new internal link",
                "tags": [],
                "matched": true
            },
            {
                "name": "Add Page",
                "args": [
                    "orientation="
                ],
                "doc": "Start a new page",
                "shortdoc": "Start a new page",
                "tags": [],
                "matched": true
            },
            {
                "name": "Add Pages",
                "args": [
                    "pages: int = 1"
                ],
                "doc": "Adds pages into PDF documents.\n\n:param pages: number of pages to add, defaults to 1",
                "shortdoc": "Adds pages into PDF documents.",
                "tags": [],
                "matched": true
            },
            {
                "name": "Add Pages To Document",
                "args": [
                    "pages: int = 1",
                    "source_pdf: str = None",
                    "target_pdf: str = None"
                ],
                "doc": "Add empty pages into current source document\n\n:param pages: number of pages to add, defaults to 1\n:param source_pdf: filepath to the source pdf\n:param target_pdf: filename to the target pdf, stored by default\n    to `output_directory`",
                "shortdoc": "Add empty pages into current source document",
                "tags": [],
                "matched": true
            },
            {
                "name": "Alias Nb Pages",
                "args": [
                    "alias={nb}"
                ],
                "doc": "Define an alias for total number of pages",
                "shortdoc": "Define an alias for total number of pages",
                "tags": [],
                "matched": true
            },
            {
                "name": "Cell",
                "args": [
                    "w",
                    "h=0",
                    "txt=",
                    "border=0",
                    "ln=0",
                    "align=",
                    "fill=0",
                    "link="
                ],
                "doc": "Output a cell",
                "shortdoc": "Output a cell",
                "tags": [],
                "matched": true
            },
            {
                "name": "Check Page",
                "args": [],
                "doc": "Decorator to protect drawing methods",
                "shortdoc": "Decorator to protect drawing methods",
                "tags": [],
                "matched": true
            },
            {
                "name": "Close",
                "args": [],
                "doc": "Terminate document",
                "shortdoc": "Terminate document",
                "tags": [],
                "matched": true
            },
            {
                "name": "Close All Pdf Documents",
                "args": [],
                "doc": "Close all opened PDF file descriptors.",
                "shortdoc": "Close all opened PDF file descriptors.",
                "tags": [],
                "matched": true
            },
            {
                "name": "Close Pdf Document",
                "args": [
                    "source_pdf: str = None"
                ],
                "doc": "Close PDF file descriptor for certain file.\n\n:param source_pdf: filepath\n:raises ValueError: if file descriptor for the file is not found",
                "shortdoc": "Close PDF file descriptor for certain file.",
                "tags": [],
                "matched": true
            },
            {
                "name": "Code 39",
                "args": [
                    "txt",
                    "x",
                    "y",
                    "w=1.5",
                    "h=5.0"
                ],
                "doc": "Barcode 3of9",
                "shortdoc": "Barcode 3of9",
                "tags": [],
                "matched": true
            },
            {
                "name": "Dashed Line",
                "args": [
                    "x1",
                    "y1",
                    "x2",
                    "y2",
                    "dash_length=1",
                    "space_length=1"
                ],
                "doc": "Draw a dashed line. Same interface as line() except:\n- dash_length: Length of the dash\n- space_length: Length of the space between dashes",
                "shortdoc": "Draw a dashed line. Same interface as line() except: - dash_length: Length of the dash - space_length: Length of the space between dashes",
                "tags": [],
                "matched": true
            },
            {
                "name": "Dump Pdf As Xml",
                "args": [
                    "source_pdf: str = None"
                ],
                "doc": "Get PDFMiner format XML dump of the PDF\n\n:param source_pdf: filepath\n:return: XML content",
                "shortdoc": "Get PDFMiner format XML dump of the PDF",
                "tags": [],
                "matched": true
            },
            {
                "name": "Ellipse",
                "args": [
                    "x",
                    "y",
                    "w",
                    "h",
                    "style="
                ],
                "doc": "Draw a ellipse",
                "shortdoc": "Draw a ellipse",
                "tags": [],
                "matched": true
            },
            {
                "name": "Error",
                "args": [
                    "msg"
                ],
                "doc": "Fatal error",
                "shortdoc": "Fatal error",
                "tags": [],
                "matched": true
            },
            {
                "name": "Extract Pages From Pdf",
                "args": [
                    "source_pdf: str = None",
                    "target_pdf: str = None",
                    "pages: typing.Any = None"
                ],
                "doc": "Extract pages from source PDF and save to target PDF document.\n\n:param source_pdf: filepath to the source pdf\n:param target_pdf: filename to the target pdf, stored by default\n    to `output_directory`\n:param pages: page numbers to extract from PDF (numbers start from 0)\n    if None then extracts all pages\n\nPage numbers starting from 1.",
                "shortdoc": "Extract pages from source PDF and save to target PDF document.",
                "tags": [],
                "matched": true
            },
            {
                "name": "Footer",
                "args": [],
                "doc": "Footer to be implemented in your own inherited class",
                "shortdoc": "Footer to be implemented in your own inherited class",
                "tags": [],
                "matched": true
            },
            {
                "name": "Get All Figures",
                "args": [],
                "doc": "Return all figures in the PDF document.\n\n:return: dictionary of figures divided into pages\n\nPDF needs to be parsed before elements can be found.",
                "shortdoc": "Return all figures in the PDF document.",
                "tags": [],
                "matched": true
            },
            {
                "name": "Get Info",
                "args": [
                    "source_pdf: str = None"
                ],
                "doc": "Get information from PDF document.\n\n:param source_pdf: filepath to the source pdf\n:return: dictionary of PDF information",
                "shortdoc": "Get information from PDF document.",
                "tags": [],
                "matched": true
            },
            {
                "name": "Get Input Fields",
                "args": [
                    "source_pdf: str = None",
                    "replace_none_value: bool = False"
                ],
                "doc": "Get input fields in the PDF.\n\n:param source_pdf: source filepath, defaults to None\n:param replace_none_value: if value is None replace it with key name,\n    defaults to False\n:return: dictionary of input key values or `None`\n\nStores input fields internally so that they can be used without\nparsing PDF again.\n\nParameter `replace_none_value` is for convience to visualize fields.",
                "shortdoc": "Get input fields in the PDF.",
                "tags": [],
                "matched": true
            },
            {
                "name": "Get Number Of Pages",
                "args": [
                    "source_pdf: str = None"
                ],
                "doc": "Get number of pages in the document.\n\n:param source_pdf: filepath to the source pdf\n:raises PdfReadError: if file is encrypted or other restrictions are in place",
                "shortdoc": "Get number of pages in the document.",
                "tags": [],
                "matched": true
            },
            {
                "name": "Get Output Directory",
                "args": [],
                "doc": "Get output directory where target files are saved to.\n\n:return: absolute filepath as string",
                "shortdoc": "Get output directory where target files are saved to.",
                "tags": [],
                "matched": true
            },
            {
                "name": "Get String Width",
                "args": [
                    "s"
                ],
                "doc": "Get width of a string in the current font",
                "shortdoc": "Get width of a string in the current font",
                "tags": [],
                "matched": true
            },
            {
                "name": "Get Text From Pdf",
                "args": [
                    "source_pdf: str = None",
                    "pages: typing.Any = None"
                ],
                "doc": "Get text from set of pages in source PDF document.\n\n:param source_pdf: filepath to the source pdf\n:param pages: page numbers to get text (numbers start from 0)\n:return: dictionary of pages and their texts\n\nPDF needs to be parsed before text can be read.",
                "shortdoc": "Get text from set of pages in source PDF document.",
                "tags": [],
                "matched": true
            },
            {
                "name": "Get Value From Anchor",
                "args": [
                    "locator: str",
                    "pagenum: int = 1",
                    "direction: str = right",
                    "strict: bool = False",
                    "regexp: str = None"
                ],
                "doc": "Get closest text (value) to anchor element.\n\nPDF needs to be parsed before elements can be found.\n\n:param locator: element to set anchor to\n:param pagenum: page number where search if performed on, default 1 (first)\n:param direction: in which direction to search for text,\n    directions  'top', 'bottom', 'left' or 'right', defaults to 'right'\n:param strict: if element margins should be used for matching points,\n    used when direction is 'top' or 'bottom', default `False`\n:param regexp: expected format of value to match, defaults to None\n:return: closest matching text or `None`",
                "shortdoc": "Get closest text (value) to anchor element.",
                "tags": [],
                "matched": true
            },
            {
                "name": "Get X",
                "args": [],
                "doc": "Get x position",
                "shortdoc": "Get x position",
                "tags": [],
                "matched": true
            },
            {
                "name": "Get Y",
                "args": [],
                "doc": "Get y position",
                "shortdoc": "Get y position",
                "tags": [],
                "matched": true
            },
            {
                "name": "Header",
                "args": [],
                "doc": "Header to be implemented in your own inherited class",
                "shortdoc": "Header to be implemented in your own inherited class",
                "tags": [],
                "matched": true
            },
            {
                "name": "Html To Pdf",
                "args": [
                    "content: str = None",
                    "filename: str = None",
                    "variables: dict = None",
                    "create_dirs: bool = True",
                    "exists_ok: bool = True"
                ],
                "doc": "Use HTML content to generate PDF file.\n\n:param content: HTML content\n:param filename: filepath where to save PDF document\n:param variables: dictionary of variables to fill into template, defaults to {}\n:param create_dirs: directory structure is created if it is missing,\n default `True`\n:param exists_ok: file is overwritten if it exists, default `True`",
                "shortdoc": "Use HTML content to generate PDF file.",
                "tags": [],
                "matched": true
            },
            {
                "name": "Image",
                "args": [
                    "name",
                    "x=None",
                    "y=None",
                    "w=0",
                    "h=0",
                    "type=",
                    "link="
                ],
                "doc": "Put an image on the page",
                "shortdoc": "Put an image on the page",
                "tags": [],
                "matched": true
            },
            {
                "name": "Interleaved 2 Of 5",
                "args": [
                    "txt",
                    "x",
                    "y",
                    "w=1.0",
                    "h=10.0"
                ],
                "doc": "Barcode I2of5 (numeric), adds a 0 if odd lenght",
                "shortdoc": "Barcode I2of5 (numeric), adds a 0 if odd lenght",
                "tags": [],
                "matched": true
            },
            {
                "name": "Is Pdf Encrypted",
                "args": [
                    "source_pdf: str = None"
                ],
                "doc": "Check if PDF is encrypted.\n\nReturns True even if PDF was decrypted.\n\n:param source_pdf: filepath to the source pdf\n:return: True if file is encrypted",
                "shortdoc": "Check if PDF is encrypted.",
                "tags": [],
                "matched": true
            },
            {
                "name": "Line",
                "args": [
                    "x1",
                    "y1",
                    "x2",
                    "y2"
                ],
                "doc": "Draw a line",
                "shortdoc": "Draw a line",
                "tags": [],
                "matched": true
            },
            {
                "name": "Link",
                "args": [
                    "x",
                    "y",
                    "w",
                    "h",
                    "link"
                ],
                "doc": "Put a link on the page",
                "shortdoc": "Put a link on the page",
                "tags": [],
                "matched": true
            },
            {
                "name": "Ln",
                "args": [
                    "h="
                ],
                "doc": "Line Feed; default value is last cell height",
                "shortdoc": "Line Feed; default value is last cell height",
                "tags": [],
                "matched": true
            },
            {
                "name": "Multi Cell",
                "args": [
                    "w",
                    "h",
                    "txt=",
                    "border=0",
                    "align=J",
                    "fill=0",
                    "split_only=False"
                ],
                "doc": "Output text with automatic or explicit line breaks",
                "shortdoc": "Output text with automatic or explicit line breaks",
                "tags": [],
                "matched": true
            },
            {
                "name": "Normalize Text",
                "args": [
                    "txt"
                ],
                "doc": "Check that text input is in the correct format/encoding",
                "shortdoc": "Check that text input is in the correct format/encoding",
                "tags": [],
                "matched": true
            },
            {
                "name": "Open",
                "args": [],
                "doc": "Begin document",
                "shortdoc": "Begin document",
                "tags": [],
                "matched": true
            },
            {
                "name": "Open Pdf Document",
                "args": [
                    "source_pdf: str = None"
                ],
                "doc": "Open PDF document.\n\n:param source_pdf: filepath to the source pdf\n:raises ValueError: if PDF is already open\n\nAlso opens file for reading.",
                "shortdoc": "Open PDF document.",
                "tags": [],
                "matched": true
            },
            {
                "name": "Output",
                "args": [
                    "name=",
                    "dest="
                ],
                "doc": "Output PDF to some destination",
                "shortdoc": "Output PDF to some destination",
                "tags": [],
                "matched": true
            },
            {
                "name": "Page No",
                "args": [],
                "doc": "Get current page number",
                "shortdoc": "Get current page number",
                "tags": [],
                "matched": true
            },
            {
                "name": "Page Rotate",
                "args": [
                    "pages: int",
                    "source_pdf: str = None",
                    "target_pdf: str = None",
                    "clockwise: bool = True",
                    "angle: int = 90"
                ],
                "doc": "Rotate pages in source PDF document and save to target PDF document.\n\n:param source_pdf: filepath to the source pdf\n:param target_pdf: filename to the target pdf, stored by default\n    to `output_directory`\n:param pages: page numbers to extract from PDF (numbers start from 0)\n:param clockwise: directorion that page will be rotated to, default True\n:param angle: number of degrees to rotate, default 90",
                "shortdoc": "Rotate pages in source PDF document and save to target PDF document.",
                "tags": [],
                "matched": true
            },
            {
                "name": "Parse Pdf",
                "args": [
                    "source_pdf: str = None"
                ],
                "doc": "Parse source PDF into entities which can be\nused for text searches for example.\n\n:param source_pdf: source",
                "shortdoc": "Parse source PDF into entities which can be used for text searches for example.",
                "tags": [],
                "matched": true
            },
            {
                "name": "Pdf Decrypt",
                "args": [
                    "source_pdf: str = None",
                    "target_pdf: str = None",
                    "password: str = None"
                ],
                "doc": "Decrypt PDF with password.\n\n:param source_pdf: filepath to the source pdf\n:param target_pdf: filepath to the decrypted pdf\n:param password: password as a string\n:return: True if decrypt was successful, else False or Exception\n:raises ValueError: on decryption errors",
                "shortdoc": "Decrypt PDF with password.",
                "tags": [],
                "matched": true
            },
            {
                "name": "Pdf Encrypt",
                "args": [
                    "source_pdf: str = None",
                    "target_pdf: str = None",
                    "user_pwd: str = ",
                    "owner_pwd: str = None",
                    "use_128bit: bool = True"
                ],
                "doc": "Encrypt PDF document.\n\n:param source_pdf: filepath to the source pdf\n:param target_pdf: filename to the target pdf, stored by default\n    to `output_directory`\n:param user_pwd: allows opening and reading PDF with restrictions\n:param owner_pwd: allows opening PDF without any restrictions, by\n    default same `user_pwd`\n:param use_128bit: whether to 128bit encryption, when false 40bit\n    encryption is used, default True",
                "shortdoc": "Encrypt PDF document.",
                "tags": [],
                "matched": true
            },
            {
                "name": "Rect",
                "args": [
                    "x",
                    "y",
                    "w",
                    "h",
                    "style="
                ],
                "doc": "Draw a rectangle",
                "shortdoc": "Draw a rectangle",
                "tags": [],
                "matched": true
            },
            {
                "name": "Replace Text",
                "args": [
                    "text: str",
                    "replace: str"
                ],
                "doc": "Replace text content with something else in the PDF.\n\n:param text: this text will be replaced\n:param replace: used to replace `text`",
                "shortdoc": "Replace text content with something else in the PDF.",
                "tags": [],
                "matched": true
            },
            {
                "name": "Rotate",
                "args": [
                    "angle",
                    "x=None",
                    "y=None"
                ],
                "doc": "",
                "shortdoc": "",
                "tags": [],
                "matched": true
            },
            {
                "name": "Save Pdf",
                "args": [
                    "source: str = None",
                    "target: str = None",
                    "use_modified_reader: bool = False"
                ],
                "doc": "Save current over itself or to `target_pdf`\n\n:param source: filepath to source PDF\n:param target: filepath to target PDF\n:param use_modified_reader: needs to be set to `True` if\n    using modified PDF reader",
                "shortdoc": "Save current over itself or to `target_pdf`",
                "tags": [],
                "matched": true
            },
            {
                "name": "Set Anchor To Element",
                "args": [
                    "locator: str"
                ],
                "doc": "Sets anchor point in the document for further searches.\n\nPDF needs to be parsed before elements can be found.\n\n:param locator: element to search for\n:return: True if element was found",
                "shortdoc": "Sets anchor point in the document for further searches.",
                "tags": [],
                "matched": true
            },
            {
                "name": "Set Author",
                "args": [
                    "author"
                ],
                "doc": "Author of document",
                "shortdoc": "Author of document",
                "tags": [],
                "matched": true
            },
            {
                "name": "Set Auto Page Break",
                "args": [
                    "auto",
                    "margin=0"
                ],
                "doc": "Set auto page break mode and triggering margin",
                "shortdoc": "Set auto page break mode and triggering margin",
                "tags": [],
                "matched": true
            },
            {
                "name": "Set Compression",
                "args": [
                    "compress"
                ],
                "doc": "Set page compression",
                "shortdoc": "Set page compression",
                "tags": [],
                "matched": true
            },
            {
                "name": "Set Creator",
                "args": [
                    "creator"
                ],
                "doc": "Creator of document",
                "shortdoc": "Creator of document",
                "tags": [],
                "matched": true
            },
            {
                "name": "Set Display Mode",
                "args": [
                    "zoom",
                    "layout=continuous"
                ],
                "doc": "Set display mode in viewer\n\nThe \"zoom\" argument may be 'fullpage', 'fullwidth', 'real',\n'default', or a number, interpreted as a percentage.",
                "shortdoc": "Set display mode in viewer",
                "tags": [],
                "matched": true
            },
            {
                "name": "Set Draw Color",
                "args": [
                    "r",
                    "g=-1",
                    "b=-1"
                ],
                "doc": "Set color for all stroking operations",
                "shortdoc": "Set color for all stroking operations",
                "tags": [],
                "matched": true
            },
            {
                "name": "Set Field Value",
                "args": [
                    "field_name: str",
                    "value: typing.Any",
                    "save: bool = False"
                ],
                "doc": "Set value for field with given name.\n\n:param field_name: field to update\n:param value: new value for the field\n\nTries to match on field identifier and its label.\n\nException is thrown if field can't be found or more than 1 field matches\nthe given `field_name`.",
                "shortdoc": "Set value for field with given name.",
                "tags": [],
                "matched": true
            },
            {
                "name": "Set Fill Color",
                "args": [
                    "r",
                    "g=-1",
                    "b=-1"
                ],
                "doc": "Set color for all filling operations",
                "shortdoc": "Set color for all filling operations",
                "tags": [],
                "matched": true
            },
            {
                "name": "Set Font",
                "args": [
                    "family",
                    "style=",
                    "size=0"
                ],
                "doc": "Select a font; size given in points",
                "shortdoc": "Select a font; size given in points",
                "tags": [],
                "matched": true
            },
            {
                "name": "Set Font Size",
                "args": [
                    "size"
                ],
                "doc": "Set font size in points",
                "shortdoc": "Set font size in points",
                "tags": [],
                "matched": true
            },
            {
                "name": "Set Keywords",
                "args": [
                    "keywords"
                ],
                "doc": "Keywords of document",
                "shortdoc": "Keywords of document",
                "tags": [],
                "matched": true
            },
            {
                "name": "Set Left Margin",
                "args": [
                    "margin"
                ],
                "doc": "Set left margin",
                "shortdoc": "Set left margin",
                "tags": [],
                "matched": true
            },
            {
                "name": "Set Line Width",
                "args": [
                    "width"
                ],
                "doc": "Set line width",
                "shortdoc": "Set line width",
                "tags": [],
                "matched": true
            },
            {
                "name": "Set Link",
                "args": [
                    "link",
                    "y=0",
                    "page=-1"
                ],
                "doc": "Set destination of internal link",
                "shortdoc": "Set destination of internal link",
                "tags": [],
                "matched": true
            },
            {
                "name": "Set Margins",
                "args": [
                    "left",
                    "top",
                    "right=-1"
                ],
                "doc": "Set left, top and right margins",
                "shortdoc": "Set left, top and right margins",
                "tags": [],
                "matched": true
            },
            {
                "name": "Set Output Directory",
                "args": [
                    "outdir: str = ."
                ],
                "doc": "Set output directory where target files are saved to.\n\n:param outdir: output directory path, default to current directory",
                "shortdoc": "Set output directory where target files are saved to.",
                "tags": [],
                "matched": true
            },
            {
                "name": "Set Right Margin",
                "args": [
                    "margin"
                ],
                "doc": "Set right margin",
                "shortdoc": "Set right margin",
                "tags": [],
                "matched": true
            },
            {
                "name": "Set Subject",
                "args": [
                    "subject"
                ],
                "doc": "Subject of document",
                "shortdoc": "Subject of document",
                "tags": [],
                "matched": true
            },
            {
                "name": "Set Text Color",
                "args": [
                    "r",
                    "g=-1",
                    "b=-1"
                ],
                "doc": "Set color for text",
                "shortdoc": "Set color for text",
                "tags": [],
                "matched": true
            },
            {
                "name": "Set Title",
                "args": [
                    "title"
                ],
                "doc": "Title of document",
                "shortdoc": "Title of document",
                "tags": [],
                "matched": true
            },
            {
                "name": "Set Top Margin",
                "args": [
                    "margin"
                ],
                "doc": "Set top margin",
                "shortdoc": "Set top margin",
                "tags": [],
                "matched": true
            },
            {
                "name": "Set X",
                "args": [
                    "x"
                ],
                "doc": "Set x position",
                "shortdoc": "Set x position",
                "tags": [],
                "matched": true
            },
            {
                "name": "Set Xy",
                "args": [
                    "x",
                    "y"
                ],
                "doc": "Set x and y positions",
                "shortdoc": "Set x and y positions",
                "tags": [],
                "matched": true
            },
            {
                "name": "Set Y",
                "args": [
                    "y"
                ],
                "doc": "Set y position and reset x",
                "shortdoc": "Set y position and reset x",
                "tags": [],
                "matched": true
            },
            {
                "name": "Switch To Pdf Document",
                "args": [
                    "source_pdf: str = None"
                ],
                "doc": "Switch library's current fileobject to already open file\nor open file if not opened.\n\n:param source_pdf: filepath\n:raises ValueError: if PDF filepath is not given and there are no active\n    file to activate",
                "shortdoc": "Switch library's current fileobject to already open file or open file if not opened.",
                "tags": [],
                "matched": true
            },
            {
                "name": "Template Html To Pdf",
                "args": [
                    "template: str = None",
                    "filename: str = None",
                    "variables: dict = None",
                    "create_dirs: bool = True",
                    "exists_ok: bool = True"
                ],
                "doc": "Use HTML template file to generate PDF file.\n\n:param template: filepath to HTML template\n:param filename: filepath where to save PDF document\n:param variables: dictionary of variables to fill into template, defaults to {}\n:param create_dirs: directory structure is created if it is missing,\n default `True`\n:param exists_ok: file is overwritten if it exists, default `True`",
                "shortdoc": "Use HTML template file to generate PDF file.",
                "tags": [],
                "matched": true
            },
            {
                "name": "Text",
                "args": [
                    "x",
                    "y",
                    "txt="
                ],
                "doc": "Output a string",
                "shortdoc": "Output a string",
                "tags": [],
                "matched": true
            },
            {
                "name": "Update Field Values",
                "args": [
                    "source_pdf: str = None",
                    "target_pdf: str = None",
                    "newvals: dict = None"
                ],
                "doc": "Update field values in PDF if it has fields.\n\n:param source_pdf: source PDF with fields to update\n:param target_pdf: updated target PDF\n:param newvals: dictionary with key values to update",
                "shortdoc": "Update field values in PDF if it has fields.",
                "tags": [],
                "matched": true
            },
            {
                "name": "Write",
                "args": [
                    "h",
                    "txt=",
                    "link="
                ],
                "doc": "Output text in flowing mode",
                "shortdoc": "Output text in flowing mode",
                "tags": [],
                "matched": true
            },
            {
                "name": "Write Html",
                "args": [
                    "text",
                    "image_map=None"
                ],
                "doc": "Parse HTML and convert it to PDF",
                "shortdoc": "Parse HTML and convert it to PDF",
                "tags": [],
                "matched": true
            }
        ],
        "all_tags": [],
        "contains_tags": false
    },
    "RPA.Robocloud.Items": {
        "name": "RPA.Robocloud.Items",
        "doc": "A library for interacting with RPA work items.\n\nWork items are used for managing data that go through multiple\nactivities and tasks inside a process. Each execution of an activity receives\na work item from the previous activity, and after the activity is finished, it\nis forwarded to the next one. During the execution, it can freely\nread and update the data contained in an item.\n\nThe default implementation uses Robocloud to store the data, but the library\nallows using custom adapters.\n\n**Default environment**\n\nThe library automatically loads the work item defined by its runtime\nenvironment if the argument ``load_env`` is truthy (enabled by default).\nThis functionality is controlled by the following environment variables:\n\n* ``RC_WORKSPACE_ID``: The ID for the Robocloud workspace\n* ``RC_WORKITEM_ID``:  The ID for the Robocloud work item\n\nThese values are dynamic and should be set by Robocloud, but can be\noverriden manually while developing an activity.\n\n**Item structure**\n\nA work item's data payload is JSON and allows storing anything that is\nserializable. This library creates an object with the key 'variables'\nthat contains key-value pairs of a variable name and its contents.\nThese variables can be exposed to the Robot Framework task to be used directly.\n\nIn addition to the data section, a work item can also contain files,\nwhich are stored by default in Robocorp's cloud. Adding and using\nfiles with work items requires no additional setup from the user.\n\n**Workflow**\n\nWhile a work item is loaded automatically when a suite starts, changes are\nnot automatically reflected back to the source. The work item will be modified\nlocally and then saved when the corresponding keyword is explicitly called.\nIt is recommended to defer all saves to the end of the task to prevent\nleaving work items in a half-modified state after failures.\n\n**Custom adapters**\n\nWhile Robocloud is the default implementation, it can also be replaced\nwith a custom adapter. The selection is based on either the ``default_adapter``\nargument for the library, or the ``RPA_WORKITEMS_ADAPTER`` environment\nvariable. A custom implementation should inherit from the ``BaseAdapter``\nclass. The library has a built-in alternative adapter called FileAdapter for\nstoring work items to disk.\n\n**Examples**\n\n**Robot Framework**\n\nIn the following example the work item is modified locally and then saved\nback to Robocloud. Also note how the work item is loaded implicitly when\nthe suite starts.\n\n.. code-block:: robotframework\n\n    *** Settings ***\n    Library    RPA.Robocloud.Items\n\n    *** Tasks ***\n    Save variables to Robocloud\n        Add work item file    orders.xlsx\n        Set work item variables    user=Dude    mail=address@company.com\n        Save work item\n\nLater in the process inside a different robot, we can use previously saved\nwork item variables and files. The library also allows injecting the variables\ndirectly into the current task execution.\n\n.. code-block:: robotframework\n\n    *** Settings ***\n    Library    RPA.Robocloud.Items\n\n    *** Tasks ***\n    Use variables from Robocloud\n        Set task variables from work item\n        Log    Variables are now available: ${user}, ${mail}\n        ${path}=    Get work item file    orders.xlsx\n        Log    Files are also stored to disk: ${path}\n\n**Python**\n\nThe library can also be used through Python, but it does not implicitly\nload the work item for the current execution.\n\n.. code-block:: python\n\n    import logging\n    from RPA.Robocloud.Items import Items\n\n    def list_variables(item_id):\n        library = Items()\n        library.load_work_item_from_environment()\n\n        for variable, value in library.get_work_item_variables().items():\n            logging.info(\"%s = %s\", variable, value)",
        "version": "",
        "named_args": true,
        "scope": "GLOBAL",
        "generated": "2020-12-01 14:53:06",
        "inits": [
            {
                "name": "Init",
                "args": [
                    "load_env=True",
                    "default_adapter=<class 'RPA.Robocloud.Items.RobocorpAdapter'>"
                ],
                "doc": "Initialize self.  See help(type(self)) for accurate signature.",
                "shortdoc": "Initialize self.  See help(type(self)) for accurate signature.",
                "tags": [],
                "matched": true
            }
        ],
        "keywords": [
            {
                "name": "Add Work Item File",
                "args": [
                    "path",
                    "name=None"
                ],
                "doc": "Add given file to work item.\n\n:param path: Path to file on disk\n:param name: Destination name for file. If not given, current name\n             of local file is used.\n\n**NOTE**: Files are not uploaded before work item is saved\n\nExample:\n\n.. code-block:: robotframework\n\n    Add work item file    output.xls\n    Save work item",
                "shortdoc": "Add given file to work item.",
                "tags": [],
                "matched": true
            },
            {
                "name": "Add Work Item Files",
                "args": [
                    "pattern"
                ],
                "doc": "Add all files that match given pattern to work item.\n\n:param pattern: Path wildcard pattern\n\nExample:\n\n.. code-block:: robotframework\n\n    Add work item files    %{ROBOT_ROOT}/generated/*.csv\n    Save work item",
                "shortdoc": "Add all files that match given pattern to work item.",
                "tags": [],
                "matched": true
            },
            {
                "name": "Clear Work Item",
                "args": [],
                "doc": "Remove all data in the current work item.\n\nExample:\n\n.. code-block:: robotframework\n\n    Clear work item\n    Save work item",
                "shortdoc": "Remove all data in the current work item.",
                "tags": [],
                "matched": true
            },
            {
                "name": "Delete Work Item Variables",
                "args": [
                    "*names",
                    "force=True"
                ],
                "doc": "Delete variable(s) from the current work item.\n\n:param names: Names of variables to remove\n:param force: Ignore variables that don't exist in work item\n\nExample:\n\n.. code-block:: robotframework\n\n    Delete work item variables    username    email\n    Save work item",
                "shortdoc": "Delete variable(s) from the current work item.",
                "tags": [],
                "matched": true
            },
            {
                "name": "Get Work Item File",
                "args": [
                    "name",
                    "path=None"
                ],
                "doc": "Get attached file from work item to disk.\nReturns the absolute path to the created file.\n\n:param name: Name of attached file\n:param path: Destination path of file. If not given, current\n             working directory is used.\n\nExample:\n\n.. code-block:: robotframework\n\n    ${path}=    Get work item file    input.xls\n    Open workbook    ${path}",
                "shortdoc": "Get attached file from work item to disk. Returns the absolute path to the created file.",
                "tags": [],
                "matched": true
            },
            {
                "name": "Get Work Item Files",
                "args": [
                    "pattern",
                    "dirname=None"
                ],
                "doc": "Get files attached to work item that match given pattern.\nReturns a list of absolute paths to the downloaded files.\n\n:param pattern: Filename wildcard pattern\n:param dirname: Destination directory, if not given robot root is used\n\nExample:\n\n.. code-block:: robotframework\n\n    ${paths}=    Get work item files    customer_*.xlsx\n    FOR  ${path}  IN  @{paths}\n        Handle customer file    ${path}\n    END",
                "shortdoc": "Get files attached to work item that match given pattern. Returns a list of absolute paths to the downloaded files.",
                "tags": [],
                "matched": true
            },
            {
                "name": "Get Work Item Payload",
                "args": [],
                "doc": "Get the full JSON payload for a work item.\n\n**NOTE**: Most use cases should prefer higher-level keywords.\n\nExample:\n\n.. code-block:: robotframework\n\n    ${payload}=    Get work item payload\n    Log    Entire payload as dictionary: ${payload}",
                "shortdoc": "Get the full JSON payload for a work item.",
                "tags": [],
                "matched": true
            },
            {
                "name": "Get Work Item Variable",
                "args": [
                    "name",
                    "default=<object object at 0x165982900>"
                ],
                "doc": "Return a single variable value from the work item,\nor default value if defined and key does not exist.\nIf key does not exist and default is not defined, raises `KeyError`.\n\n:param key: Name of variable\n:param default: Default value if key does not exist\n\nExample:\n\n.. code-block:: robotframework\n\n    ${username}=    Get work item variable    username    default=guest",
                "shortdoc": "Return a single variable value from the work item, or default value if defined and key does not exist. If key does not exist and default is not defined, raises `KeyError`.",
                "tags": [],
                "matched": true
            },
            {
                "name": "Get Work Item Variables",
                "args": [],
                "doc": "Read all variables from the current work item and\nreturn their names and values as a dictionary.\n\nExample:\n\n.. code-block:: robotframework\n\n    ${variables}=    Get work item variables\n    Log    Username: ${variables}[username], Email: ${variables}[email]",
                "shortdoc": "Read all variables from the current work item and return their names and values as a dictionary.",
                "tags": [],
                "matched": true
            },
            {
                "name": "List Work Item Files",
                "args": [],
                "doc": "List the names of files attached to the current work item.\n\nExample:\n\n.. code-block:: robotframework\n\n    ${names}=    List work item files\n    Log    Work item has files with names: ${names}",
                "shortdoc": "List the names of files attached to the current work item.",
                "tags": [],
                "matched": true
            },
            {
                "name": "List Work Item Variables",
                "args": [],
                "doc": "List the variable names for the current work item.\n\nExample:\n\n.. code-block:: robotframework\n\n    ${variables}=    List work item variables\n    Log    Available variables in work item: ${variables}",
                "shortdoc": "List the variable names for the current work item.",
                "tags": [],
                "matched": true
            },
            {
                "name": "Load Work Item",
                "args": [
                    "workspace_id",
                    "item_id"
                ],
                "doc": "Load work item for reading/writing.\n\n:param workspace_id:    Workspace ID which contains item\n:param item_id:         Workitem ID to load\n\n**NOTE**: Currently only one work item per execution is supported\n          by Robocorp Cloud, which should be loaded automatically.",
                "shortdoc": "Load work item for reading/writing.",
                "tags": [],
                "matched": true
            },
            {
                "name": "Load Work Item From Environment",
                "args": [],
                "doc": "Load current work item defined by the runtime environment.\n\nThe corresponding environment variables are:\n\n* RC_WORKSPACE_ID\n* RC_WORKITEM_ID",
                "shortdoc": "Load current work item defined by the runtime environment.",
                "tags": [],
                "matched": true
            },
            {
                "name": "Remove Work Item File",
                "args": [
                    "name",
                    "missing_ok=True"
                ],
                "doc": "Remove attached file from work item.\n\n:param name: Name of attached file\n:param missing_ok: Do not raise exception if file doesn't exist\n\n**NOTE**: Files are not deleted before work item is saved\n\nExample:\n\n.. code-block:: robotframework\n\n    Remove work item file    input.xls\n    Save work item",
                "shortdoc": "Remove attached file from work item.",
                "tags": [],
                "matched": true
            },
            {
                "name": "Remove Work Item Files",
                "args": [
                    "pattern",
                    "missing_ok=True"
                ],
                "doc": "Removes files attached to work item that match given pattern.\n\n:param pattern: Filename wildcard pattern\n:param missing_ok: Do not raise exception if file doesn't exist\n\nExample:\n\n.. code-block:: robotframework\n\n    Remove work item files    *.xlsx\n    Save work item",
                "shortdoc": "Removes files attached to work item that match given pattern.",
                "tags": [],
                "matched": true
            },
            {
                "name": "Save Work Item",
                "args": [],
                "doc": "Save the current data in the work item. If not saved,\nall changes are discarded when the library goes out of scope.",
                "shortdoc": "Save the current data in the work item. If not saved, all changes are discarded when the library goes out of scope.",
                "tags": [],
                "matched": true
            },
            {
                "name": "Set Task Variables From Work Item",
                "args": [],
                "doc": "Convert all variables in the current work item to\nRobot Framework task variables.\n\nExample:\n\n.. code-block:: robotframework\n\n    # Work item has variable INPUT_URL\n    Set task variables from work item\n    Log    The variable is now available: ${INPUT_URL}",
                "shortdoc": "Convert all variables in the current work item to Robot Framework task variables.",
                "tags": [],
                "matched": true
            },
            {
                "name": "Set Work Item Payload",
                "args": [
                    "payload"
                ],
                "doc": "Set the full JSON payload for a work item.\n\n:param payload: Content of payload, must be JSON-serializable\n\n**NOTE**: Most use cases should prefer higher-level keywords.\n\nExample:\n\n.. code-block:: robotframework\n\n    ${output}=    Create dictionary    url=example.com    username=Mark\n    Set work item payload    ${output}",
                "shortdoc": "Set the full JSON payload for a work item.",
                "tags": [],
                "matched": true
            },
            {
                "name": "Set Work Item Variable",
                "args": [
                    "name",
                    "value"
                ],
                "doc": "Set a single variable value in the current work item.\n\n:param key: Name of variable\n:param value: Value of variable\n\nExample:\n\n.. code-block:: robotframework\n\n    Set work item variable    username    MarkyMark\n    Save work item",
                "shortdoc": "Set a single variable value in the current work item.",
                "tags": [],
                "matched": true
            },
            {
                "name": "Set Work Item Variables",
                "args": [
                    "**kwargs"
                ],
                "doc": "Set multiple variables in the current work item.\n\n:param kwargs: Pairs of variable names and values\n\nExample:\n\n.. code-block:: robotframework\n\n    Set work item variables    username=MarkyMark    email=mark@example.com\n    Save work item",
                "shortdoc": "Set multiple variables in the current work item.",
                "tags": [],
                "matched": true
            }
        ],
        "all_tags": [],
        "contains_tags": false
    },
    "RPA.Robocloud.Secrets": {
        "name": "RPA.Robocloud.Secrets",
        "doc": "`Secrets` is a library for interfacing secrets set in the Robocloud Vault\n(used by default) or file-based secrets, which can be taken into use\nby setting two environment variables below.\n\nRobocloud Vault works together with Robocloud Worker or Robocode CLI.\nFollowing three environment variables need to exist (these are set by\nRobocloud Worker automatically and can be set manually with Robocode CLI).\n\n- RC_API_SECRET_HOST : URL to Robocloud Secrets API\n- RC_API_SECRET_TOKEN : API Token for Robocloud Secrets API\n- RC_WORKSPACE_ID : Robocloud Workspace ID\n\nFile based secrets can be set by defining two environment variables.\n\n- RPA_SECRET_MANAGER : 'RPA.Robocloud.Secrets.FileSecrets'\n- RPA_SECRET_FILE : Absolute path to the secrets JSON file.\n\n.. code-block:: json\n\n    {\n        \"swaglabs\": {\n            \"username\": \"standard_user\",\n            \"password\": \"secret_sauce\"\n        }\n    }\n\n**Examples**\n\n**Robot Framework**\n\n.. code-block:: robotframework\n\n    *** Settings ***\n    Library    RPA.Robocloud.Secrets\n\n    *** Tasks ***\n    Reading secrets\n        ${secrets}=   Get Secret  swaglabs\n        Log Many      ${secrets}\n\n**Python**\n\n.. code-block:: python\n\n    from RPA.Robocloud.Secrets import Secrets\n\n    secret = Secrets()\n    print(f\"My secrets: {secret.get_secret('swaglabs')}\")",
        "version": "",
        "named_args": true,
        "scope": "GLOBAL",
        "generated": "2020-12-01 14:53:06",
        "inits": [
            {
                "name": "Init",
                "args": [
                    "*args",
                    "**kwargs"
                ],
                "doc": "The selected adapter can be set with the environment\nvariable ``RPA_SECRET_MANAGER``, or the keyword argument ``default_adapter``.\nDefaults to Robocloud Vault if not defined.\n\nAll other library arguments are passed to the adapter.\n\n:param default_adapter: Override default secret adapter",
                "shortdoc": "The selected adapter can be set with the environment variable ``RPA_SECRET_MANAGER``, or the keyword argument ``default_adapter``. Defaults to Robocloud Vault if not defined.",
                "tags": [],
                "matched": true
            }
        ],
        "keywords": [
            {
                "name": "Get Secret",
                "args": [
                    "secret_name"
                ],
                "doc": "Read a secret from the configured source, e.g. Robocloud Vault,\nand return it as a ``Secret`` object.\n\n:param secret_name: Name of secret",
                "shortdoc": "Read a secret from the configured source, e.g. Robocloud Vault, and return it as a ``Secret`` object.",
                "tags": [],
                "matched": true
            }
        ],
        "all_tags": [],
        "contains_tags": false
    },
    "RPA.RobotLogListener": {
        "name": "RPA.RobotLogListener",
        "doc": "`RobotLogListener` is a library for controlling logging during\na Robot Framework execution using the listener API.\n\n**About keyword parameters**\n\nParameters `names` and `keywords` for keywords `Mute Run On Failure` and `Register Protected Keywords`\ndo not need to be full names of keywords, ie. all keywords matching even partially will be affected.\n`Run Keyword` would match all `BuiltIn` library keywords (17 keywords in RF 3.2.1) and of course all\n`Run Keyword` named keywords in any resource and/or library file which are imported would be matched also.\n\n**Mute Run On Failure**\n\nThis keyword is to be used specifically with `RPA.Browser` library, which extends\n`SeleniumLibrary`.  Normally most of the `SeleniumLibrary` keywords execute `run_on_failure`\nbehaviour, which can be set at library initialization. By default this behaviour is running\n`Capture Page Screenshot` keyword on failure.\n\nIn the example task `Check the official website` below the keyword `Run Keyword` is muted and when\nit runs the keyword `Element Should Be Visible` then those failures do not create page screenshots\ninto log file.\n\nIt is also possible to change default failure behaviour by giving parameter\n`optional_keyword_to_run` for `Mute Run On Failure`, see task `Check the official website with error log`.\nThis optional keyword would be then executed on failure. Due to the underlying `SeleniumLibrary`\nimplementation this keyword can't have arguments.\n\nExample of using `Mute Run On Failure` without and with optional keyword to run.\n\n.. code-block:: robotframework\n\n   *** Settings ***\n   Library         RPA.Browser\n   Library         RPA.RobotLogListener\n   Task Setup      Set Task Variable   ${TRIES}   1\n   Task Teardown   Close All Browsers\n\n   *** Tasks ***\n   Check the official website\n      Mute Run On Failure   Run Keyword\n      Open Available Browser   https://www.robocorp.com\n      Check for visible element\n      Capture Page Screenshot\n\n   Check the official website with error log\n      Mute Run On Failure   Run Keyword  optional_keyword_to_run=Log tries\n      Open Available Browser   https://www.robocorp.com\n      Check for visible element\n      Capture Page Screenshot\n\n   *** Keywords ***\n   Check for visible element\n      FOR  ${idx}  IN RANGE  1   20\n         Set Task Variable   ${TRIES}   ${idx}\n         ${status}   Run Keyword And Return Status   Element Should Be Visible  id:xyz\n         Exit For Loop If   '${status}' == 'PASS'\n         Sleep  2s\n      END\n\n   Log tries\n      Log  Checked element visibility ${TRIES} times\n\n**Register Protected Keywords**\n\nThis keyword is used to totally disable logging for named keywords. In the example below\nthe keyword `This will not output` is protected and it will not be logging into Robot Framework\nlog files.\n\n**Robot Framework**\n\n.. code-block:: robotframework\n\n    *** Settings ***\n    Library         RPA.RobotLogListener\n\n    *** Tasks ***\n    Protecting keywords\n       This will not output        # will output because called before register\n       Register Protected Keywords    This will not output\n       This will not output        # is now registered\n       This will output\n\n    *** Keywords ***\n    This will not output\n       Log   1\n\n    This will output\n       Log   2\n\n**Python**\n\n.. code-block:: python\n\n    from robot.libraries.BuiltIn import BuiltIn, RobotNotRunningError\n    from RPA.RobotLogListener import RobotLogListener\n\n    try:\n       BuiltIn().import_library(\"RPA.RobotLogListener\")\n    except RobotNotRunningError:\n       pass\n\n    class CustomLibrary:\n\n       def __init__(self):\n          listener = RobotLogListener()\n          listener.register_protected_keywords(\n                [\"CustomLibrary.special_keyword\"]\n          )\n\n       def special_keyword(self):\n          print('will not be written to log')\n          return 'not shown in the log'",
        "version": "",
        "named_args": true,
        "scope": "GLOBAL",
        "generated": "2020-12-01 14:53:06",
        "inits": [],
        "keywords": [
            {
                "name": "End Keyword",
                "args": [
                    "name",
                    "attributes"
                ],
                "doc": "Listener method for keyword end.\n\n:param name: keyword name\n:param attributes: keyword attributes\n\nIf `name` exists in the protected keywords list then log level is\nrestored back to level it was before settings to NONE.",
                "shortdoc": "Listener method for keyword end.",
                "tags": [],
                "matched": true
            },
            {
                "name": "Mute Run On Failure",
                "args": [
                    "keywords: typing.Any = None",
                    "optional_keyword_to_run: str = None"
                ],
                "doc": "Set keywords which should not execute `SeleniumLibrary`\ndefault behaviour of running keyword on failure.\n\n:param keywords: list of keywords to mute\n:param optional_keyword_to_run: name of the keyword to execute\n    if keyword defined by `keywords` fail\n\nKeyword names do not need to be full names of keywords, ie. all keywords\nmatching even partially will be affected. `Run Keyword` would match all\n`BuiltIn` library keywords (17 keywords in RF 3.2.1) and of course all\n`Run Keyword` named keywords in any resource and/or library file which\nare imported would be matched also.\n\nBy default `SeleniumLibrary` executes `Capture Page Screenshot`\non failure.\n\nIf `optional_keyword_to_run` is not given then nothing is done\non failure, but this can be set to override `SeleniumLibrary`\ndefault behaviour for a set of keywords.",
                "shortdoc": "Set keywords which should not execute `SeleniumLibrary` default behaviour of running keyword on failure.",
                "tags": [],
                "matched": true
            },
            {
                "name": "Only Info Level",
                "args": [
                    "names: typing.Any = None"
                ],
                "doc": "Register keywords that are allowed only INFO level logging\n\n:param names: list of keywords to protect",
                "shortdoc": "Register keywords that are allowed only INFO level logging",
                "tags": [],
                "matched": true
            },
            {
                "name": "Register Protected Keywords",
                "args": [
                    "names: typing.Any = None"
                ],
                "doc": "Register keywords that are not going to be logged into Robot Framework logs.\n\n:param names: list of keywords to protect",
                "shortdoc": "Register keywords that are not going to be logged into Robot Framework logs.",
                "tags": [],
                "matched": true
            },
            {
                "name": "Start Keyword",
                "args": [
                    "name",
                    "attributes"
                ],
                "doc": "Listener method for keyword start.\n\n:param name: keyword name\n:param attributes: keyword attributes\n\nIf `name` exists in the protected keywords list then log level is\ntemporarily set to NONE.",
                "shortdoc": "Listener method for keyword start.",
                "tags": [],
                "matched": true
            }
        ],
        "all_tags": [],
        "contains_tags": false
    },
    "RPA.SAP": {
        "name": "RPA.SAP",
        "doc": "RPA Framework library which is wrapping `SapGuiLibrary` functionality.",
        "version": "",
        "named_args": true,
        "scope": "GLOBAL",
        "generated": "2020-12-01 14:53:06",
        "inits": [
            {
                "name": "Init",
                "args": [
                    "*args",
                    "**kwargs"
                ],
                "doc": "Initialize self.  See help(type(self)) for accurate signature.",
                "shortdoc": "Initialize self.  See help(type(self)) for accurate signature.",
                "tags": [],
                "matched": true
            }
        ],
        "keywords": [],
        "all_tags": [],
        "contains_tags": false
    },
    "RPA.Salesforce": {
        "name": "RPA.Salesforce",
        "doc": "`Salesforce` is a library for accessing Salesforce using REST API.\nThe library extends `simple-salesforce library`_.\n\nMore information available at `Salesforce REST API Developer Guide`_.\n\n.. _Salesforce REST API Developer Guide:\n    https://developer.salesforce.com/docs/atlas.en-us.api_rest.meta/api_rest/intro_what_is_rest_api.htm\n\n.. _simple-salesforce library:\n    https://github.com/simple-salesforce/simple-salesforce\n\n**Dataloader**\n\nThe keyword `execute_dataloader_import` can be used to mimic\n`Salesforce Dataloader`_ import behaviour.\n\n`input_object` can be given in different formats. Below is an example where\ninput is in `RPA.Table` format in **method a** and list format in **method b**.\n\n.. _Salesforce Dataloader:\n    https://developer.salesforce.com/docs/atlas.en-us.dataLoader.meta/dataLoader/data_loader.htm\n\n.. code-block:: robotframework\n\n    *** Settings ***\n    Library     RPA.Salesforce\n    Library     RPA.Database\n    Task Setup  Authorize Salesforce\n\n    *** Tasks ***\n    # Method a\n    ${orders}=        Database Query Result As Table\n    ...               SELECT * FROM incoming_orders\n    ${status}=        Execute Dataloader Insert\n    ...               ${orders}  ${mapping_dict}  Tilaus__c\n    # Method b\n    ${status}=        Execute Dataloader Insert\n    ...               ${WORKDIR}${/}orders.json  ${mapping_dict}  Tilaus__c\n\n\nExample file **orders.json**\n\n.. code-block:: json\n\n    [\n        {\n            \"asiakas\": \"0015I000002jBLIQA2\"\n        },\n        {\n            \"asiakas\": \"0015I000002jBLDQA2\"\n        },\n    ]\n\n`mapping_object` describes how the input data fields are mapped into Salesforce\nobject attributes. In the example, the mapping defines that `asiakas` attribute in the\ninput object is mapped into `Tilaaja__c` attribute of `Tilaus__c` custom Salesforce object.\n\n.. code-block:: json\n\n    {\n        \"Tilaus__c\": {\n            \"asiakas\": \"Tilaaja__c\"\n        },\n    }\n\nObject type could be, for example, `Tilaus__c`.\n\n**Salesforce object operations**\n\nFollowing operations can be used to manage Salesforce objects:\n\n* Get Salesforce Object By Id\n* Create Salesforce Object\n* Update Salesforce Object\n* Upsert Salesforce Object\n* Delete Salesforce Object\n* Get Salesforce Object Metadata\n* Describe Salesforce Object\n\n**Examples**\n\n**Robot Framework**\n\n.. code-block:: robotframework\n\n    *** Settings ***\n    Library     RPA.Salesforce\n    Task Setup  Authorize Salesforce\n\n    *** Variables ***\n    ${ACCOUNT_NOKIA}    0015I000002jBLDQA2\n\n    *** Tasks ***\n    Change account details in Salesforce\n        &{account}=      Get Salesforce Object By Id   Account  ${ACCOUNT_NOKIA}\n        &{update_obj}=   Create Dictionary   Name=Nokia Ltd  BillingStreet=Nokia bulevard 1\n        ${result}=       Update Salesforce Object  Account  ${ACCOUNT_NOKIA}  ${update_obj}\n\n    *** Keywords ***\n    Authorize Salesforce\n        ${secrets}=     Get Secret   salesforce\n        Auth With Token\n        ...        username=${secrets}[USERNAME]\n        ...        password=${secrets}[PASSWORD]\n        ...        api_token=${secrets}[API_TOKEN]\n\n**Python**\n\n.. code-block:: python\n\n    import pprint\n    from RPA.Salesforce import Salesforce\n    from RPA.Robocloud.Secrets import FileSecrets\n\n    pp = pprint.PrettyPrinter(indent=4)\n    filesecrets = FileSecrets(\"secrets.json\")\n    secrets = filesecrets.get_secret(\"salesforce\")\n\n    sf = Salesforce()\n    sf.auth_with_token(\n        username=secrets[\"USERNAME\"],\n        password=secrets[\"PASSWORD\"],\n        api_token=secrets[\"API_TOKEN\"],\n    )\n    nokia_account_id = \"0015I000002jBLDQA2\"\n    account = sf.get_salesforce_object_by_id(\"Account\", nokia_account_id)\n    pp.pprint(account)\n    billing_information = {\n        \"BillingStreet\": \"Nokia Bulevard 1\",\n        \"BillingCity\": \"Espoo\",\n        \"BillingPostalCode\": \"01210\",\n        \"BillingCountry\": \"Finland\",\n    }\n    result = sf.update_salesforce_object(\"Account\", nokia_account_id, billing_information)\n    print(f\"Update result: {result}\")",
        "version": "",
        "named_args": true,
        "scope": "GLOBAL",
        "generated": "2020-12-01 14:53:06",
        "inits": [
            {
                "name": "Init",
                "args": [
                    "sandbox: bool = False"
                ],
                "doc": "Initialize self.  See help(type(self)) for accurate signature.",
                "shortdoc": "Initialize self.  See help(type(self)) for accurate signature.",
                "tags": [],
                "matched": true
            }
        ],
        "keywords": [
            {
                "name": "Add Product Into Opportunity",
                "args": [
                    "product_name: str",
                    "quantity: int",
                    "opportunity_id: str = None",
                    "pricebook_name: str = None",
                    "custom_total_price: float = None"
                ],
                "doc": "Add Salesforce Product into Opportunity.\n\n:param product_name: type of the product in the Pricelist\n:param quantity: number of products to add\n:param opportunity_id: identifier of Opportunity, default None\n:param pricebook_name: name of the pricelist, default None\n:param custom_total_price: price that overrides quantity and product price,\n    default None\n:return: True is operation is successful or False",
                "shortdoc": "Add Salesforce Product into Opportunity.",
                "tags": [],
                "matched": true
            },
            {
                "name": "Auth With Token",
                "args": [
                    "username: str",
                    "password: str",
                    "api_token: str"
                ],
                "doc": "Authorize to Salesforce with security token, username\nand password creating instance.\n\n:param username: Salesforce API username\n:param password: Salesforce API password\n:param api_token: Salesforce API security token",
                "shortdoc": "Authorize to Salesforce with security token, username and password creating instance.",
                "tags": [],
                "matched": true
            },
            {
                "name": "Create New Opportunity",
                "args": [
                    "close_date: str",
                    "opportunity_name: str",
                    "stage_name: str = Closed Won",
                    "account_name: str = None"
                ],
                "doc": "Create Salesforce Opportunity object.\n\n:param close_date: closing date for the Opportunity, format 'YYYY-MM-DD'\n:param opportunity_name: as string\n:param stage_name: needs to be one of the defined stages,\n    defaults to \"Closed Won\"\n:param account_name: by default uses previously set account, defaults to None\n:return: created opportunity or False",
                "shortdoc": "Create Salesforce Opportunity object.",
                "tags": [],
                "matched": true
            },
            {
                "name": "Create Salesforce Object",
                "args": [
                    "object_type: str",
                    "object_data: typing.Any"
                ],
                "doc": "Create Salesforce object by type and data.\n\n:param object_type: Salesforce object type\n:param object_data: Salesforce object data\n:raises SalesforceDataNotAnDictionary: when `object_data` is not dictionary\n:return: resulting object as dictionary",
                "shortdoc": "Create Salesforce object by type and data.",
                "tags": [],
                "matched": true
            },
            {
                "name": "Delete Salesforce Object",
                "args": [
                    "object_type: str",
                    "object_id: str"
                ],
                "doc": "Delete Salesfoce object by type and id.\n\n:param object_type: Salesforce object type\n:param object_id: Salesforce object id\n:return: True if successful",
                "shortdoc": "Delete Salesfoce object by type and id.",
                "tags": [],
                "matched": true
            },
            {
                "name": "Describe Salesforce Object",
                "args": [
                    "object_type: str"
                ],
                "doc": "Get Salesfoce object description by type.\n\n:param object_type: Salesforce object type\n:return: object description as dictionary",
                "shortdoc": "Get Salesfoce object description by type.",
                "tags": [],
                "matched": true
            },
            {
                "name": "Execute Dataloader Insert",
                "args": [
                    "input_object: typing.Any",
                    "mapping_object: typing.Any",
                    "object_type: str"
                ],
                "doc": "Keyword mimics Salesforce Dataloader 'insert' behaviour by taking\nin a `input_object`representing dictionary of data to input into Salesforce,\na `mapping_object` representing dictionary mapping the input keys into\nSalesforce keys, an `object_type` representing Salesforce object which\nDatahandler will handle with `operation` type.\n\nStores operation successes into `Salesforce.dataloader_success` array.\nStores operation errors into `Salesforce.dataloader_errors`.\n\nThese can be retrieved with keywords `get_dataloader_success_table` and\n`get_dataloader_error_table` which return corresponding data as\n`RPA.Table`.\n\n:param input_object: filepath or list of dictionaries\n:param mapping_object: filepath or dictionary\n:param object_type: Salesforce object type\n:return: True if operation is successful",
                "shortdoc": "Keyword mimics Salesforce Dataloader 'insert' behaviour by taking in a `input_object`representing dictionary of data to input into Salesforce, a `mapping_object` representing dictionary mapping the input keys into Salesforce keys, an `object_type` representing Salesforce object which Datahandler will handle with `operation` type.",
                "tags": [],
                "matched": true
            },
            {
                "name": "Get Dataloader Error Table",
                "args": [],
                "doc": "Return Dataloader error entries as `RPA.Table`",
                "shortdoc": "Return Dataloader error entries as `RPA.Table`",
                "tags": [],
                "matched": true
            },
            {
                "name": "Get Dataloader Success Table",
                "args": [],
                "doc": "Return Dataloader success entries as `RPA.Table`",
                "shortdoc": "Return Dataloader success entries as `RPA.Table`",
                "tags": [],
                "matched": true
            },
            {
                "name": "Get Opportunity Id",
                "args": [
                    "opportunity_name: str"
                ],
                "doc": "Get ID of an Opportunity linked to set account.\n\n:param opportunity_name: opportunity to query\n:return: Id of the opportunity or False",
                "shortdoc": "Get ID of an Opportunity linked to set account.",
                "tags": [],
                "matched": true
            },
            {
                "name": "Get Pricebook Entries",
                "args": [],
                "doc": "Get all pricebook entries.\n\n:return: query result",
                "shortdoc": "Get all pricebook entries.",
                "tags": [],
                "matched": true
            },
            {
                "name": "Get Pricebook Id",
                "args": [
                    "pricebook_name: str"
                ],
                "doc": "Get ID of a pricelist.\n\nReturns False if unique Id is not found.\n\n:param pricebook_name: pricelist to query\n:return: Id of the pricelist or False",
                "shortdoc": "Get ID of a pricelist.",
                "tags": [],
                "matched": true
            },
            {
                "name": "Get Products In Pricelist",
                "args": [
                    "pricebook_name: str"
                ],
                "doc": "Get all products in a pricelist.\n\n:param pricebook_name: pricelist to query\n:return: products in dictionary",
                "shortdoc": "Get all products in a pricelist.",
                "tags": [],
                "matched": true
            },
            {
                "name": "Get Salesforce Object By Id",
                "args": [
                    "object_type: str",
                    "object_id: str"
                ],
                "doc": "Get Salesforce object by id and type.\n\n:param object_type: Salesforce object type\n:param object_id: Salesforce object id\n:return: dictionary of object attributes",
                "shortdoc": "Get Salesforce object by id and type.",
                "tags": [],
                "matched": true
            },
            {
                "name": "Get Salesforce Object Metadata",
                "args": [
                    "object_type: str"
                ],
                "doc": "Get Salesfoce object metadata by type.\n\n:param object_type: Salesforce object type\n:return: object metadata as dictionary",
                "shortdoc": "Get Salesfoce object metadata by type.",
                "tags": [],
                "matched": true
            },
            {
                "name": "Read Dictionary From File",
                "args": [
                    "mapping_file: str"
                ],
                "doc": "Read dictionary from file.\n\n:param mapping_file: path to the file\n:return: file content as dictionary",
                "shortdoc": "Read dictionary from file.",
                "tags": [],
                "matched": true
            },
            {
                "name": "Salesforce Query",
                "args": [
                    "sql_string: str"
                ],
                "doc": "Perform SQL query.\n\n:param sql_string: SQL clause to perform\n:return: result of the SQL query",
                "shortdoc": "Perform SQL query.",
                "tags": [],
                "matched": true
            },
            {
                "name": "Salesforce Query Result As Table",
                "args": [
                    "sql_string: str"
                ],
                "doc": "Perform SQL query and return result as `RPA.Table`.\n\n:param sql_string: SQL clause to perform\n:return: result of the SQL query as Table",
                "shortdoc": "Perform SQL query and return result as `RPA.Table`.",
                "tags": [],
                "matched": true
            },
            {
                "name": "Set Account",
                "args": [
                    "account_name: str = ",
                    "account_id: str = "
                ],
                "doc": "Set account name and id by giving either parameter.\n\nCan be used together with keywords:\n    - get_opportunity_id\n    - create_new_opportunity\n\n:param account_name: string, defaults to \"\"\n:param account_id: string, defaults to \"\"\n:return: True if account was found from Salesforce, else False",
                "shortdoc": "Set account name and id by giving either parameter.",
                "tags": [],
                "matched": true
            },
            {
                "name": "Set Pricebook",
                "args": [
                    "pricebook_name: str"
                ],
                "doc": "Sets Pricebook to be used in Salesforce operations.\n\n:param pricebook_name: pricelist to use",
                "shortdoc": "Sets Pricebook to be used in Salesforce operations.",
                "tags": [],
                "matched": true
            },
            {
                "name": "Update Salesforce Object",
                "args": [
                    "object_type: str",
                    "object_id: str",
                    "object_data: typing.Any"
                ],
                "doc": "Update Salesfoce object by type, id and data.\n\n:param object_type: Salesforce object type\n:param object_id: Salesforce object id\n:param object_data: Salesforce object data\n:raises SalesforceDataNotAnDictionary: when `object_data` is not dictionary\n:return: True if successful",
                "shortdoc": "Update Salesfoce object by type, id and data.",
                "tags": [],
                "matched": true
            },
            {
                "name": "Upsert Salesforce Object",
                "args": [
                    "object_type: str",
                    "object_id: str",
                    "object_data: typing.Any"
                ],
                "doc": "Upsert Salesfoce object by type, id and data.\n\n:param object_type: Salesforce object type\n:param object_id: Salesforce object id\n:param object_data: Salesforce object data\n:raises SalesforceDataNotAnDictionary: when `object_data` is not dictionary\n:return: True if successful",
                "shortdoc": "Upsert Salesfoce object by type, id and data.",
                "tags": [],
                "matched": true
            }
        ],
        "all_tags": [],
        "contains_tags": false
    },
    "RPA.Slack": {
        "name": "RPA.Slack",
        "doc": "RPA Framework library for Slack operations.",
        "version": "",
        "named_args": true,
        "scope": "GLOBAL",
        "generated": "2020-12-01 14:53:06",
        "inits": [],
        "keywords": [
            {
                "name": "Slack Message Using Webhook",
                "args": [
                    "webhook_url: str",
                    "channel: str",
                    "sender: str",
                    "text: str",
                    "icon_emoji: str = None"
                ],
                "doc": "Send message to Slack channel using webhook.\n\n:param webhook_url: needs to be configured for the Slack server\n:param channel: channel needs to exist in the Slack server\n:param sender: shown in the message post as sender\n:param text: text for the message post\n:param icon_emoji: icon for the message post, defaults to None",
                "shortdoc": "Send message to Slack channel using webhook.",
                "tags": [],
                "matched": true
            }
        ],
        "all_tags": [],
        "contains_tags": false
    },
    "RPA.Tables": {
        "name": "RPA.Tables",
        "doc": "`Tables` is a library for manipulating tabular data inside Robot Framework.\n\nIt can import data from various sources and apply different operations to it.\nCommon use-cases are reading and writing CSV files, inspecting files in\ndirectories, or running tasks using existing Excel data.\n\n**Import types**\n\nThe data from which a table can be created can be of two main types:\n\n1. An iterable of individual rows, like a list of lists, or list of dictionaries\n2. A dictionary of columns, where each dictionary value is a list of values\n\nFor instance, these two input values:\n\n.. code-block:: python\n\n    data1 = [\n        {\"name\": \"Mark\", \"age\": 58},\n        {\"name\": \"John\", \"age\": 22},\n        {\"name\": \"Adam\", \"age\": 67},\n    ]\n\n    data2 = {\n        \"name\": [\"Mark\", \"John\", \"Adam\"],\n        \"age\":  [    58,     22,     67],\n    }\n\nWould both result in the following table:\n\n+-------+------+-----+\n| Index | Name | Age |\n+=======+======+=====+\n| 1     | Mark | 58  |\n+-------+------+-----+\n| 2     | John | 22  |\n+-------+------+-----+\n| 3     | Adam | 67  |\n+-------+------+-----+\n\n**Examples**\n\n**Robot Framework**\n\nThe `Tables` library can load tabular data from various other libraries\nand manipulate it inside Robot Framework.\n\n.. code-block:: robotframework\n\n    *** Settings ***\n    Library    RPA.Tables\n\n    *** Keywords ***\n    Files to Table\n        ${files}=    List files in directory    ${CURDIR}\n        ${files}=    Create table    ${files}\n        Filter table by column    ${files}    size  >=  ${1024}\n        FOR    ${file}    IN    @{files}\n            Log    ${file}[name]\n        END\n        Write table to CSV    ${files}    ${OUTPUT_DIR}${/}files.csv\n\n**Python**\n\nThe library is also available directly through Python, where it\nis easier to handle multiple different tables or do more bespoke\nmanipulation operations.\n\n.. code-block:: python\n\n    from RPA.Tables import Tables\n\n    library = Tables()\n    orders = library.read_table_from_csv(\n        \"orders.csv\", columns=[\"name\", \"mail\", \"product\"]\n    )\n\n    customers = library.group_table_by_column(rows, \"mail\")\n    for customer in customers:\n        for order in customer:\n            add_cart(order)\n        make_order()",
        "version": "",
        "named_args": true,
        "scope": "GLOBAL",
        "generated": "2020-12-01 14:53:06",
        "inits": [],
        "keywords": [
            {
                "name": "Add Table Column",
                "args": [
                    "table",
                    "name=None",
                    "values=None"
                ],
                "doc": "Append a column to a table.\n\n:param table:   table to modify\n:param name:    name of new column\n:param values:  row values (or single scalar value for all rows)",
                "shortdoc": "Append a column to a table.",
                "tags": [],
                "matched": true
            },
            {
                "name": "Add Table Row",
                "args": [
                    "table",
                    "row",
                    "index=None"
                ],
                "doc": "Append rows to a table.\n\n:param table:   table to modify\n:param row:     value for new row\n:param index:   index name for new row",
                "shortdoc": "Append rows to a table.",
                "tags": [],
                "matched": true
            },
            {
                "name": "Clear Table",
                "args": [
                    "table"
                ],
                "doc": "Clear table in-place, but keep columns.\n\n:param table:   table to clear",
                "shortdoc": "Clear table in-place, but keep columns.",
                "tags": [],
                "matched": true
            },
            {
                "name": "Copy Table",
                "args": [
                    "table"
                ],
                "doc": "Copy table object.\n\n:param table:   table to copy",
                "shortdoc": "Copy table object.",
                "tags": [],
                "matched": true
            },
            {
                "name": "Create Table",
                "args": [
                    "data=None",
                    "trim=False",
                    "columns=None",
                    "index=None"
                ],
                "doc": "Create Table object from data.\n\nData can be a combination of various iterable containers, e.g.\nlist of lists, list of dicts, dict of lists.\n\n:param data:    source data for table\n:param trim:    remove all empty rows from the end of the worksheet,\n                default `False`\n:param columns: names of columns (optional)\n:param index:   names of rows (optional)",
                "shortdoc": "Create Table object from data.",
                "tags": [],
                "matched": true
            },
            {
                "name": "Export Table",
                "args": [
                    "table",
                    "with_index=False",
                    "as_list=True"
                ],
                "doc": "Convert table object to standard Python containers.\n\n:param table:       table to convert to dict\n:param with_index:  include index in values\n:param as_list:     export data as list instead of dict",
                "shortdoc": "Convert table object to standard Python containers.",
                "tags": [],
                "matched": true
            },
            {
                "name": "Filter Empty Rows",
                "args": [
                    "table"
                ],
                "doc": "Remove all rows from the table which have only None values.\n\n:param table:   table to filter",
                "shortdoc": "Remove all rows from the table which have only None values.",
                "tags": [],
                "matched": true
            },
            {
                "name": "Filter Table By Column",
                "args": [
                    "table",
                    "column",
                    "operator",
                    "value"
                ],
                "doc": "Return all rows where the column values match the given condition.\n\n:param table:       table to filter\n:param column:      column to filter with\n:param operator:    filtering operator, e.g. >, <, ==, contains\n:param value:       value to compare column to (using operator)",
                "shortdoc": "Return all rows where the column values match the given condition.",
                "tags": [],
                "matched": true
            },
            {
                "name": "Find Table Rows",
                "args": [
                    "table",
                    "column",
                    "value",
                    "as_list=False"
                ],
                "doc": "Find a row in the table by a given column value.\n\n:param table:   Table to find from\n:param column:  name of column to search\n:param value:   value to match for\n:param as_list: return list instead of dictionary",
                "shortdoc": "Find a row in the table by a given column value.",
                "tags": [],
                "matched": true
            },
            {
                "name": "Get Table Cell",
                "args": [
                    "table",
                    "row",
                    "column"
                ],
                "doc": "Get a cell value from table.\n\n:param table:   table to read from\n:param row:     row of cell\n:param column:  column of cell",
                "shortdoc": "Get a cell value from table.",
                "tags": [],
                "matched": true
            },
            {
                "name": "Get Table Column",
                "args": [
                    "table",
                    "column",
                    "as_list=False"
                ],
                "doc": "Get all column values from table.\n\n:param table:   table to read\n:param column:  column to read\n:param as_list: return list instead of dictionary",
                "shortdoc": "Get all column values from table.",
                "tags": [],
                "matched": true
            },
            {
                "name": "Get Table Dimensions",
                "args": [
                    "table"
                ],
                "doc": "Return table dimensions, as (rows, columns).\n\n:param table:    table to inspect",
                "shortdoc": "Return table dimensions, as (rows, columns).",
                "tags": [],
                "matched": true
            },
            {
                "name": "Get Table Row",
                "args": [
                    "table",
                    "index",
                    "as_list=False"
                ],
                "doc": "Get a single row from table.\n\n:param table:   table to read\n:param row:     row to read\n:param as_list: return list instead of dictionary",
                "shortdoc": "Get a single row from table.",
                "tags": [],
                "matched": true
            },
            {
                "name": "Get Table Slice",
                "args": [
                    "table",
                    "start=None",
                    "end=None"
                ],
                "doc": "Return a new Table from a subset of given Table rows.\n\n:param table:   table to read from\n:param start:   start index (inclusive)\n:param start:   end index (inclusive)",
                "shortdoc": "Return a new Table from a subset of given Table rows.",
                "tags": [],
                "matched": true
            },
            {
                "name": "Group Table By Column",
                "args": [
                    "table",
                    "column"
                ],
                "doc": "Group table by `column` and return a list of grouped Tables.\n\n:param table:   table to use for grouping\n:param column:  column which is used as grouping criteria",
                "shortdoc": "Group table by `column` and return a list of grouped Tables.",
                "tags": [],
                "matched": true
            },
            {
                "name": "Merge Tables",
                "args": [
                    "*tables",
                    "index=None"
                ],
                "doc": "Create a union of two tables and their contents.\n\n:param tables: Tables to merge\n:param index:  Column name to use as index for merge\n\nBy default rows from all tables are appended one after the other.\nOptionally a column name can be given with ``index``, which is\nused to merge rows together.\n\nExample:\n\nFor instance, a ``name`` column could be used to identify\nunique rows and the merge operation should overwrite values\ninstead of appending multiple copies of the same name.\n\n====== =====\nName   Price\n====== =====\nEgg    10.0\nCheese 15.0\nHam    20.0\n====== =====\n\n====== =====\nName   Stock\n====== =====\nEgg    12.0\nCheese 99.0\nHam    0.0\n====== =====\n\n.. code-block:: robotframework\n\n    ${products}=    Merge tables    ${prices}    ${stock}    index=Name\n    FOR    ${product}    IN    @{products}\n        Log many\n        ...    Product: ${product}[Name]\n        ...    Price: ${product}[Price]\n        ...    Stock: ${product}[Stock]\n    END",
                "shortdoc": "Create a union of two tables and their contents.",
                "tags": [],
                "matched": true
            },
            {
                "name": "Pop Table Column",
                "args": [
                    "table",
                    "column=None",
                    "as_list=False"
                ],
                "doc": "Remove column from table and return it.\n\n:param table:   table to modify\n:param column:  column to remove\n:param as_list: return list instead of dictionary",
                "shortdoc": "Remove column from table and return it.",
                "tags": [],
                "matched": true
            },
            {
                "name": "Pop Table Row",
                "args": [
                    "table",
                    "index=None",
                    "as_list=False"
                ],
                "doc": "Remove row from table and return it.\n\n:param table:   table to modify\n:param index:   row index, pops first row if none given\n:param as_list: return list instead of dictionary",
                "shortdoc": "Remove row from table and return it.",
                "tags": [],
                "matched": true
            },
            {
                "name": "Read Table From Csv",
                "args": [
                    "path",
                    "header=None",
                    "columns=None",
                    "dialect=None",
                    "delimiters=None"
                ],
                "doc": "Read a CSV file as a table.\n\n:param path:        path to CSV file\n:param header:      CSV file includes header\n:param columns:     names of columns in resulting table\n:param dialect:     format of CSV file\n:param delimiters:  string of possible delimiters\n\nBy default attempts to deduce the CSV format and headers\nfrom a sample of the input file. If it's unable to determine\nthe format automatically, the dialect and header will\nhave to be defined manually.\n\nValid ``dialect`` values are ``excel``, ``excel-tab``, and ``unix``,\nand ``header`` is boolean argument (``True``/``False``). Optionally a\nset of valid ``delimiters`` can be given as a string.\n\nThe ``columns`` argument can be used to override the names of columns\nin the resulting table. The amount of columns must match the input\ndata.",
                "shortdoc": "Read a CSV file as a table.",
                "tags": [],
                "matched": true
            },
            {
                "name": "Rename Table Columns",
                "args": [
                    "table",
                    "columns",
                    "strict=False"
                ],
                "doc": "Renames columns in the Table with given values. Columns with\nname as `None` will be use previous value.\n\n:param table:   table to modify\n:param columns: list of new column names\n:param strict:  if True, raises ValueError if column lengths\n                do not match",
                "shortdoc": "Renames columns in the Table with given values. Columns with name as `None` will be use previous value.",
                "tags": [],
                "matched": true
            },
            {
                "name": "Set Column As Index",
                "args": [
                    "table",
                    "column=None"
                ],
                "doc": "Set existing column as index for rows.\n\n:param table:   table to modify\n:param column:  column to convert to index",
                "shortdoc": "Set existing column as index for rows.",
                "tags": [],
                "matched": true
            },
            {
                "name": "Set Row As Column Names",
                "args": [
                    "table",
                    "index"
                ],
                "doc": "Set existing row as names for columns.\n\n:param table: table to modify\n:param index: row to use as column names",
                "shortdoc": "Set existing row as names for columns.",
                "tags": [],
                "matched": true
            },
            {
                "name": "Set Table Cell",
                "args": [
                    "table",
                    "row",
                    "column",
                    "value"
                ],
                "doc": "Set a cell value in the table.\n\n:param table:   table to modify to\n:param row:     row of cell\n:param column:  column of cell\n:param value:   value to set",
                "shortdoc": "Set a cell value in the table.",
                "tags": [],
                "matched": true
            },
            {
                "name": "Set Table Column",
                "args": [
                    "table",
                    "column",
                    "values"
                ],
                "doc": "Assign values to entire column in the table.\n\n:param table:   table to modify\n:param column:  column to modify\n:param values:  value(s) to set",
                "shortdoc": "Assign values to entire column in the table.",
                "tags": [],
                "matched": true
            },
            {
                "name": "Set Table Row",
                "args": [
                    "table",
                    "row",
                    "values"
                ],
                "doc": "Assign values to a row in the table.\n\n:param table:   table to modify\n:param row:     row to modify\n:param values:  value(s) to set",
                "shortdoc": "Assign values to a row in the table.",
                "tags": [],
                "matched": true
            },
            {
                "name": "Sort Table By Column",
                "args": [
                    "table",
                    "column",
                    "ascending=False"
                ],
                "doc": "Sort table in-place according to `column`.\n\n:param table:       table to sort\n:param column:      column to sort with\n:param ascending:   table sort order",
                "shortdoc": "Sort table in-place according to `column`.",
                "tags": [],
                "matched": true
            },
            {
                "name": "Table Head",
                "args": [
                    "table",
                    "count=5",
                    "as_list=False"
                ],
                "doc": "Return first `count` rows from table.\n\n:param table:   table to read from\n:param count:   number of lines to read\n:param as_list: return list instead of Table",
                "shortdoc": "Return first `count` rows from table.",
                "tags": [],
                "matched": true
            },
            {
                "name": "Table Tail",
                "args": [
                    "table",
                    "count=5",
                    "as_list=False"
                ],
                "doc": "Return last `count` rows from table.\n\n:param table:   table to read from\n:param count:   number of lines to read\n:param as_list: return list instead of Table",
                "shortdoc": "Return last `count` rows from table.",
                "tags": [],
                "matched": true
            },
            {
                "name": "Trim Column Names",
                "args": [
                    "table"
                ],
                "doc": "Remove all extraneous whitespace from column names.",
                "shortdoc": "Remove all extraneous whitespace from column names.",
                "tags": [],
                "matched": true
            },
            {
                "name": "Trim Empty Rows",
                "args": [
                    "table"
                ],
                "doc": "Remove all rows from the end of the table\nwhich have only None values.\n\n:param table:    table to filter",
                "shortdoc": "Remove all rows from the end of the table which have only None values.",
                "tags": [],
                "matched": true
            },
            {
                "name": "Write Table To Csv",
                "args": [
                    "table",
                    "path",
                    "header=True",
                    "dialect=excel"
                ],
                "doc": "Write a table as a CSV file.\n\n:param path:    path to write to\n:param table:   table to write\n:param header:  write columns as header to CSV file\n:param dialect: the format of output CSV\n\nValid ``dialect`` values are ``excel``, ``excel-tab``, and ``unix``.",
                "shortdoc": "Write a table as a CSV file.",
                "tags": [],
                "matched": true
            }
        ],
        "all_tags": [],
        "contains_tags": false
    },
    "RPA.Tasks": {
        "name": "RPA.Tasks",
        "doc": "`Tasks` is a library for controlling task execution during a Robot Framework run.\n\nIt allows conditional branching between tasks, loops and jumps, and optionally\nvalidating the execution through a schema file. It can also be used to\nvisualize the tasks as a graph.\n\n.. _model:\n\n**Execution model**\n\nIn a typical Robot Framework run, tasks are ordered linearly in a file and\nthey're executed in definition order. Events that happen during\nthe execution can not affect the order and only have the option to fail the task\nor continue as defined.\n\nUsing the `Tasks` library, it's possible to change this model according\nto different states or inputs. The execution will start by running a single\nstart task from the suite, and then according to user-defined keywords or\nschema rules select the next task. Any task which is defined in the same file\ncan be used, and the same task can also be used multiple times during a single\nexecution.\n\n.. _execution-example:\n\nExample:\n\nAs an example, the following Robot Framework file describes a process where\na task would have to be executed multiple times before a condition is reached.\nIn a real-world scenario, these tasks would be more complicated, instead of just\nincrementing numbers.\n\n.. code-block:: robotframework\n\n    *** Settings ***\n    Library    RPA.Tasks\n\n    *** Variables ***\n    ${CURRENT}    ${1}\n    ${TARGET}     ${5}\n\n    *** Tasks ***\n    Check loop condition\n        Log    I'm trying to count to ${TARGET}\n        Set next task if    ${CURRENT} >= ${TARGET}\n        ...    Target reached\n        ...    Increment current number\n\n    This will not run\n        Fail    This should never run\n\n    Increment current number\n        Set suite variable    ${CURRENT}    ${CURRENT + 1}\n        Log    Number is now ${CURRENT}\n        Jump to task    Check loop condition\n\n    Target reached\n        Log    Those are some good numbers!\n\nThe execution for this example would go as follows:\n\n1. It starts from ``Check loop condition``, as it's the first task in the file.\n2. During the first task, the keyword ``Set next task if`` is called, which queues\n   up the next task according to a condition.\n3. In the initial state, we have not reached the target number, and will next run\n   the task ``Increment current number``.\n4. The second task executes normally and in the end jumps back to the first\n   task using the keyword ``Jump to task``.\n5. The above sequence is repeated until the condition is met, and we move to\n   the final task of the file. This final task does not schedule further tasks\n   and the execution ends.\n\nYou can also note the task ``This will not run``, which as the name implies\nis never executed, as no other task schedules or jumps to it.\n\nThe console log from the above execution shows how the same task is executed\nmultiple times:\n\n.. code-block:: console\n\n    ==============================================================================\n    Incrementing Process\n    ==============================================================================\n    #1   Check loop condition                                             | PASS |\n    Transition: Set by keyword\n    ------------------------------------------------------------------------------\n    #2   Increment current number                                         | PASS |\n    Transition: Set by keyword\n    ------------------------------------------------------------------------------\n    #3   Check loop condition                                             | PASS |\n    Transition: Set by keyword\n    ------------------------------------------------------------------------------\n    #4   Increment current number                                         | PASS |\n    Transition: Set by keyword\n    ------------------------------------------------------------------------------\n    #5   Check loop condition                                             | PASS |\n    Transition: Set by keyword\n    ------------------------------------------------------------------------------\n    #6   Increment current number                                         | PASS |\n    Transition: Set by keyword\n    ------------------------------------------------------------------------------\n    #7   Check loop condition                                             | PASS |\n    Transition: Set by keyword\n    ------------------------------------------------------------------------------\n    #8   Increment current number                                         | PASS |\n    Transition: Set by keyword\n    ------------------------------------------------------------------------------\n    #9   Check loop condition                                             | PASS |\n    Transition: Set by keyword\n    ------------------------------------------------------------------------------\n    #10  Target reached                                                   | PASS |\n    ------------------------------------------------------------------------------\n    Incrementing Process:: [/graph_incrementing_process.svg]              | PASS |\n    10 critical tasks, 10 passed, 0 failed\n    10 tasks total, 10 passed, 0 failed\n    ==============================================================================\n\n.. _graph:\n\n**Graph**\n\nA common way to document a process is through a directed graph. These graphs\nare usually drawn manually and describe the expected higher level steps.\nThe actual implementation itself follows a different path through a graph,\ndepending on inputs or implementation details. This library visualizes this\nexecution graph using the `Graphviz <https://graphviz.org>`_ tool.\n\nAfter the execution is finished, it will create a\n`DOT <https://en.wikipedia.org/wiki/DOT_(graph_description_language)>`_ file\nand render it as an image. This image will automatically be appended\nto the suite's documentation field.\n\n**Requirements**\n\nDrawing the graph requires a working installation of\n`Graphviz <https://graphviz.org>`_. This can be installed through their\nwebsite or by using `Conda <https://docs.conda.io/>`_.\n\nThis requirement is optional for the functioning of this library, and will\ndisplay a warning if the tool is not available. The visualization\ncan be entirely disabled with the ``graph`` argument during library\ninitialization.\n\n.. _schema:\n\n**Schema**\n\nThere is an option to define a schema file for the suite, which is written in JSON.\nThis file will be used to validate the actual execution and fail it if an unexpected\ntransition between tasks happens. It can also define rules for selecting the next\ntask, which allows separating the task and process definitions.\n\nExample:\n\nThe execution-example shown previously used keywords to control\nthe execution. This can also be done using the following schema:\n\n.. code-block:: json\n\n    {\n        \"tasks\": {\n            \"Check loop condition\": {\n                \"alias\": \"check\",\n                \"start\": true,\n                \"next\": [\n                    \"increment\",\n                    \"target\"\n                ],\n                \"actions\": [\n                    {\n                        \"condition\": \"$CURRENT >= $TARGET\",\n                        \"task\": \"target\"\n                    },\n                    {\n                        \"condition\": \"$CURRENT < $TARGET\",\n                        \"task\": \"increment\"\n                    }\n                ]\n            },\n            \"Increment current number\": {\n                \"alias\": \"increment\",\n                \"next\": [\n                    \"check\"\n                ],\n                \"actions\": [\n                    {\n                        \"status\": \"PASS\",\n                        \"task\": \"check\"\n                    }\n                ]\n            },\n            \"Target reached\": {\n                \"alias\": \"target\",\n                \"end\": true,\n                \"next\": []\n            }\n        }\n    }\n\nThis has the added benefit of protecting against implementation errors,\nas the library will validate the start and end tasks, and transitions between\ndifferent tasks.\n\nAfter this schema has been taken into use, the aforementioned example\nwill reduce to the following:\n\n.. code-block:: robotframework\n\n    *** Settings ***\n    Library    RPA.Tasks    schema=counter-schema.json\n\n    *** Variables ***\n    ${CURRENT}    ${1}\n    ${TARGET}     ${5}\n\n    *** Tasks ***\n    Check loop condition\n        Log    I'm trying to count to ${TARGET}\n\n    This will not run\n        Fail    This should never run\n\n    Increment current number\n        Set suite variable    ${CURRENT}    ${CURRENT + 1}\n        Log    Number is now ${CURRENT}\n\n    Target reached\n        Log    Those are some good numbers!\n\n**Format**\n\nThe current format is JSON with the following structure:\n\n.. code-block:: javascript\n\n    {\n        \"tasks\": {\n            [name: string]: {\n                \"alias\": string,\n                \"start\": boolean,\n                \"end\": boolean,\n                \"next\": string[],\n                \"actions\": action[],\n            }\n        }\n    }\n\nEach schema is a map of tasks with various properties. The keys must\nmatch the task names in the Robot Framework file definition. All properties\ninside the task are optional.\n\nThe available properties and their uses:\n\n- *alias*:   Define a short name for the task, which can be used as a reference\n             inside the schema.\n- *start*:   Start task for execution. There can be only one task with this\n             enabled. If not defined, will default to first task in the file.\n- *end*:     Valid end task for execution. There can be multiple tasks with this\n             enabled. Fails the execution if this is defined for any task and the\n             execution stops in a non-end task.\n- *next*:    List of valid tasks to transition to from this task. Supports\n             alias definitions.\n- *actions*: List of actions that are executed at the end of the task.\n             See section below for details.\n\nThe types of actions:\n\n- *exception*: Set the next task if a matching exception occurs.\n               Matches the exception message as regex.\n- *condition*: Set the next task if a conditional expression is true.\n               Allows using Robot Framework variables.\n- *status*:    Set the next task if the current task's result matches,\n               e.g. PASS or FAIL.\n\nExamples of actions:\n\n.. code-block:: json\n\n    [\n        {\"exception\": \".*ValueError.*\", \"task\": \"Invalid input values\"},\n        {\"condition\": \"$ATTEMPTS > 10\", \"task\": \"Too many attempts\"},\n        {\"status\": \"PASS\", \"task\": \"Success state\"}\n    ]",
        "version": "",
        "named_args": true,
        "scope": "GLOBAL",
        "generated": "2020-12-01 14:53:06",
        "inits": [
            {
                "name": "Init",
                "args": [
                    "execution_limit=1024",
                    "schema=None",
                    "graph=True",
                    "graph_inline=True"
                ],
                "doc": "There are a few arguments for controlling the Tasks library.\n\n:param execution_limit: Maximum number of tasks to run in suite,\n                        used to prevent infinite loops\n:param schema:          Path to optional schema file\n:param graph:           Render execution result as graph using graphviz\n:param graph_inline:    Inline graph into log, instead of saving as file",
                "shortdoc": "There are a few arguments for controlling the Tasks library.",
                "tags": [],
                "matched": true
            }
        ],
        "keywords": [
            {
                "name": "Jump To Task",
                "args": [
                    "name"
                ],
                "doc": "Jump directly to given task, skipping the rest of the task\nexecution. If run inside a teardown, also skips the rest of the\nteardown sequence.",
                "shortdoc": "Jump directly to given task, skipping the rest of the task execution. If run inside a teardown, also skips the rest of the teardown sequence.",
                "tags": [],
                "matched": true
            },
            {
                "name": "Jump To Task If",
                "args": [
                    "condition",
                    "name",
                    "default=None"
                ],
                "doc": "Jump directly to given task according to the condition.",
                "shortdoc": "Jump directly to given task according to the condition.",
                "tags": [],
                "matched": true
            },
            {
                "name": "Jump To Task If Keyword Fails",
                "args": [
                    "task",
                    "keyword",
                    "*args"
                ],
                "doc": "Executes given keyword and jumps to given task if it fails.",
                "shortdoc": "Executes given keyword and jumps to given task if it fails.",
                "tags": [],
                "matched": true
            },
            {
                "name": "Jump To Task If Keyword Succeeds",
                "args": [
                    "task",
                    "keyword",
                    "*args"
                ],
                "doc": "Executes given keyword and jumps to given task if it succeeds.",
                "shortdoc": "Executes given keyword and jumps to given task if it succeeds.",
                "tags": [],
                "matched": true
            },
            {
                "name": "Set Next Task",
                "args": [
                    "name"
                ],
                "doc": "Set the next task to be executed.\nShould be a task in the same suite.\n\n:param name: Name of next task",
                "shortdoc": "Set the next task to be executed. Should be a task in the same suite.",
                "tags": [],
                "matched": true
            },
            {
                "name": "Set Next Task If",
                "args": [
                    "condition",
                    "name",
                    "default=None"
                ],
                "doc": "Set the next task according to the condition.\nIf no default is given, does not modify execution order.\n\n:param condition: Condition expression to evaluate\n:param name:      Name of next task, if successful\n:param default:   Name of next task, if unsuccessful",
                "shortdoc": "Set the next task according to the condition. If no default is given, does not modify execution order.",
                "tags": [],
                "matched": true
            },
            {
                "name": "Set Next Task If Keyword Fails",
                "args": [
                    "task",
                    "keyword",
                    "*args"
                ],
                "doc": "Executes given keyword and sets the next task if it fails.",
                "shortdoc": "Executes given keyword and sets the next task if it fails.",
                "tags": [],
                "matched": true
            },
            {
                "name": "Set Next Task If Keyword Succeeds",
                "args": [
                    "task",
                    "keyword",
                    "*args"
                ],
                "doc": "Executes given keyword and sets the next task if it succeeds.",
                "shortdoc": "Executes given keyword and sets the next task if it succeeds.",
                "tags": [],
                "matched": true
            }
        ],
        "all_tags": [],
        "contains_tags": false
    },
    "RPA.Twitter": {
        "name": "RPA.Twitter",
        "doc": "`Twitter` is a library for accessing Twitter using developer API.\nThe library extends `tweepy`_ library.\n\nAuthorization credentials can be given as parameters for ``authorize`` keyword\nor keyword can read them in as environment variables:\n\n- `TWITTER_CONSUMER_KEY`\n- `TWITTER_CONSUMER_SECRET`\n- `TWITTER_ACCESS_TOKEN`\n- `TWITTER_ACCESS_TOKEN_SECRET`\n\nLibrary usage requires Twitter developer credentials.\nThose can be requested from `Twitter developer site`_\n\n.. _tweepy:\n    http://docs.tweepy.org/en/latest/index.html\n\n.. _Twitter developer site:\n    https://developer.twitter.com/\n\n**Examples**\n\n.. code-block:: robotframework\n\n    *** Settings ***\n    Library   RPA.Twitter\n\n    *** Tasks ***\n    Get user tweets and like them\n        [Setup]   Authorize\n        @{tweets}=   Get User Tweets   username=niinisto   count=5\n        FOR   ${tweet}  IN   @{tweets}\n            Like   ${tweet}\n        END\n\n.. code-block:: python\n\n    from RPA.Twitter import Twitter\n\n    library = Twitter()\n    library.authorize()\n    tweets = library.get_user_tweets(username=\"niinisto\", count=5)\n    for tw in tweets:\n        library.like(tw)\n    tweets = library.text_search_tweets(query=\"corona trump\")\n    for tw in tweets:\n        print(tw.text)\n    user = library.get_user_profile(\"niinisto\")\n    library.follow(user)\n    library.tweet(\"first tweet\")\n    me = library.get_me()\n    print(me)",
        "version": "",
        "named_args": true,
        "scope": "GLOBAL",
        "generated": "2020-12-01 14:53:06",
        "inits": [],
        "keywords": [
            {
                "name": "Authorize",
                "args": [
                    "consumer_key: str = None",
                    "consumer_secret: str = None",
                    "access_token: str = None",
                    "access_token_secret: str = None"
                ],
                "doc": "Authorize to Twitter API\n\n:param consumer_key: app consumer key\n:param consumer_secret: app consumer secret\n:param access_token: user access token\n:param access_token_secret: user access token secret",
                "shortdoc": "Authorize to Twitter API",
                "tags": [],
                "matched": true
            },
            {
                "name": "Follow",
                "args": [
                    "user: str = None"
                ],
                "doc": "Follow Twitter user\n\n:param user: screen name of the user\n:return:  `True` if user was followed, `False` if not",
                "shortdoc": "Follow Twitter user",
                "tags": [],
                "matched": true
            },
            {
                "name": "Get Me",
                "args": [],
                "doc": "Get Twitter profile of authenticated user\n\n:return: user profile as dictionary or `None`",
                "shortdoc": "Get Twitter profile of authenticated user",
                "tags": [],
                "matched": true
            },
            {
                "name": "Get User Profile",
                "args": [
                    "username: str = None"
                ],
                "doc": "Get user's Twitter profile\n\n:param username: whose profile to get\n:return: profile as dictionary",
                "shortdoc": "Get user's Twitter profile",
                "tags": [],
                "matched": true
            },
            {
                "name": "Get User Tweets",
                "args": [
                    "username: str = None",
                    "count: int = 100"
                ],
                "doc": "Get user tweets\n\n:param username: whose tweets to get\n:param count: maximum number of tweets, defaults to 100\n:return: list of user tweets",
                "shortdoc": "Get user tweets",
                "tags": [],
                "matched": true
            },
            {
                "name": "Like",
                "args": [
                    "tweet: Tweet = None"
                ],
                "doc": "Like a tweet\n\n:param tweet: as a class `Tweet`\n:return: `True` if Tweet was liked, `False` if not",
                "shortdoc": "Like a tweet",
                "tags": [],
                "matched": true
            },
            {
                "name": "Text Search Tweets",
                "args": [
                    "query: str = None",
                    "count: int = 100",
                    "geocode: str = None",
                    "lang: str = None",
                    "locale: str = None",
                    "result_type: str = mixed",
                    "until: str = None",
                    "since_id: str = None",
                    "max_id: str = None"
                ],
                "doc": "Search tweets defined by search query\n\nResults types:\n\n- mixed : include both popular and real time results in the response\n- recent : return only the most recent results in the response\n- popular : return only the most popular results in the response\n\n:param query: search query string of 500 characters maximum,\n    including operators\n:param count: maximum number of tweets, defaults to 100\n:param geocode: tweets by users located within a given\n    radius of the given latitude/longitude\n:param lang: language code of tweets\n:param locale: language of the query you are sending\n:param result_type: type of search results you would prefer to receive,\n    default \"mixed\"\n:param until: tweets created before the given date\n:param since_id: Returns only statuses with an ID greater than\n:param max_id: only statuses with an ID less than\n:return: list of matching tweets",
                "shortdoc": "Search tweets defined by search query",
                "tags": [],
                "matched": true
            },
            {
                "name": "Tweet",
                "args": [
                    "content: str = None"
                ],
                "doc": "Make a tweet with content\n\n:param content: text for the status update",
                "shortdoc": "Make a tweet with content",
                "tags": [],
                "matched": true
            },
            {
                "name": "Unfollow",
                "args": [
                    "user: str = None"
                ],
                "doc": "Unfollow Twitter user\n\n:param user: screen name of the user\n:return:  `True` if user was followed, `False` if not",
                "shortdoc": "Unfollow Twitter user",
                "tags": [],
                "matched": true
            },
            {
                "name": "Unlike",
                "args": [
                    "tweet: Tweet = None"
                ],
                "doc": "Unlike a tweet\n\n:param tweet: as a class `Tweet`\n:return: `True` if Tweet was unliked, `False` if not",
                "shortdoc": "Unlike a tweet",
                "tags": [],
                "matched": true
            }
        ],
        "all_tags": [],
        "contains_tags": false
    },
    "RPA.Word.Application": {
        "name": "RPA.Word.Application",
        "doc": "`Word.Application` is a library for controlling a Word application.\n\n**Examples**\n\n**Robot Framework**\n\n.. code-block:: robotframework\n\n    *** Settings ***\n    Library                 RPA.Word.Application\n    Task Setup              Open Application\n    Suite Teardown          Quit Application\n\n    *** Tasks ***\n    Open existing file\n        Open File           old.docx\n        Write Text          Extra Line Text\n        Write Text          Another Extra Line of Text\n        Save Document AS    ${CURDIR}${/}new.docx\n        ${texts}=           Get all Texts\n        Close Document\n\n**Python**\n\n.. code-block:: python\n\n    from RPA.Word.Application import Application\n\n    app = Application()\n    app.open_application()\n    app.open_file('old.docx')\n    app.write_text('Extra Line Text')\n    app.save_document_as('new.docx')\n    app.quit_application()",
        "version": "",
        "named_args": true,
        "scope": "GLOBAL",
        "generated": "2020-12-01 14:53:06",
        "inits": [],
        "keywords": [
            {
                "name": "Close Document",
                "args": [
                    "save_changes: bool = False"
                ],
                "doc": "Close the active document (if open).",
                "shortdoc": "Close the active document (if open).",
                "tags": [],
                "matched": true
            },
            {
                "name": "Create New Document",
                "args": [],
                "doc": "Create new document for Word application",
                "shortdoc": "Create new document for Word application",
                "tags": [],
                "matched": true
            },
            {
                "name": "Export To Pdf",
                "args": [
                    "filename: str"
                ],
                "doc": "Export active document into PDF file.\n\n:param filename: PDF to export WORD into",
                "shortdoc": "Export active document into PDF file.",
                "tags": [],
                "matched": true
            },
            {
                "name": "Get All Texts",
                "args": [],
                "doc": "Get all texts from active document\n\n:return: texts",
                "shortdoc": "Get all texts from active document",
                "tags": [],
                "matched": true
            },
            {
                "name": "Open Application",
                "args": [
                    "visible: bool = False",
                    "display_alerts: bool = False"
                ],
                "doc": "Open the Word application.\n\n:param visible: show window after opening\n:param display_alerts: show alert popups",
                "shortdoc": "Open the Word application.",
                "tags": [],
                "matched": true
            },
            {
                "name": "Open File",
                "args": [
                    "filename: str = None"
                ],
                "doc": "Open Word document with filename.\n\n:param filename: Word document filepath, defaults to None",
                "shortdoc": "Open Word document with filename.",
                "tags": [],
                "matched": true
            },
            {
                "name": "Quit Application",
                "args": [
                    "save_changes: bool = False"
                ],
                "doc": "Quit the application.",
                "shortdoc": "Quit the application.",
                "tags": [],
                "matched": true
            },
            {
                "name": "Replace Text",
                "args": [
                    "find: str",
                    "replace: str"
                ],
                "doc": "Replace text in active document\n\n:param find: text to replace\n:param replace: new text",
                "shortdoc": "Replace text in active document",
                "tags": [],
                "matched": true
            },
            {
                "name": "Save Document",
                "args": [],
                "doc": "Save active document",
                "shortdoc": "Save active document",
                "tags": [],
                "matched": true
            },
            {
                "name": "Save Document As",
                "args": [
                    "filename: str",
                    "fileformat: str = None"
                ],
                "doc": "Save document with filename and optionally with given fileformat\n\n:param filename: where to save document\n:param fileformat: see @FILEFORMATS dictionary for possible format,\n    defaults to None",
                "shortdoc": "Save document with filename and optionally with given fileformat",
                "tags": [],
                "matched": true
            },
            {
                "name": "Set Footer",
                "args": [
                    "text: str"
                ],
                "doc": "Set footer for the active document\n\n:param text: footer text to set",
                "shortdoc": "Set footer for the active document",
                "tags": [],
                "matched": true
            },
            {
                "name": "Set Header",
                "args": [
                    "text: str"
                ],
                "doc": "Set header for the active document\n\n:param text: header text to set",
                "shortdoc": "Set header for the active document",
                "tags": [],
                "matched": true
            },
            {
                "name": "Write Text",
                "args": [
                    "text: str",
                    "newline: bool = True"
                ],
                "doc": "Writes given text at the end of the document\n\n:param text: string to write\n:param newline: write text to newline if True, default to True",
                "shortdoc": "Writes given text at the end of the document",
                "tags": [],
                "matched": true
            }
        ],
        "all_tags": [],
        "contains_tags": false
    },
    "RPA.core.decorators": {
        "name": "RPA.core.decorators",
        "doc": "Documentation for library ``RPA.core.decorators``.",
        "version": "",
        "named_args": true,
        "scope": "GLOBAL",
        "generated": "2020-12-01 14:53:06",
        "inits": [],
        "keywords": [
            {
                "name": "Operating System Required",
                "args": [
                    "*systems"
                ],
                "doc": "Decorator to restrict method for specified operating system\n\n:param systems: operating systems in string format\n    e.g. \"Linux,Darwin\", default 'Windows'",
                "shortdoc": "Decorator to restrict method for specified operating system",
                "tags": [],
                "matched": true
            },
            {
                "name": "Wraps",
                "args": [
                    "wrapped",
                    "assigned=('__module__', '__name__', '__qualname__', '__doc__', '__annotations__')",
                    "updated=('__dict__',)"
                ],
                "doc": "Decorator factory to apply update_wrapper() to a wrapper function\n\nReturns a decorator that invokes update_wrapper() with the decorated\nfunction as the wrapper argument and the arguments to wraps() as the\nremaining arguments. Default arguments are as for update_wrapper().\nThis is a convenience function to simplify applying partial() to\nupdate_wrapper().",
                "shortdoc": "Decorator factory to apply update_wrapper() to a wrapper function",
                "tags": [],
                "matched": true
            }
        ],
        "all_tags": [],
        "contains_tags": false
    },
    "RPA.core.geometry": {
        "name": "RPA.core.geometry",
        "doc": "Documentation for library ``RPA.core.geometry``.",
        "version": "",
        "named_args": true,
        "scope": "GLOBAL",
        "generated": "2020-12-01 14:53:06",
        "inits": [],
        "keywords": [
            {
                "name": "Astuple",
                "args": [
                    "obj",
                    "*",
                    "tuple_factory=<class 'tuple'>"
                ],
                "doc": "Return the fields of a dataclass instance as a new tuple of field values.\n\nExample usage::\n\n  @dataclass\n  class C:\n      x: int\n      y: int\n\nc = C(1, 2)\nassert astuple(c) == (1, 2)\n\nIf given, 'tuple_factory' will be used instead of built-in tuple.\nThe function applies recursively to field values that are\ndataclass instances. This will also look into built-in containers:\ntuples, lists, and dicts.",
                "shortdoc": "Return the fields of a dataclass instance as a new tuple of field values.",
                "tags": [],
                "matched": true
            },
            {
                "name": "Dataclass",
                "args": [
                    "cls=None",
                    "*",
                    "init=True",
                    "repr=True",
                    "eq=True",
                    "order=False",
                    "unsafe_hash=False",
                    "frozen=False"
                ],
                "doc": "Returns the same class as was passed in, with dunder methods\nadded based on the fields defined in the class.\n\nExamines PEP 526 __annotations__ to determine fields.\n\nIf init is true, an __init__() method is added to the class. If\nrepr is true, a __repr__() method is added. If order is true, rich\ncomparison dunder methods are added. If unsafe_hash is true, a\n__hash__() method function is added. If frozen is true, fields may\nnot be assigned to after instance creation.",
                "shortdoc": "Returns the same class as was passed in, with dunder methods added based on the fields defined in the class.",
                "tags": [],
                "matched": true
            },
            {
                "name": "To Point",
                "args": [
                    "obj: typing.Any"
                ],
                "doc": "Convert `obj` to instance of Point.",
                "shortdoc": "Convert `obj` to instance of Point.",
                "tags": [],
                "matched": true
            },
            {
                "name": "To Region",
                "args": [
                    "obj: typing.Any"
                ],
                "doc": "Convert `obj` to instance of Region.",
                "shortdoc": "Convert `obj` to instance of Region.",
                "tags": [],
                "matched": true
            }
        ],
        "all_tags": [],
        "contains_tags": false
    },
    "RPA.core.helpers": {
        "name": "RPA.core.helpers",
        "doc": "Documentation for library ``RPA.core.helpers``.",
        "version": "",
        "named_args": true,
        "scope": "GLOBAL",
        "generated": "2020-12-01 14:53:06",
        "inits": [],
        "keywords": [
            {
                "name": "Clean Filename",
                "args": [
                    "filename: str",
                    "replace: str =  "
                ],
                "doc": "Clean filename to valid format which can be used file operations.\n\n:param filename: name to be cleaned\n:param replace: characters to replace with underscore, defaults to \" \"\n:return: valid filename",
                "shortdoc": "Clean filename to valid format which can be used file operations.",
                "tags": [],
                "matched": true
            },
            {
                "name": "Delay",
                "args": [
                    "sleeptime: float = 0.0"
                ],
                "doc": "Delay execution for given amount of seconds.\n\n:param sleeptime: seconds as float, defaults to 0",
                "shortdoc": "Delay execution for given amount of seconds.",
                "tags": [],
                "matched": true
            },
            {
                "name": "Import By Name",
                "args": [
                    "name: str",
                    "caller: str = None"
                ],
                "doc": "Import module (or attribute) by name.\n\n:param name: Import path, e.g. RPA.WorkItems.RobocloudAdapter",
                "shortdoc": "Import module (or attribute) by name.",
                "tags": [],
                "matched": true
            },
            {
                "name": "Required Env",
                "args": [
                    "name: str",
                    "default: typing.Any = <object object at 0x159397700>"
                ],
                "doc": "Load required environment variable.\n\n:param name: Name of environment variable\n:param default: Value to use if variable is undefined.\n                If not given and variable is undefined, raises KeyError.",
                "shortdoc": "Load required environment variable.",
                "tags": [],
                "matched": true
            },
            {
                "name": "Required Param",
                "args": [
                    "param_name: typing.Any = None",
                    "method_name: str = None"
                ],
                "doc": "Check that required parameter is not None",
                "shortdoc": "Check that required parameter is not None",
                "tags": [],
                "matched": true
            }
        ],
        "all_tags": [],
        "contains_tags": false
    },
    "RPA.core.locators": {
        "name": "RPA.core.locators",
        "doc": "Documentation for library ``RPA.core.locators``.",
        "version": "",
        "named_args": true,
        "scope": "GLOBAL",
        "generated": "2020-12-01 14:53:06",
        "inits": [],
        "keywords": [
            {
                "name": "Fields",
                "args": [
                    "class_or_instance"
                ],
                "doc": "Return a tuple describing the fields of this dataclass.\n\nAccepts a dataclass or an instance of one. Tuple elements are of\ntype Field.",
                "shortdoc": "Return a tuple describing the fields of this dataclass.",
                "tags": [],
                "matched": true
            },
            {
                "name": "Parse Locator",
                "args": [
                    "locator: str"
                ],
                "doc": "Construct locator from string format, e.g. 'coordinates:120,340'.",
                "shortdoc": "Construct locator from string format, e.g. 'coordinates:120,340'.",
                "tags": [],
                "matched": true
            },
            {
                "name": "Sanitize Name",
                "args": [
                    "name"
                ],
                "doc": "Sanitize locator name for use in filenames.\nSanitized name should be unique in database.\n\nExamples:\n    Google.Logo -> google-logo\n    Cool Stuff -> cool-stuff\n    What?? -> what",
                "shortdoc": "Sanitize locator name for use in filenames. Sanitized name should be unique in database.",
                "tags": [],
                "matched": true
            }
        ],
        "all_tags": [],
        "contains_tags": false
    },
    "RPA.core.locators.containers": {
        "name": "RPA.core.locators.containers",
        "doc": "Documentation for library ``RPA.core.locators.containers``.",
        "version": "",
        "named_args": true,
        "scope": "GLOBAL",
        "generated": "2020-12-01 14:53:06",
        "inits": [],
        "keywords": [
            {
                "name": "Asdict",
                "args": [
                    "obj",
                    "*",
                    "dict_factory=<class 'dict'>"
                ],
                "doc": "Return the fields of a dataclass instance as a new dictionary mapping\nfield names to field values.\n\nExample usage:\n\n  @dataclass\n  class C:\n      x: int\n      y: int\n\n  c = C(1, 2)\n  assert asdict(c) == {'x': 1, 'y': 2}\n\nIf given, 'dict_factory' will be used instead of built-in dict.\nThe function applies recursively to field values that are\ndataclass instances. This will also look into built-in containers:\ntuples, lists, and dicts.",
                "shortdoc": "Return the fields of a dataclass instance as a new dictionary mapping field names to field values.",
                "tags": [],
                "matched": true
            },
            {
                "name": "Dataclass",
                "args": [
                    "cls=None",
                    "*",
                    "init=True",
                    "repr=True",
                    "eq=True",
                    "order=False",
                    "unsafe_hash=False",
                    "frozen=False"
                ],
                "doc": "Returns the same class as was passed in, with dunder methods\nadded based on the fields defined in the class.\n\nExamines PEP 526 __annotations__ to determine fields.\n\nIf init is true, an __init__() method is added to the class. If\nrepr is true, a __repr__() method is added. If order is true, rich\ncomparison dunder methods are added. If unsafe_hash is true, a\n__hash__() method function is added. If frozen is true, fields may\nnot be assigned to after instance creation.",
                "shortdoc": "Returns the same class as was passed in, with dunder methods added based on the fields defined in the class.",
                "tags": [],
                "matched": true
            },
            {
                "name": "Fields",
                "args": [
                    "class_or_instance"
                ],
                "doc": "Return a tuple describing the fields of this dataclass.\n\nAccepts a dataclass or an instance of one. Tuple elements are of\ntype Field.",
                "shortdoc": "Return a tuple describing the fields of this dataclass.",
                "tags": [],
                "matched": true
            }
        ],
        "all_tags": [],
        "contains_tags": false
    },
    "RPA.core.locators.database": {
        "name": "RPA.core.locators.database",
        "doc": "Documentation for library ``RPA.core.locators.database``.",
        "version": "",
        "named_args": true,
        "scope": "GLOBAL",
        "generated": "2020-12-01 14:53:06",
        "inits": [],
        "keywords": [
            {
                "name": "Contextmanager",
                "args": [
                    "func"
                ],
                "doc": "@contextmanager decorator.\n\nTypical usage:\n\n    @contextmanager\n    def some_generator(<arguments>):\n        <setup>\n        try:\n            yield <value>\n        finally:\n            <cleanup>\n\nThis makes this:\n\n    with some_generator(<arguments>) as <variable>:\n        <body>\n\nequivalent to this:\n\n    <setup>\n    try:\n        <variable> = <value>\n        <body>\n    finally:\n        <cleanup>",
                "shortdoc": "@contextmanager decorator.",
                "tags": [],
                "matched": true
            },
            {
                "name": "Open Stream",
                "args": [
                    "obj",
                    "*args",
                    "**kwargs"
                ],
                "doc": "Wrapper for built-in open(), which allows using\nexisting IO streams.",
                "shortdoc": "Wrapper for built-in open(), which allows using existing IO streams.",
                "tags": [],
                "matched": true
            },
            {
                "name": "Sanitize Name",
                "args": [
                    "name"
                ],
                "doc": "Sanitize locator name for use in filenames.\nSanitized name should be unique in database.\n\nExamples:\n    Google.Logo -> google-logo\n    Cool Stuff -> cool-stuff\n    What?? -> what",
                "shortdoc": "Sanitize locator name for use in filenames. Sanitized name should be unique in database.",
                "tags": [],
                "matched": true
            }
        ],
        "all_tags": [],
        "contains_tags": false
    },
    "RPA.core.notebook": {
        "name": "RPA.core.notebook",
        "doc": "Documentation for library ``RPA.core.notebook``.",
        "version": "",
        "named_args": true,
        "scope": "GLOBAL",
        "generated": "2020-12-01 14:53:06",
        "inits": [],
        "keywords": [
            {
                "name": "Notebook Audio",
                "args": [
                    "audio"
                ],
                "doc": "Display IPython Audio object in the notebook\n\n:param audio: path to the audio file",
                "shortdoc": "Display IPython Audio object in the notebook",
                "tags": [],
                "matched": true
            },
            {
                "name": "Notebook Dir",
                "args": [
                    "directory",
                    "recursive=False"
                ],
                "doc": "Display IPython FileLinks object in the notebook\n\n:param directory: location of the directory\n:param recursive: if all subdirectories should be shown also, defaults to False",
                "shortdoc": "Display IPython FileLinks object in the notebook",
                "tags": [],
                "matched": true
            },
            {
                "name": "Notebook File",
                "args": [
                    "filepath"
                ],
                "doc": "Display IPython FileLink object in the notebook\n\n:param filepath: location of the file",
                "shortdoc": "Display IPython FileLink object in the notebook",
                "tags": [],
                "matched": true
            },
            {
                "name": "Notebook Image",
                "args": [
                    "image"
                ],
                "doc": "Display IPython Image object in the notebook\n\n:param image: path to the image file",
                "shortdoc": "Display IPython Image object in the notebook",
                "tags": [],
                "matched": true
            },
            {
                "name": "Notebook Json",
                "args": [
                    "json_object"
                ],
                "doc": "Display IPython JSON object in the notebook\n\n:param json_object: item to show",
                "shortdoc": "Display IPython JSON object in the notebook",
                "tags": [],
                "matched": true
            },
            {
                "name": "Notebook Print",
                "args": [
                    "arg=None",
                    "**kwargs"
                ],
                "doc": "Display IPython Markdown object in the notebook\n\nValid parameters are `text`, `image`, `link` or `table`.\n\n:param text: string to output (can contain markdown)\n:param image: path to the image file\n:param link: path to the link\n:param table: `RPA.Table` object to print",
                "shortdoc": "Display IPython Markdown object in the notebook",
                "tags": [],
                "matched": true
            },
            {
                "name": "Notebook Table",
                "args": [
                    "table",
                    "count: int = 20"
                ],
                "doc": "Display RPA.Table as IPython Markdown object in the notebook\n\n:param table: `RPA.Table` object to print",
                "shortdoc": "Display RPA.Table as IPython Markdown object in the notebook",
                "tags": [],
                "matched": true
            },
            {
                "name": "Notebook Video",
                "args": [
                    "video"
                ],
                "doc": "Display IPython Video object in the notebook\n\n:param video: path to the video file",
                "shortdoc": "Display IPython Video object in the notebook",
                "tags": [],
                "matched": true
            },
            {
                "name": "Print Precheck",
                "args": [
                    "f"
                ],
                "doc": "",
                "shortdoc": "",
                "tags": [],
                "matched": true
            },
            {
                "name": "Wraps",
                "args": [
                    "wrapped",
                    "assigned=('__module__', '__name__', '__qualname__', '__doc__', '__annotations__')",
                    "updated=('__dict__',)"
                ],
                "doc": "Decorator factory to apply update_wrapper() to a wrapper function\n\nReturns a decorator that invokes update_wrapper() with the decorated\nfunction as the wrapper argument and the arguments to wraps() as the\nremaining arguments. Default arguments are as for update_wrapper().\nThis is a convenience function to simplify applying partial() to\nupdate_wrapper().",
                "shortdoc": "Decorator factory to apply update_wrapper() to a wrapper function",
                "tags": [],
                "matched": true
            }
        ],
        "all_tags": [],
        "contains_tags": false
    },
    "RPA.core.types": {
        "name": "RPA.core.types",
        "doc": "Documentation for library ``RPA.core.types``.",
        "version": "",
        "named_args": true,
        "scope": "GLOBAL",
        "generated": "2020-12-01 14:53:06",
        "inits": [],
        "keywords": [
            {
                "name": "Is Dict Like",
                "args": [
                    "obj"
                ],
                "doc": "Check if `obj` behaves like a dictionary.",
                "shortdoc": "Check if `obj` behaves like a dictionary.",
                "tags": [],
                "matched": true
            },
            {
                "name": "Is List Like",
                "args": [
                    "obj"
                ],
                "doc": "Check if `obj` behaves like a list.",
                "shortdoc": "Check if `obj` behaves like a list.",
                "tags": [],
                "matched": true
            },
            {
                "name": "Is Namedtuple",
                "args": [
                    "obj"
                ],
                "doc": "Check if `obj` is a namedtuple.",
                "shortdoc": "Check if `obj` is a namedtuple.",
                "tags": [],
                "matched": true
            }
        ],
        "all_tags": [],
        "contains_tags": false
    },
    "RPA.core.webdriver": {
        "name": "RPA.core.webdriver",
        "doc": "Documentation for library ``RPA.core.webdriver``.",
        "version": "",
        "named_args": true,
        "scope": "GLOBAL",
        "generated": "2020-12-01 14:53:06",
        "inits": [],
        "keywords": [
            {
                "name": "Executable",
                "args": [
                    "browser: str",
                    "download: bool = False"
                ],
                "doc": "Get path to webdriver executable, and download it if requested.\n\n:param browser: name of browser to get webdriver for\n:param download: download driver binaries if they don't exist",
                "shortdoc": "Get path to webdriver executable, and download it if requested.",
                "tags": [],
                "matched": true
            },
            {
                "name": "Start",
                "args": [
                    "name: str",
                    "**options"
                ],
                "doc": "Start a Selenium webdriver.",
                "shortdoc": "Start a Selenium webdriver.",
                "tags": [],
                "matched": true
            }
        ],
        "all_tags": [],
        "contains_tags": false
    },
    "RPA.recognition": {
        "name": "RPA.recognition",
        "doc": "Documentation for library ``RPA.recognition``.",
        "version": "",
        "named_args": true,
        "scope": "GLOBAL",
        "generated": "2020-12-01 14:53:06",
        "inits": [],
        "keywords": [
            {
                "name": "Base64 To Image",
                "args": [
                    "text: str"
                ],
                "doc": "Convert image in base64 string to Image object.",
                "shortdoc": "Convert image in base64 string to Image object.",
                "tags": [],
                "matched": true
            },
            {
                "name": "Image To Base64",
                "args": [
                    "image: Image"
                ],
                "doc": "Convert Image object to base64 string.",
                "shortdoc": "Convert Image object to base64 string.",
                "tags": [],
                "matched": true
            }
        ],
        "all_tags": [],
        "contains_tags": false
    },
    "RPA.recognition.ocr": {
        "name": "RPA.recognition.ocr",
        "doc": "Documentation for library ``RPA.recognition.ocr``.",
        "version": "",
        "named_args": true,
        "scope": "GLOBAL",
        "generated": "2020-12-01 14:53:06",
        "inits": [],
        "keywords": [
            {
                "name": "Clamp",
                "args": [
                    "minimum: float",
                    "value: float",
                    "maximum: float"
                ],
                "doc": "Clamp value between given minimum and maximum.",
                "shortdoc": "Clamp value between given minimum and maximum.",
                "tags": [],
                "matched": true
            },
            {
                "name": "Find",
                "args": [
                    "image: typing.Union[PIL.Image.Image, pathlib.Path]",
                    "text: str",
                    "confidence: float = 80.0"
                ],
                "doc": "Scan image for text and return a list of regions\nthat contain it (or something close to it).\n\n:param image: Path to image or Image object\n:param text: Text to find in image\n:param confidence: Minimum confidence for text similaritys",
                "shortdoc": "Scan image for text and return a list of regions that contain it (or something close to it).",
                "tags": [],
                "matched": true
            },
            {
                "name": "Read",
                "args": [
                    "image: typing.Union[PIL.Image.Image, pathlib.Path]"
                ],
                "doc": "Scan image for text and return it as one string.\n\n:param image: Path to image or Image object",
                "shortdoc": "Scan image for text and return it as one string.",
                "tags": [],
                "matched": true
            },
            {
                "name": "To Image",
                "args": [
                    "obj: typing.Any"
                ],
                "doc": "Convert `obj` to instance of Pillow's Image class.",
                "shortdoc": "Convert `obj` to instance of Pillow's Image class.",
                "tags": [],
                "matched": true
            }
        ],
        "all_tags": [],
        "contains_tags": false
    },
    "RPA.recognition.templates": {
        "name": "RPA.recognition.templates",
        "doc": "Documentation for library ``RPA.recognition.templates``.",
        "version": "",
        "named_args": true,
        "scope": "GLOBAL",
        "generated": "2020-12-01 14:53:06",
        "inits": [],
        "keywords": [
            {
                "name": "Clamp",
                "args": [
                    "minimum: float",
                    "value: float",
                    "maximum: float"
                ],
                "doc": "Clamp value between given minimum and maximum.",
                "shortdoc": "Clamp value between given minimum and maximum.",
                "tags": [],
                "matched": true
            },
            {
                "name": "Find",
                "args": [
                    "image: typing.Union[PIL.Image.Image, pathlib.Path]",
                    "template: typing.Union[PIL.Image.Image, pathlib.Path]",
                    "region: Region = None",
                    "limit: int = None",
                    "confidence: float = 80.0"
                ],
                "doc": "Attempt to find the template from the given image.\n\n:param image:       Path to image or Image instance, used to search from\n:param template:    Path to image or Image instance, used to search with\n:param limit:       Limit returned results to maximum of `limit`.\n:param region:      Area to search from. Can speed up search significantly.\n:param confidence:  Confidence for matching, value between 1 and 100\n:return:            List of matching regions\n:raises ImageNotFoundError: No match was found",
                "shortdoc": "Attempt to find the template from the given image.",
                "tags": [],
                "matched": true
            },
            {
                "name": "Log 2 Lin",
                "args": [
                    "minimum: float",
                    "value: float",
                    "maximum: float"
                ],
                "doc": "Maps logarithmic scale to linear scale of same range.",
                "shortdoc": "Maps logarithmic scale to linear scale of same range.",
                "tags": [],
                "matched": true
            },
            {
                "name": "To Image",
                "args": [
                    "obj: typing.Any"
                ],
                "doc": "Convert `obj` to instance of Pillow's Image class.",
                "shortdoc": "Convert `obj` to instance of Pillow's Image class.",
                "tags": [],
                "matched": true
            }
        ],
        "all_tags": [],
        "contains_tags": false
    },
    "RPA.recognition.utils": {
        "name": "RPA.recognition.utils",
        "doc": "Documentation for library ``RPA.recognition.utils``.",
        "version": "",
        "named_args": true,
        "scope": "GLOBAL",
        "generated": "2020-12-01 14:53:06",
        "inits": [],
        "keywords": [
            {
                "name": "Base64 To Image",
                "args": [
                    "text: str"
                ],
                "doc": "Convert image in base64 string to Image object.",
                "shortdoc": "Convert image in base64 string to Image object.",
                "tags": [],
                "matched": true
            },
            {
                "name": "Clamp",
                "args": [
                    "minimum: float",
                    "value: float",
                    "maximum: float"
                ],
                "doc": "Clamp value between given minimum and maximum.",
                "shortdoc": "Clamp value between given minimum and maximum.",
                "tags": [],
                "matched": true
            },
            {
                "name": "Image To Base64",
                "args": [
                    "image: Image"
                ],
                "doc": "Convert Image object to base64 string.",
                "shortdoc": "Convert Image object to base64 string.",
                "tags": [],
                "matched": true
            },
            {
                "name": "Log 2 Lin",
                "args": [
                    "minimum: float",
                    "value: float",
                    "maximum: float"
                ],
                "doc": "Maps logarithmic scale to linear scale of same range.",
                "shortdoc": "Maps logarithmic scale to linear scale of same range.",
                "tags": [],
                "matched": true
            },
            {
                "name": "To Image",
                "args": [
                    "obj: typing.Any"
                ],
                "doc": "Convert `obj` to instance of Pillow's Image class.",
                "shortdoc": "Convert `obj` to instance of Pillow's Image class.",
                "tags": [],
                "matched": true
            }
        ],
        "all_tags": [],
        "contains_tags": false
    }
}